<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode破局攻略</title>
      <link href="2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/"/>
      <url>2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本专栏转载于<a href="https://github.com/labuladong/fucking-algorithm">Githublabuladong/fucking-algorithm</a>. 用于个人学习算法所需.</p><p>本仓库总共 60 多篇原创文章，基本上都是基于 LeetCode 的题目，涵盖了所有题型和技巧，而且一定要做到<strong>举一反三，通俗易懂</strong>，绝不是简单的代码堆砌，后面有目录。<br>我先吐槽几句。<strong>刷题刷题，刷的是题，培养的是思维，本仓库的目的就是传递这种算法思维</strong>。我要是只写一个包含 LeetCode 题目代码的仓库，有个锤子用？没有思路解释，没有思维框架，顶多写个时间复杂度，那玩意一眼就能看出来。<br>只想要答案的话很容易，题目评论区五花八门的答案，动不动就秀 python 一行代码解决，有那么多人点赞。问题是，你去做算法题，是去学习编程语言的奇技淫巧的，还是学习算法思维的呢？你的快乐，到底源自复制别人的一行代码通过测试，已完成题目 +1，还是源自自己通过逻辑推理和算法框架不看答案写出解法？<br>网上总有大佬喷我，说我写这玩意太基础了，根本没必要啰嗦。我只能说大家刷算法就是找工作吃饭的，不是打竞赛的，我也是一路摸爬滚打过来的，我们要的是清楚明白有所得，不是故弄玄虚无所指。不想办法做到通俗易懂，难道要上来先把《算法导论》吹上天，然后把人家都心怀敬仰地劝退？别的不说，公众号几万读者，PDF 版本上万次下载，联系我的出版社都好几家，说明质量还过得去吧？<br><strong>做啥事情做多了，都能发现套路的，我把各种算法套路框架总结出来，相信可以帮助其他人少走弯路</strong>。我这个纯靠自学的小童鞋，花了一年时间刷题和总结，自己写了一份算法小抄，后面有目录，这里就不废话了。</p><p><strong>PS：如果想下载此仓库到本地学习，不要用 git 命令下载，点击 GitHub 网页上的下载按钮直接下载 zip 文件，这样就不会下载 git 历史，大大加快下载速度</strong>。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>第零章、必读系列<ul><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E6%95%88%E6%96%B9%E6%B3%95">学习算法和刷题的框架思维</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%954">学习数据结构和算法读什么书</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6">动态规划解题框架</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84">动态规划答疑篇</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88">回溯算法解题框架</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3">二分查找解题框架</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7">滑动窗口解题框架</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7">双指针技巧解题框架</a></li><li><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B">Linux的进程、线程、文件描述符是什么</a></li><li><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/%E5%9C%A8%E7%BA%BF%E7%BB%83%E4%B9%A0%E5%B9%B3%E5%8F%B0">Git/SQL/正则表达式的在线练习平台</a></li></ul></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97">第一章、动态规划系列</a><ul><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6">动态规划详解</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84">动态规划答疑篇</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">动态规划设计：最长递增子序列</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">编辑距离</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98">经典动态规划问题：高楼扔鸡蛋</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E8%BF%9B%E9%98%B6">经典动态规划问题：高楼扔鸡蛋（进阶）</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF">动态规划之子序列问题解题模板</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98">动态规划之博弈问题</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98">贪心算法之区间调度问题</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8BKMP%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95">动态规划之KMP字符匹配算法</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%9B%A2%E7%81%AD%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98">团灭 LeetCode 股票买卖问题</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%8A%A2%E6%88%BF%E5%AD%90">团灭 LeetCode 打家劫舍问题</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%9B%9B%E9%94%AE%E9%94%AE%E7%9B%98">动态规划之四键键盘</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE">动态规划之正则表达</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">最长公共子序列</a></li></ul></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97">第二章、数据结构系列</a><ul><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E6%95%88%E6%96%B9%E6%B3%95">学习算法和刷题的思路指南</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%954">学习数据结构和算法读什么书</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">二叉堆详解实现优先级队列</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/LRU%E7%AE%97%E6%B3%95">LRU算法详解</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%93%8D%E4%BD%9C%E9%9B%86%E9%94%A6">二叉搜索树操作集锦</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88">特殊数据结构：单调栈</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97">特殊数据结构：单调队列</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E8%AE%BE%E8%AE%A1Twitter">设计Twitter</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">递归反转链表的一部分</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">队列实现栈|栈实现队列</a></li></ul></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97">第三章、算法思维系列</a><ul><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF">算法学习之路</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88">回溯算法详解</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%AD%90%E9%9B%86%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88">回溯算法团灭排列、组合、子集问题</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3">二分查找详解</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7">双指针技巧总结</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7">滑动窗口技巧</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/twoSum%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3">twoSum问题的核心思想</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BD%8D%E6%93%8D%E4%BD%9C">常用的位操作</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8">拆解复杂问题：实现计算器</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E7%83%A7%E9%A5%BC%E6%8E%92%E5%BA%8F">烧饼排序</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%89%8D%E7%BC%80%E5%92%8C%E6%8A%80%E5%B7%A7">前缀和技巧</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95">字符串乘法</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/FloodFill%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8">FloodFill算法详解及应用</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98%E4%B9%8B%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6">区间调度之区间合并问题</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8C%BA%E9%97%B4%E4%BA%A4%E9%9B%86%E9%97%AE%E9%A2%98">区间调度之区间交集问题</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98">信封嵌套问题</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%87%A0%E4%B8%AA%E5%8F%8D%E7%9B%B4%E8%A7%89%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98">几个反直觉的概率问题</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95">洗牌算法</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E9%80%92%E5%BD%92%E8%AF%A6%E8%A7%A3">递归详解</a></li></ul></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97">第四章、高频面试系列</a><ul><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/LRU%E7%AE%97%E6%B3%95">如何实现LRU算法</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%89%93%E5%8D%B0%E7%B4%A0%E6%95%B0">如何高效寻找素数</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">如何计算编辑距离</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/koko%E5%81%B7%E9%A6%99%E8%95%89">如何运用二分查找算法</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%8E%A5%E9%9B%A8%E6%B0%B4">如何高效解决接雨水问题</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">如何去除有序数组的重复元素</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">如何寻找最长回文子串</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">如何k个一组反转链表</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%88%A4%E5%AE%9A">如何判定括号合法性</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%B6%88%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0">如何寻找消失的元素</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E7%BC%BA%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0">如何寻找缺失和重复的元素</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">如何判断回文链表</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7">如何在无限序列中随机抽取元素</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%BA%A7%E4%BD%8D%E8%B0%83%E5%BA%A6">如何调度考生的座位</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3">Union-Find算法详解</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8">Union-Find算法应用</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E7%9A%84%E6%99%BA%E5%8A%9B%E9%A2%98">一行代码就能解决的算法题</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E5%AD%90%E5%BA%8F%E5%88%97">二分查找高效判定子序列</a></li></ul></li><li>第五章、计算机技术<ul><li><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B">Linux的进程、线程、文件描述符是什么</a></li><li><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/session%E5%92%8Ccookie">一文看懂 session 和 cookie</a></li><li><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/linuxshell">关于 Linux shell 你必须知道的</a></li><li><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF">加密算法的前身今世</a></li><li><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/%E5%9C%A8%E7%BA%BF%E7%BB%83%E4%B9%A0%E5%B9%B3%E5%8F%B0">Git/SQL/正则表达式的在线练习平台</a><h1 id="感谢如下大佬参与翻译"><a href="#感谢如下大佬参与翻译" class="headerlink" title="感谢如下大佬参与翻译"></a>感谢如下大佬参与翻译</h1>按照昵称字典序排名：<br><a href="https://github.com/ABCpril">ABCpril</a>,<br><a href="https://github.com/andavid">andavid</a>,<br><a href="https://github.com/bryceustc">bryceustc</a>,<br><a href="https://github.com/build2645">build2645</a>,<br><a href="https://github.com/CarrieOn">CarrieOn</a>,<br><a href="https://github.com/xiaochuhub">cooker</a>,<br><a href="https://github.com/Coder2Programmer">Dong Wang</a>,<br><a href="https://github.com/ExcaliburEX">ExcaliburEX</a>,<br><a href="https://github.com/floatLig">floatLig</a>,<br><a href="https://github.com/foreversolar">ForeverSolar</a>,<br><a href="https://fulinli.github.io/">Fulin Li</a>,<br><a href="https://github.com/Funnyyanne">Funnyyanne</a>,<br><a href="https://github.com/GYHHAHA">GYHHAHA</a>,<br><a href="https://hiarcher.top/">Hi_archer</a>,<br><a href="https://github.com/Iruze">Iruze</a>,<br><a href="https://github.com/Jieyixia">Jieyixia</a>,<br><a href="https://github.com/Justin-YGG">Justin</a>,<br><a href="https://github.com/Kevin-free">Kevin</a>,<br><a href="https://github.com/Lrc123">Lrc123</a>,<br><a href="https://github.com/lriy">lriy</a>,<br><a href="https://github.com/Lyjeeq">Lyjeeq</a>,<br><a href="https://greenwichmt.github.io/">MasonShu</a>,<br><a href="https://github.com/Master-cai">Master-cai</a>,<br><a href="https://github.com/miaoxiaozui2017">miaoxiaozui2017</a>,<br><a href="https://github.com/natsunoyoru97">natsunoyoru97</a>,<br><a href="https://github.com/nettee">nettee</a>,<br><a href="https://github.com/PaperJets">PaperJets</a>,<br><a href="https://github.com/qy-yang">qy-yang</a>,<br><a href="https://github.com/realism0331">realism0331</a>,<br><a href="https://github.com/HuangZiSheng001">SCUhzs</a>,<br><a href="https://github.com/Seaworth">Seaworth</a>,<br><a href="https://github.com/shazi4399">shazi4399</a>,<br><a href="https://github.com/ShuoZheLi/">ShuozheLi</a>,<br><a href="https://blog.csdn.net/SinjoyWong">sinjoywong</a>,<br><a href="https://github.com/sunqiuming526">sunqiuming526</a>,<br><a href="https://github.com/tianhaoz95">Tianhao Zhou</a>,<br><a href="https://github.com/timmmGZ">timmmGZ</a>,<br><a href="https://github.com/tommytim0515">tommytim0515</a>,<br><a href="https://github.com/upbin">upbin</a>,<br><a href="https://github.com/wadegrc">wadegrc</a>,<br><a href="https://github.com/walsvid">walsvid</a>,<br><a href="https://github.com/warmingkkk">warmingkkk</a>,<br><a href="https://github.com/Wonderxie">Wonderxie</a>,<br><a href="https://github.com/wsyzxxxx">wsyzxxxx</a>,<br><a href="https://github.com/xiaodp">xiaodp</a>,<br><a href="https://github.com/youyun">youyun</a>,<br><a href="https://github.com/yx-tan">yx-tan</a>,<br><a href="https://github.com/Mr2er0">Zero</a>,<br><a href="https://github.com/ML-ZimingMeng/LeetCode-Python3">Ziming</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jupyterlab汉化</title>
      <link href="2021/03/08/jupyterlab%E6%B1%89%E5%8C%96/"/>
      <url>2021/03/08/jupyterlab%E6%B1%89%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>mac安装jupyterlab，使用<code>pip3 install jupyterlab</code>实际上安装的还是jupyter，并不起作用，仍然需要一系列操作来完成。可以使用<code>brew install jupyterlab</code>的方式完成安装。</p><p>但此时<code>jupyterlab</code>和<code>python3</code>是什么关系呢？</p><p>实际上，<code>jupyterlab</code>依旧是引用的<code>python3</code>,而非独立安装了一份python，且两者的<code>pip</code>库通用。<code>jupyterlab</code>的库的位置在<code>/usr/local/Cellar/jupyterlab/3.0.9/libexec/lib/python3.9/site-packages</code>，而<code>python3</code>的库位置在<code>/usr/local/lib/python3.9/site-packages</code>。对于在<code>jupyterlab</code>网页界面安装的插件，会同步安装，但是通过系统<code>pip3</code>安装的，则只会安装到<code>python3</code>所在的库位置，并不会同步，且不会作用于<code>jupyterlab</code>。</p><p>比如这里我们所需要的汉化插件，<code>jupyterlab-language-pack-zh-CN</code>，若只采用默认安装的方式，并不能汉化成功，而同步安装在<code>jupyterlab</code>库的位置之后，汉化正常。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>完全卸载jupyter</title>
      <link href="2021/03/08/%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BDjupyter/"/>
      <url>2021/03/08/%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BDjupyter/</url>
      
        <content type="html"><![CDATA[<p>使用<code>pip(3) uninstall jupyter</code>的方式无法卸载完全，使用<code>pip-autoremove</code>包也如此，因而只能采用以下方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 uninstall -y jupyter<br>pip3 uninstall -y jupyter_core<br>pip3 uninstall -y jupyter-client<br>pip3 uninstall -y jupyter-console<br>pip3 uninstall -y notebook<br>pip3 uninstall -y qtconsole<br>pip3 uninstall -y nbconvert<br>pip3 uninstall -y nbformat<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网穿透-可视化frp</title>
      <link href="2020/09/14/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F-%E5%8F%AF%E8%A7%86%E5%8C%96frp/"/>
      <url>2020/09/14/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F-%E5%8F%AF%E8%A7%86%E5%8C%96frp/</url>
      
        <content type="html"><![CDATA[<h2 id="软件工具"><a href="#软件工具" class="headerlink" title="软件工具"></a>软件工具</h2><p><a href="https://www.natfrp.com/">Sakura Frp</a>(Frp二次开发，可视化)</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>注册账号并登陆</li><li>每日领取流量</li></ol><p><img src="/images/pasted-14.png" alt="upload successful"></p><ol start="3"><li>软件下载</li></ol><p><img src="/images/pasted-15.png" alt="upload successful"></p><p>推荐使用自动安装脚本，按照提示填入id和秘钥</p><p><img src="/images/pasted-16.png" alt="upload successful"></p><ol start="4"><li>添加和管理隧道</li></ol><p><img src="/images/pasted-17.png" alt="upload successful"></p><p>隧道协议分为tcp,udp,http,https,xtcp等，不同协议的区别参见网页右下方。<br>    <br>  <img src="/images/pasted-19.png" alt="upload successful"><br>  对于我们常用的远程桌面(rdp)，ssh，均可用这种方式。         </p><h3 id="服务器选择"><a href="#服务器选择" class="headerlink" title="服务器选择"></a>服务器选择</h3><p>        <br><img src="/images/pasted-20.png" alt="upload successful"><br>可建站表示支持http隧道服务映射。？M表示带宽，优先使用国内的服务器，速度较快。        </p><h3 id="TCP隧道设置"><a href="#TCP隧道设置" class="headerlink" title="TCP隧道设置"></a>TCP隧道设置</h3><p><img src="/images/pasted-21.png" alt="upload successful"></p><p>隧道名称和备注随意设置，本机地址留空即可，本地端口即为内网服务器的端口，比如ssh默认22，rdp默认3389，远程端口可以自己设置，符合规则即可，默认留空也可以。</p><p>下方的加密传输和压缩数据可打开。        </p><h3 id="HTTP隧道设置"><a href="#HTTP隧道设置" class="headerlink" title="HTTP隧道设置"></a>HTTP隧道设置</h3><p>        <br><img src="/images/pasted-22.png" alt="upload successful"><br>        和TCP协议对比，域名替代了远程端口。需要自己注册域名。绑定自己域名后，可以直接不带端口地访问自己域名。<br>        <br><img src="/images/pasted-23.png" alt="upload successful"></p><ul><li><p>备注：选择服务器时需选择 可建站的类型！</p></li><li><p>备注：建站也未必需要http隧道，使用tcp隧道也可以，但需要带端口访问。 <a href="https://gitproxy.qianqu.me/wiki/#/panel/faq?id=%e5%ae%9e%e5%90%8d%e8%ae%a4%e8%af%81%e5%88%b0%e5%ba%95%e5%8f%af%e4%bb%a5%e5%81%9a%e4%bb%80%e4%b9%88">参考链接</a>.          </p><h3 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h3><p>使用脚本安装软件后，会提示创建系统服务，按照提示输入token和隧道之后，会自动创建systemd服务。根据自身需要，可以对配置文件进行修改。<br>     <br>服务脚本类似如下：</p></li></ul><p><img src="/images/pasted-24.png" alt="upload successful"></p><p>其中被遮挡的部分为个人秘钥，数字部分为隧道列表<br>    <br><img src="/images/pasted-25.png" alt="upload successful"><br>    <br>可以看出，355729隧道正常启动，通过yfsonline.top即可访问.</p><p>对于同一个服务器的不同隧道端口，可以修改配置文件<br>    <br><img src="/images/pasted-26.png" alt="upload successful"></p><p>对于不同的服务器，比如上面所列，则对于每一个服务器需要额外配置。目前所采用的方式为新建systemd服务(很蠢但有效)，如下：<br>    <br><img src="/images/pasted-27.png" alt="upload successful"></p><p>随后通过<code>systemctl enable/restart *.service</code>的方式即可配置好服务。</p><h2 id="可能遇到的部分很蠢的问题"><a href="#可能遇到的部分很蠢的问题" class="headerlink" title="可能遇到的部分很蠢的问题"></a>可能遇到的部分很蠢的问题</h2><ol><li><p>服务无法正常启动<br>检查服务配置文件的隧道ID，里面的id为初次配置时生成的，在反复测试的过程中可能这个隧道已经被你删除了。</p></li><li><p>按教程配置好之后，依旧无法远程访问ssh服务<br>sshd端口是否输入正确？ sshd服务有没有开启？</p></li><li><p>服务配置文件中使用’command1 &amp;&amp; command2’开启两个服务后，无法正常访问服务<br>systemctl如何在一个service中开启两个进程，这个目前还没搞明白，就很蠢地手动创建另一个服务吧！</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pandas Series方法 性能测试</title>
      <link href="2020/08/14/Pandas-Series%E6%96%B9%E6%B3%95-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>2020/08/14/Pandas-Series%E6%96%B9%E6%B3%95-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>对于pandas的Series数据，进行整体的数据变换是常见的事，包括类型转换，字符串切割，数据计算等等，如何高性能地完成这些数据变换，对于大规模的数据处理至关重要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python3">import numpy as np<br>import pandas as pd<br>import timeit<br><br>a &#x3D; pd.Series(range(1000))<br><br># %timeit a.apply(lambda x:x+2)  385us<br><br>def func1(x):<br>return x + 2<br><br># %timeit func1(a) 88us<br><br># %timeit a.astype(&#39;str&#39;) 524us<br><br>def func2(x):<br>return str(x)<br><br># %timeit func2(a) 383us<br><br>b &#x3D; pd.Series([&#39;abcdefg&#39; for i in range(1000)])<br><br># %timeit b.str[3:5]  287us<br><br>def func3(x):<br>return x[3:5]<br>    <br># func3(b) mistake<br><br># 3    abcdefg<br># 4    abcdefg<br># dtype: object<br></code></pre></td></tr></table></figure><h3 id="series作为函数参数传入"><a href="#series作为函数参数传入" class="headerlink" title="series作为函数参数传入"></a>series作为函数参数传入</h3><p>series作为函数参数传入，由于未指定函数参数类型，因而该函数可以传入标量，也可以传入向量，传入向量则为向量运算。但需要注意的是，对于<code>[]</code>切片运算，如果传入的是向量，并不会对内部标量进行切割，而是对向量本身进行切割，这也导致了执行<code>func3(b)</code>的时候，没能达成我们想要的目标。由于是向量运算，这种方式执行的速度比较快。</p><h3 id="series作为主体，调用函数"><a href="#series作为主体，调用函数" class="headerlink" title="series作为主体，调用函数"></a>series作为主体，调用函数</h3><p>series作为主题，通过<code>.func</code>的形式调用函数，这种方式的速度较慢，耗时较长。尤其是通常使用的<code>.astype</code>和<code>.apply</code>，会降低运行效率。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 学习笔记</title>
      <link href="2020/08/14/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/08/14/Python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li><code>str</code>是<code>python</code>的内建数据类型</li></ul><h2 id="Pandas-Series-字符串操作"><a href="#Pandas-Series-字符串操作" class="headerlink" title="Pandas Series 字符串操作"></a>Pandas Series 字符串操作</h2><p><code>pandas</code>的series内元素为<code>str</code>类型时，如果需要对整列的字符串进行变换，是无法直接调用字符串函数的，如<code>[]</code>截取操作，<code>count</code>计数，<code>split</code>分割操作等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python3">s &#x3D; pd.Series([&#39;A&#39;,&#39;b&#39;,&#39;C&#39;,&#39;bbhello&#39;,&#39;123&#39;,np.nan,&#39;hj&#39;])<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">0          A<br>1          b<br>2          C<br>3    bbhello<br>4        123<br>5        NaN<br>6         hj<br>dtype: object<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">type(s)<br>&lt;class &#39;pandas.core.series.Series&#39;&gt;<br></code></pre></td></tr></table></figure><p>如<code>s[0:1]</code>实际上截取的是<code>series</code>的第一个元素，即<code>A</code>，而不是所有数据的第一个字母组成的<code>series</code>. 使用<code>s.count(&#39;b&#39;)</code>会提示非法调用。</p><p>为了实现序列元素的批操作，可以将<code>series</code>转化为<code>strings.StringMethods</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python3">type(s.str)<br>&lt;class &#39;pandas.core.strings.StringMethods&#39;&gt;<br></code></pre></td></tr></table></figure><p>再对<code>s.str</code>进行字符串操作就可以成功了。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">s.str.count(&#39;b&#39;)<br>0    0.0<br>1    1.0<br>2    0.0<br>3    2.0<br>4    0.0<br>5    NaN<br>6    0.0<br>dtype: float64<br></code></pre></td></tr></table></figure><p>如何对<code>Series</code>进行内部元素数据类型转换，可以使用<code>s.astype(&#39;&#39;)</code>来实现。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>windows rdp服务开启</title>
      <link href="2020/08/12/windows-rdp%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%90%AF/"/>
      <url>2020/08/12/windows-rdp%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%90%AF/</url>
      
        <content type="html"><![CDATA[<p>经过对办公室电脑一系列猛如虎的操作(安装rdpwrapper、升级企业版、升级专业版)但依旧无法远程连接rdp之后，我几乎放弃了rdp这条路，无奈地向向日葵投降。虽然能够通过网云穿和utools NAT来访问办公室电脑的jupyter服务，但处理起来数据总归是不太爽。看看高额的蒲公英rdp映射服务，还是放弃了氪金。然而，俗话说，“有志者，事竟成”，在不懈的坚持下，还是成功地得以在家连上办公室的电脑。Bingo！</p><p>远程桌面的访问其实分为三个部分：</p><h2 id="远程桌面服务器的搭建"><a href="#远程桌面服务器的搭建" class="headerlink" title="远程桌面服务器的搭建"></a>远程桌面服务器的搭建</h2><p>其实用搭建这个词不算很合适，但一时找不到合适的词，暂用此。<code>win10</code>家庭版比较尴尬的一点是，并不自带远程桌面服务器，只有企业版和专业版提供。尽管我们可以用<code>Github</code>的<code>RDP wrapper</code>来‘曲线救国’，但在当时测试时，也是bug连连，及其烦人。为了省事起见，先是用密钥升级了企业版，又用密钥升级了专业版…(我也不懂为啥当初有这种神奇操作)。考虑到使用的是公司的电脑，会不会产生法律风险。。。暂时还不知道，先不管了。</p><h2 id="公网ip"><a href="#公网ip" class="headerlink" title="公网ip"></a>公网ip</h2><p>这一步也是最为烦人的一步。我之前的<code>vps</code>服务器基本到期，没有额外的公网ip做映射。网云穿等一些列服务商也由于政策原因(真的，还是接口？)，关闭了免费的3389映射服务，并将其设为收费专线服务，一年几百大洋，太黑了。一想到自己搭建<code>vps</code>，还得买主机，配置<code>frp</code>，妈耶，要疯了。</p><p>后来发现了知乎上有人推荐的两款工具，<a href="http://www.natfrp.com/">SakuraLauncher</a>和<a href="http://www.zerotier.com/">ZeroTiger</a>. 前者是基于<code>frp</code>，开放了免费的<code>frp</code>服务线路，后者应用<code>VPN异地组网技术</code>。简单的设置后，即可实现公网<code>ip</code>的映射。</p><h2 id="rdp服务开启"><a href="#rdp服务开启" class="headerlink" title="rdp服务开启"></a>rdp服务开启</h2><p>理论上来说，以上两步完成之后，就已经可以愉快地远程办公了。但很不幸，failed。</p><p>防火墙的问题？关闭防火墙也不行。允许应用通过防火墙？该通过不该通过的都通过了也不行… = = </p><p>看着<code>frp log</code>不断地报错，心都要碎了。一直拒绝、拒绝、拒绝连接。以为是有其他应用抢占<code>3389</code>端口，但用 <code>netstat -ano | findstr 3389</code> 一直为空。</p><p>此时，灵光一现，这他喵不会是没有开启远程桌面服务导致的吧？然后赶快把本机执行了一下上面命令：</p><p><img src="/images/pasted-12.png" alt="upload successful"></p><p>你说尴尬不尴尬，办公室那台，没有开启3389服务？什么鬼，我明明什么都没有做啊！</p><p>硬着头皮上网搜，“如何开启3389服务”，找到救命稻草<a href="https://www.cnblogs.com/dsli/p/7452535.html">cmd开启3389</a><br>启发下，打开注册表，定位到<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Terminal Server</code>，修改<code>fDenyTSConnections</code>的字段为<code>0</code>，即不阻止远程连接。</p><p>备注：修改端口可以通过修改<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp</code>字段<code>PortNumber</code>来实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title=" 总结"></a> 总结</h2><p>回顾这一路，也是坑位连连。有系统的限制、网络资源的限制以及潜在的各种深坑。其中注册表那部分最初最令人困惑。怀疑是从家庭版升级到企业版后，安全策略会禁止远程访问，导致注册表字段修改。而升级到专业版后，则继承了这一点。表现为系统设置处显示可用，但本地并没监听3389端口，导致实际无法连接。<br><img src="/images/pasted-13.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>windows 批处理解压缩文件</title>
      <link href="2020/08/06/windows-%E6%89%B9%E5%A4%84%E7%90%86%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/"/>
      <url>2020/08/06/windows-%E6%89%B9%E5%A4%84%E7%90%86%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>今天在黑翼实习的过程中，廖师兄提到接下来数据处理要放到linux下的原因是数据解压的考虑。观察数据压缩的格式为7z后缀，而windows其实是有7z压缩软件的，相比能够通过命令行的形式来实现解压缩，从而结合脚本完成批量解压。</p><p>数据处理用的语言为python，最初的想法是调用python的逻辑来实现解压，后来觉得又没有太大的必要。因而考虑用bat脚本来实现。</p><p>7z的使用说明如下：</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>7z，全称7-Zip， 是一款开源软件。是目前公认的压缩比例最大的压缩解压软件。</p><ul><li>主页：<a href="http://www.7-zip.org/">http://www.7-zip.org/</a></li><li>中文主页：<a href="http://7z.sparanoid.com/">http://7z.sparanoid.com/</a></li><li>命令行版本下载：<a href="http://7z.sparanoid.com/download.html">http://7z.sparanoid.com/download.html</a></li><li>主要特征：<ul><li>全新的LZMA算法加大了7z格式的压缩比</li><li>支持格式：<ul><li>压缩 / 解压缩：7z, XZ, BZIP2, GZIP, TAR, ZIP</li><li>仅解压缩：ARJ, CAB, CHM, CPIO, DEB, DMG, FAT, HFS, ISO, LZH, LZMA, MBR, MSI, NSIS, NTFS, RAR, RPM, UDF, VHD, WIM, XAR, Z</li></ul></li></ul></li></ul><h3 id="退出代码"><a href="#退出代码" class="headerlink" title="退出代码"></a>退出代码</h3><ul><li>0 ： 正常，没有错误；</li><li>1 ： 警告，没有致命的错误，例如某些文件正在被使用，没有被压缩；</li><li>2 ： 致命错误；</li><li>7 ： 命令行错误；</li><li>8 ： 没有足够的内存；</li><li>255 ： 用户停止了操作；</li></ul><h3 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h3><p>7z &lt;命令行&gt; [&lt;选项&gt;…] &lt;基本档案名称&gt; [&lt;参数变量&gt;…]</p><ul><li>在方括号内的表达式(“[” 和 “]”之间的字符)是可选的。</li><li>在书名号内的表达式(“&lt;” 和 “&gt;”之间的字符)是必须替换的表达式(而且要去掉括号)。</li></ul><p>7-Zip 支持和 Windows 相类似的通配符：</p><ul><li>“*”可以使用星号代替零个或多个字符。 </li><li>“?”可以用问号代替名称中的单个字符。</li></ul><p>如果只用*，7-Zip 会将其视为任何扩展名的全部文件。</p><h3 id="命令及实例"><a href="#命令及实例" class="headerlink" title="命令及实例"></a>命令及实例</h3><ol><li><p>a 添加文件到压缩档案。</p><ul><li>7z a archive1.zip subdir\ ：增加subdir文件夹下的所有的文件和子文件夹到archive1.zip中，archived1.zip中的文件名包含subdir\前缀。</li><li>7z a archive2.zip .\subdir* ：增加subdir文件夹下的所有的文件和子文件夹到archive1.zip中，archived2.zip中的文件名不包含subdir\前缀。</li><li>cd /D c:\dir1\ </li><li>7z a c:\archive3.zip dir2\dir3\ ：archiive3.zip中的文件名将包含dir2\dir3\前缀，但是不包含c:\dir1前缀。</li><li>7z a Files.7z *.txt -r ： 增加当前文件夹及其子文件夹下的所有的txt文件到Files.7z中。</li></ul></li><li><p>b 测试 CPU 运行速度及检查内存错误。</p></li><li><p>d 从压缩档案删除文件。</p><ul><li>7z d archive.zip *.bak -r ：从archive.zip中删除所有的bak文件。</li></ul></li><li><p>e 从压缩档案中释放文件到当前目录中。或者到指定的输出文件夹。输出文件夹设置可以通过 -o (设置输出文件夹) 选项来更改。此命令会将所有被释放的文件放置到一个文件夹。如果您想使用完整路径释放文件，您必须使用 x (完整路径释放) 命令。 </p><ul><li>7z e archive.zip ：从压缩档案 archive.zip 中释放所有文件到当前文件夹。</li><li>7z e archive.zip -oc:\soft *.cpp ：从压缩档案 archive.zip 中释放 *.cpp 文件到 c:\soft 文件夹。</li></ul></li><li><p>l 列出压缩档案内容。</p><ul><li>7z l archiv.zip ：列出压缩档案 archive.zip 的内容。</li></ul></li><li><p>t 测试压缩档案文件的完整性。</p><ul><li>7z t archive.zip *.doc ：在压缩档案 archive.zip 中测试 *.doc 文件的完整性。</li></ul></li><li><p>u 在压缩档案文件中使用较新的文件替换掉较旧的文件。</p><ul><li>7z u archive.zip *.doc ：在压缩档案 archive.zip 中更新 *.doc 文件。</li></ul></li><li><p>x 在当前目录中，使用完整路径从压缩档案中释放文件.或者到指定的输出文件夹。<br> -7z x archive.zip ：从压缩档案 archive.zip 中释放所有文件到当前文件夹。<br> -7z x archive.zip -oc:\soft *.cpp ：从压缩档案 archive.zip 中释放 *.cpp 文件到 c:\soft 文件夹。</p></li></ol><h3 id="更多的选项"><a href="#更多的选项" class="headerlink" title="更多的选项"></a>更多的选项</h3><ol><li><p>–在命令行中使“–”后的选项开关“-”都失效。这样就允许在命令行中使用文件名以“-”开头的文件。</p><ul><li>7z t – -ArchiveName.7z ：测试 -ArchiveName.7z 压缩档案.</li></ul></li><li><p>-i 指定压缩时附加文件或一类文件。此选项可附件添加多个类型。</p><ul><li>i[<recurse_type>]<file_ref> 其中<recurse_type>为可以为r[- | 0]（具体的-r选项见后面-r），<file_ref>可以为@{listfile} | !{wildcard}。</li><li>7z a -tzip src.zip <em>.txt -ir!DIR1\</em>.cpp ：从当前目录中添加 *.txt 文件，和 DIR1 目录及其子目录中的 *.cpp 文件到 src.zip 压缩档案。</li></ul></li><li><p>-x 指定某一文件或某一类文件从操作中排除。此选项可同时排除多个类型。</p><ul><li>x[<recurse_type>]<file_ref> 其中<recurse_type>为可以为r[- | 0]（具体的-r选项见后面-r），<file_ref>可以为@{listfile} | !{wildcard}。</li><li>7z a -tzip archive.zip <em>.txt -x!temp.</em> ：添加除 temp.* 文件之外的所有 *.txt 文件到压缩档案 archive.zip。</li></ul></li><li><p>-o 指定释放文件的输出文件夹。此选项只能和释放命令配合使用。</p><ul><li>7z x archive.zip -oc:\Doc ：从 archive.zip 压缩档案释放所有文件到 c:\Doc 文件夹。</li></ul></li><li><p>-r 递归子目录选项。</p></li><li><p>-r 开启递归子目录。对于 e (释放)、l (列表)、t (测试)、x (完整路径释放) 这些在压缩档案中操作的命令， 会默认使用此选项。 </p></li><li><p>-r- 关闭递归子目录。对于 a (添加)、d (删除)、u (更新) 等所有需扫描磁盘文件的命令，会默认使用此选项。 </p></li><li><p>-r0 开启递归子目录。但只应用于通配符。 </p><ul><li>7z l archive.zip -r- *.doc ：列出在 archive.zip 压缩档案中根目录下的 *.doc 文件。 </li><li>7z a -tzip archive.zip -r src*.cpp src*.h ：将 src 目录及其子目录中的 *.cpp 及 *.h 文件添加到 archive.zip 压缩档案。</li></ul></li><li><p>-t 指定压缩档案格式。指定压缩档案格式。它们可以是：zip、7z、rar、cab、gzip、bzip2、tar 或其它格式。而 默认值是 7z 格式。 </p><ul><li>7z a -tzip archive.zip *.txt ：使用 zip 格式从当前目录中添加所有 *.txt 文件到压缩档案 archive.zip。</li></ul></li><li><p>-y 使 7-Zip 执行命令时的大多数提示失效。您可以使用此选项来阻止在 e (释放) 和 x (完整路径释放) 命令中文件覆盖时的提示。</p><ul><li>7z x src.zip -y ：从 src.zip 释放所有文件。所有的覆盖提示将被阻止且所有相同文件名的文件将被覆盖。</li></ul></li><li><p>-v指定分卷大小。</p><ul><li>{Size}[b | k | m | g] </li><li>指定分卷大小，可以使用字节、KB(1 KB＝1024 字节)，MB(1 MB = 1024 KB)或 GB(1 GB = 1024 MB)。如果您只指定了 {Size}，7-zip 将把它视为字。 </li><li>7z a a.7z *.txt -v10k -v15k -v2m ： 创建 a.7z 分卷压缩档案。第一个分卷为 10 KB，第二个为 15 KB，剩下全部为 2 MB。</li></ul></li><li><p>-p 指定密码。</p><ul><li>7z x archive.zip -psecret ：将设有密码“secret”的压缩档案 archive.zip 中所有文件释放。</li></ul></li><li><p>-ao 指定在释放期间如何覆盖硬盘上现有的同名文件。</p><ul><li>语法：-ao[a | s | u ]</li><li>-aoa 直接覆盖现有文件，而没有任何提示。 </li><li>-aos 跳过现有文件，其不会被覆盖。 </li><li>-aou 如果相同文件名的文件以存在，将自动重命名被释放的文件。举个例子，文件 file.txt 将被自动重命名为 file_1.txt。 </li><li>-aot 如果相同文件名的文件以存在，将自动重命名现有的文件。举个例子，文件 file.txt 将被自动重命名为 file_1.txt。 </li><li>7z x test.zip -aoa ：从压缩档案 test.zip 中释放所有文件并却不做提示直接覆盖现有文件。</li></ul></li><li><p>-an 不解析命令行中的 archive_name 区域。此选项必须和 -i (附加文件) 开关一起使用。比如您为压缩档案使用列表文件，您就需要指定 -ai 选项，所以您需要禁止解析命令行中的 archive_name 区域。<br>实例见后面的-ai和-ax中。</p></li><li><p>-ai 指定附加文件，包括压缩档案文件名及通配符。此选项可同时附加多个类型。</p><ul><li>ai[<recurse_type>]<file_ref> 其中<recurse_type>为可以为r[- | 0]（具体的-r选项见后面-r），<file_ref>可以为@{listfile} | !{wildcard}。</li><li>7z t -an -air!*.7z ： 在当前目录及子目录下测试 *.7z 压缩档案。</li></ul></li><li><p>-ax 指定必须从操作中排除的压缩档案。此选项可同时排除多个类型。</p><ul><li>ax[<recurse_type>]<file_ref> 其中<recurse_type>为可以为r[- | 0]（具体的-r选项见后面-r），<file_ref>可以为@{listfile} | !{wildcard}。</li><li>7z t -an -ai!<em>.7z -ax!a</em>.7z ：测试除 a*.7z 之外的 *.7z 压缩档案。</li></ul></li></ol><p>更多的不常用的选项，可以查看帮助。例如：-m设置压缩算法；-scs 设置要压缩的文件的列表文件的字符集；-seml通过电子邮件发送压缩档；-sfx创建自释放档；-si从标准输入读入数据，-so从输出到标准输出；-slp设置大内存模式；-slt显示技术信息；-ssc设置区分大小写；-ssw压缩正在写入的文件；-u更新选项。</p><p><code>7z -e</code> 后面跟的是相对路径，<code>7z -x</code>后面跟的是绝对路径。</p><p>下面是bat的脚本</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bat">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-comment">REM %cd% 终端当前目录</span><br><span class="hljs-comment">REM %%~dp0 为脚本所在目录</span><br><span class="hljs-comment">REM %%用在脚本中</span><br><span class="hljs-comment">REM %s用在命令行中</span><br><span class="hljs-comment">REM 7z x 后面跟绝对路径</span><br><span class="hljs-comment">REM 7z e 后面跟相对路径</span><br><span class="hljs-comment">REM 7z -aos 表示若文件已存在，跳过解压</span><br><span class="hljs-comment">REM 两行cd 源于 7z x -aos %%s -o%%~dps 在for循环中无法正常执行，用反复进退目录的方式曲线救国。这么做效率会下降，以后再修正。</span><br><span class="hljs-comment">REM /R 表示递归搜索</span><br><br><span class="hljs-built_in">set</span> work_path=&quot;<span class="hljs-variable">%cd%</span>&quot;<br><span class="hljs-built_in">echo</span> work_path=<span class="hljs-variable">%work_path%</span><br><span class="hljs-keyword">for</span> /R <span class="hljs-variable">%work_path%</span> <span class="hljs-variable">%%s</span> <span class="hljs-keyword">in</span> (*.<span class="hljs-number">7</span>z.<span class="hljs-number">001</span>) <span class="hljs-keyword">do</span> (<br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">%%~</span>dps<br>    <span class="hljs-number">7</span>z x -aos <span class="hljs-variable">%%s</span><br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">%work_path%</span><br>)<br></code></pre></td></tr></table></figure><ul><li>REM 表示bat脚本的注释</li><li><code>7z x -aos</code> 表示 解压到当前目录</li><li>%%s表示与<code>*.7z.001</code>匹配的文件全路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs log">%I 引用I<br>%~I         - expands %I removing any surrounding quotes (&quot;)<br>%~fI        - expands %I to a fully qualified path name<br>%~dI        - expands %I to a drive letter only<br>%~pI        - expands %I to a path only<br>%~nI        - expands %I to a file name only<br>%~xI        - expands %I to a file extension only<br>%~sI        - expanded path contains short names only<br>%~aI        - expands %I to file attributes of file<br>%~tI        - expands %I to date&#x2F;time of file<br>%~zI        - expands %I to size of file<br><br>The modifiers can be combined to get compound results:<br>%~dpI       - expands %I to a drive letter and path only<br>%~nxI       - expands %I to a file name and extension only<br>%~fsI       - expands %I to a full path name with short names only<br></code></pre></td></tr></table></figure><p>在上面，给出了cmd下提取路径或文件名的一些操作，如果用在脚本中，<code>%</code>改为<code>%%</code>即可。其中<code>I</code>表示变量，在这里，我们用的是<code>S</code>. </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>工作方向</title>
      <link href="2020/07/05/%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%90%91/"/>
      <url>2020/07/05/%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="晚饭"><a href="#晚饭" class="headerlink" title="晚饭"></a>晚饭</h2><p>董必杰、郭爽什么身份，开会内容主要是什么？我参与的意义在哪里？</p><h2 id="基金"><a href="#基金" class="headerlink" title="基金"></a>基金</h2><p>晚饭时提及，项目可能要延期开展（这部分确认一下），确认是否可行，大概日期，需要准备什么，任职岗位及预期待遇，发展前景。</p><h2 id="投资顾问"><a href="#投资顾问" class="headerlink" title="投资顾问"></a>投资顾问</h2><p>感兴趣的几个方向：</p><ol><li>教育，感觉市场比较大，投资者对这个领域关注比较多，尤其是在线教育这个行业。</li><li>文娱，受众面比较广，受舆论、热评比较较大，需要对不同产品方向的受众有一定了解。</li><li>环保，新兴领域，受政府扶持较大。</li></ol><p>教育依赖教育部，文娱依赖大企业，环保依赖政府机构。这几点都是初步的想法，有什么建议及推荐的方向，如果要做到的话，需要准备些什么？</p><h2 id="会计"><a href="#会计" class="headerlink" title="会计"></a>会计</h2><p>用友，能否进，怎么进，做什么，需要准备什么？</p><p>管理方向的会计</p><p>根据简历适合投递什么岗位？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>windows 开机自启</title>
      <link href="2020/05/14/windows-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/"/>
      <url>2020/05/14/windows-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/</url>
      
        <content type="html"><![CDATA[<p>windows开机自启软件的方式有很多，有些可以通过软件自身设置完成，有些可以通过win10 自带任务管理完成。比较便捷的方式，直接把快捷方式移到指定目录即可。</p><p><code>C:\Users\[yourname]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code></p><p>打开此目录的便捷方式为 打开<code>运行</code>，输入<code>shell:startup</code>.</p><p><img src="/images/pasted-10.png" alt="upload successful"></p><p><img src="/images/pasted-11.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vcxsrv 载入配置文件</title>
      <link href="2020/05/14/vcxsrv-%E8%BD%BD%E5%85%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>2020/05/14/vcxsrv-%E8%BD%BD%E5%85%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>vcxsrv每次通过xlauch打开时，都要用鼠标进行一系列点点点。如何能够一步到位？</p><p>只需要将快捷方式中加上参数 <code>-run</code> 即可。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">xlauch.exe -run pathofconfig<br></code></pre></td></tr></table></figure><p>如下图：</p><p><img src="/images/pasted-9.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>金融杠杆支撑天价片酬</title>
      <link href="2020/05/10/%E9%87%91%E8%9E%8D%E6%9D%A0%E6%9D%86%E6%94%AF%E6%92%91%E5%A4%A9%E4%BB%B7%E7%89%87%E9%85%AC/"/>
      <url>2020/05/10/%E9%87%91%E8%9E%8D%E6%9D%A0%E6%9D%86%E6%94%AF%E6%92%91%E5%A4%A9%E4%BB%B7%E7%89%87%E9%85%AC/</url>
      
        <content type="html"><![CDATA[<ul><li>天价片酬谁来买单？</li></ul><p><video src='https://vdn3.vzuu.com/LD/199938f0-04fd-11e9-9e14-0a580a415826.mp4?disable_local_cache=1&bu=http-com&expiration=1589112809&auth_key=1589112809-0-0-7b9c1fbcd7a294e6edcb992ecb0e227c&f=mp4'        type='video/mp4'        controls='controls'         preload="auto"       width='100%'        height='100%'><br></video></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>V2ray 共享热点</title>
      <link href="2020/05/02/V2ray-%E5%85%B1%E4%BA%AB%E7%83%AD%E7%82%B9/"/>
      <url>2020/05/02/V2ray-%E5%85%B1%E4%BA%AB%E7%83%AD%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>最近肺炎爆发, 虽然上班了但是因为公司要节省口罩, 所以大部分时间都在家里待岗, 正好电脑上已经不再用ss, ssr也准备不用了 (越来越不稳定了) 于是尝试了一下共享V2Ray的局域网连接, 很快就成功了, 闲得无事写篇博客记录一下.<br>准备</p><ol><li>电脑1台</li><li>安装好V2RayN<br>详细步骤<br>设置V2RayN<br>因为现在懒得自己弄, 所以随便找个机场, 拿到订阅链接后在V2RayN中更新节点并在设置中允许局域网连接, 同时留意一下本地监听端口, 如图显示是10808端口.</li></ol><p><img src="/images/pasted-4.png" alt="upload successful"><br>打开移动热点<br>以win10系统为例, 在设置中打开移动热点:</p><p><img src="/images/pasted-5.png" alt="upload successful"><br>然后在网络适配器选项中, 查看已经开启的热点并获取ip地址:</p><p><img src="/images/pasted-6.png" alt="upload successful"><br>连接热点<br>首先在设置中查看已开启的代理的手动设置项, 可以看到端口为10809.</p><p><img src="/images/pasted-7.png" alt="upload successful"><br>在手机上连接热点, 并手动设置代理服务器ip以及端口, 从上面步骤可知分别为: 192.168.137.1和10809.</p><p><img src="/images/pasted-8.png" alt="upload successful"><br>到这里就大功告成了, 其他类似的共享到局域网的热点都是差不多的步骤, ssr的设置也一样.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter修改外观配置</title>
      <link href="2020/04/22/Jupyter%E4%BF%AE%E6%94%B9%E5%A4%96%E8%A7%82%E9%85%8D%E7%BD%AE/"/>
      <url>2020/04/22/Jupyter%E4%BF%AE%E6%94%B9%E5%A4%96%E8%A7%82%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>jupyter默认的宽度比较小，当将浏览器全屏的时候，仅有一半的页面宽度能够得以利用，画图的时候展示的范围比较小。为了解决这个问题，只需要在设置主题时修改配置即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jt -t grade3 -cellw 90% -T<br></code></pre></td></tr></table></figure><ul><li><code>jt</code>为主题配置命令</li><li><code>-t grade3</code> 为使用<code>grade3</code>主题</li><li><code>-cellw 90%</code> 为设置单元格宽度为页面宽度的90%</li><li><code>-T</code> 为显示工具栏。</li></ul><p>效果如下图：</p><p><img src="/images/pasted-3.png" alt="upload successful"></p><p><font color='red'>备注：若使图片的宽度也变大，需要在设定TCanvas修改默认的宽度。</font></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>批量导入markdown文件为Hexo博客md文件</title>
      <link href="2020/04/11/%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5markdown%E6%96%87%E4%BB%B6%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2md%E6%96%87%E4%BB%B6/"/>
      <url>2020/04/11/%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5markdown%E6%96%87%E4%BB%B6%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2md%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>相比于普通的markdown文件，hexo的markdown文件有文件头数据，用来设定标题，创建日期，类别等信息，有时候需要批量将普通markdown文件添加头部文件数据，可以通过以下脚本实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> */*<br><span class="hljs-keyword">do</span><br>    name=`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;file%.*&#125;</span>`<br>    sed -i <span class="hljs-string">&quot;1i\title: `echo <span class="hljs-variable">$&#123;name##*/&#125;</span>`&quot;</span> <span class="hljs-variable">$file</span><br>    sed -i <span class="hljs-string">&quot;2i\author: 远方&quot;</span> <span class="hljs-variable">$file</span><br>    sed -i <span class="hljs-string">&quot;3i\tags:&quot;</span> <span class="hljs-variable">$file</span><br>    sed -i <span class="hljs-string">&quot;4i\  - LeetCode&quot;</span> <span class="hljs-variable">$file</span><br>    sed -i <span class="hljs-string">&quot;5i\  - 算法&quot;</span> <span class="hljs-variable">$file</span><br>    sed -i <span class="hljs-string">&quot;6i\categories:&quot;</span> <span class="hljs-variable">$file</span><br>    sed -i <span class="hljs-string">&quot;7i\  - LeetCode破局攻略&quot;</span> <span class="hljs-variable">$file</span><br>    sed -i <span class="hljs-string">&quot;8i\date: 2016-01-01 19:20:00&quot;</span> <span class="hljs-variable">$file</span><br>    sed -i <span class="hljs-string">&quot;9i\---&quot;</span> <span class="hljs-variable">$file</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>其中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">name=`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;file%.*&#125;</span>`<br></code></pre></td></tr></table></figure><p>截取<code>.*</code>前的字符串，表现为去后缀名，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -i <span class="hljs-string">&quot;1i\title: `echo <span class="hljs-variable">$&#123;name##*/&#125;</span>`&quot;</span> <span class="hljs-variable">$file</span><br></code></pre></td></tr></table></figure><p>从左往右截取<code>*/</code>后的数据，<code>##</code>标识截取到最后一个满足条件的，表现为去除中间路径，保留文件名。</p><ul><li><a href="https://www.cnblogs.com/kiko2014551511/p/11531558.html">参考链接</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo忽略渲染某些文件</title>
      <link href="2020/04/10/Hexo%E5%BF%BD%E7%95%A5%E6%B8%B2%E6%9F%93%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6/"/>
      <url>2020/04/10/Hexo%E5%BF%BD%E7%95%A5%E6%B8%B2%E6%9F%93%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>hexo运行时会渲染source目录下所有文件，如果需要跳过某些文件，需要在hexo根目录下的<code>_config.yml</code>文件中修改配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">skip_render:</span> <br></code></pre></td></tr></table></figure><p>为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">skip_render:</span> <span class="hljs-string">&quot;attachments/*&quot;</span><br></code></pre></td></tr></table></figure><p>如果需要跳过某些文件（如html），可以更改为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">skip_render:</span> <span class="hljs-string">&quot;attachments/*.html&quot;</span><br></code></pre></td></tr></table></figure><p>这里提一下渲染<code>html</code>与否的区别：</p><ol><li>渲染会增加hexo启动的时常</li><li>渲染后html会内嵌入hexo框架中，成为其子界面</li><li>非渲染的html会跳转到html文件，和原来的html界面一样。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo挂载本地文件</title>
      <link href="2020/04/10/Hexo%E6%8C%82%E8%BD%BD%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/"/>
      <url>2020/04/10/Hexo%E6%8C%82%E8%BD%BD%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在Hexo<code>source</code>目录下建立<code>attachments</code>目录，将本地文件拷贝到该目录下，然后通过链接的形式加载，如<code>[file](attachments/file)</code>.</p><ul><li><a href="attachments/jupyter%E7%B2%BE%E7%AE%80%E9%85%8D%E7%BD%AE.pdf">pdf测试文件</a></li><li><a href="attachments/p%CE%B3%E6%95%88%E7%8E%87%E5%88%BB%E5%BA%A6(%E6%96%B0).xlsx">office测试文件</a></li><li><a href="attachments/sed%E8%B7%A8%E8%A1%8C%E6%9B%BF%E6%8D%A2.md">markdown测试文件</a><br>html和pdf文件可以直接在浏览器中打开。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown链接跳转</title>
      <link href="2020/04/10/markdown%E9%93%BE%E6%8E%A5%E8%B7%B3%E8%BD%AC/"/>
      <url>2020/04/10/markdown%E9%93%BE%E6%8E%A5%E8%B7%B3%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>此部分内容主要应用于在线markdown链接跳转，包括Hexo和jupyter，而离线本底的链接跳转比较简单，这部分跳过。</p><h2 id="jupyter链接跳转"><a href="#jupyter链接跳转" class="headerlink" title="jupyter链接跳转"></a>jupyter链接跳转</h2><p>markdown的语法中，链接一般用<code>[描述链接](链接地址)</code>这种形式表示，图片可以理解为特殊的链接，语法为<code>![图片描述](图片地址)</code>。<br>加入两个jupyter在同一目录下，分别为1.ipynb和2.ipynb. 在2中引用1可以用相对链接的形式<code>[描述1](1.ipynb)</code>，反之也可以。另外，即使不在同一个目录，只要给出相对路径也可实现跳转。比较完整的表述可以加上全连接，但一般必要性不大，不便于迁移。比如需要把文件夹整个迁移到GitHub，使用相对链接的话，跳转依旧生效。<br>如果指定跳转到jupyter内部某个地方，则可以通过添加标签的形式来实现。在跳转的目的地处添加<code>&lt;a id=link&gt;目的地&lt;/a&gt;</code>，在跳转的起点添加<code>[起点](#link)</code>，即可完整跳转链接操作。<code>&lt;a id=link&gt;目的地&lt;/a&gt;</code>的目的在于生成一个名字为link的标签(任意名字，避免重名冲突即可)，<code>[起点](#link)</code>则直接引用该标签地址(在本文档内部，省略了链接地址，只有标签地址)。由此可以知道，地址栏#的含义为跳转到文档内部的标签。如果要在其他文档中跳转到该标签，只需要在地址栏后面加上<code>#link</code>即可，如<code>[从2跳转到1的link所在处](1.ipynb#link)</code><br><font color='red'><code>#</code>后面紧跟<code>link</code>不要加空格</font><br>此外，实际上jupyter内部在新建标题的时候(<code>#</code>一级标题 <code>##</code>二级标题…)的时候，会自动在页面创建标签，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain"># 论文题目名字<br>## 第一章名字<br>### 第一节名字<br>### 第二节名字<br>## 第二章名字<br>...<br></code></pre></td></tr></table></figure><p>通过<code>[跳转到第一章第二节](pathof.ipynb#第二节名字)</code>即可便捷实现跳转。<br><font color='red'>无论是几级标题，在引用时是等价的，都只需要一个<code>#</code>，再次强调<code>#</code>的含义是引用标签</font></p><h2 id="Hexo-链接跳转"><a href="#Hexo-链接跳转" class="headerlink" title="Hexo 链接跳转"></a>Hexo 链接跳转</h2><p>有时候需要在hexo博客中引用其他文章，此时需要处理链接的问题，和jupyter类似，需要考虑到Github平台后链接怎么处理。类似地，也可以采用相对链接的方式，但需要留意到此时引用的应该是发布后的html文件，而非原来的md文件。引用相对链接先打开目标链接，比如<code>http://localhost:4000/2020/04/01/日程表/</code>，删去<code>http://localhost:4000</code>，则<code>/2020/04/01/日程表/</code>为相对链接。<br>引用该相对链接即可实现本地和Github同步跳转。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sed跨行替换</title>
      <link href="2020/04/08/sed%E8%B7%A8%E8%A1%8C%E6%9B%BF%E6%8D%A2/"/>
      <url>2020/04/08/sed%E8%B7%A8%E8%A1%8C%E6%9B%BF%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p><code>sed</code>、<code>awk</code>、<code>grep</code>一般认为是对行操作，而实际上<code>sed</code>可以跨行操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -e <span class="hljs-string">&#x27;/替换起始字符串/!b;:a;/替换终止字符串/bb;$!&#123;N;ba&#125;;:b;s/替换起始字符串.*中间包含的特定字符串，进行限制，可以为空.*替换终止字符串/替换后的字符串/&#x27;</span> -i 操作的文件<br></code></pre></td></tr></table></figure><p>需要留意，对于特殊字符需要进行转义。</p><ul><li><code>sed -e</code>表示执行后面的脚本</li><li>每一个分号表示一行命令</li><li><code>/替换起始字符串/!b;</code></li><li><code>:a;</code></li><li><code>/替换终止字符串/bb;</code></li><li><code>$!&#123;N;ba&#125;;</code></li><li><code>:b;</code></li><li><code>s/替换起始字符串.\*中间包含的特定字符串，进行限制，可以为空.\*替换终止字符串/替换后的字符串/</code>  替换命令</li><li><code>-i</code> 修改文件</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter导出html无法显示图像</title>
      <link href="2020/04/08/Jupyter%E5%AF%BC%E5%87%BAhtml%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F/"/>
      <url>2020/04/08/Jupyter%E5%AF%BC%E5%87%BAhtml%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p>此问题是由于root版本变更引起的。<br>在<code>root v620</code><a href="https://root.cern/doc/v620/release-notes.html#release-6.2004">更新日志</a>中可以看到关于网络部分做了诸多变更。</p><h1 id="Core-Libraries"><a href="#Core-Libraries" class="headerlink" title="Core Libraries"></a>Core Libraries</h1><ul><li>Speed-up startup, in particular in case of no or poor network accesibility, by avoiding a network access that was used as input to generate a globally unique ID for the current process.</li><li>This network access is replaced by a passive scan of the network interface. This reduces somewhat the uniqueness of the unique ID as the IP address is no longer guaranteed by the DNS server to be unique. Note that this was already the case when the network access (used to look up the hostname and its IP address) failed.<h1 id="Language-Bindings"><a href="#Language-Bindings" class="headerlink" title="Language Bindings"></a>Language Bindings</h1><h2 id="Jupyter-Notebook-Integration"><a href="#Jupyter-Notebook-Integration" class="headerlink" title="Jupyter Notebook Integration"></a>Jupyter Notebook Integration</h2></li><li>When starting Jupyter server with <code>root --notebook</code> arg1 arg2 …, extra arguments can be provided. All these arguments delivered as is to jupyter executable and can be used for configuration. Like server binding to specific host <code>root --notebook --ip=hostname</code></li><li>Remove <code>c.NotebookApp.ip = &#39;*&#39; from default jupyter config</code>. One has to provide ip address for server binding using <code>root --notebook --ip=&lt;hostaddr&gt;</code> arguments</li><li>Now Jupyter Notebooks will use JSROOT provided with ROOT installation. This allows to use notebooks without internet connection (offline).<h1 id="JavaScript-ROOT"><a href="#JavaScript-ROOT" class="headerlink" title="JavaScript ROOT"></a>JavaScript ROOT</h1></li><li>Provide monitoring capabilities for TGeoManager object. Now geomtry with some tracks can be displayed and updated in web browser, using THttpServer monitoring capability like histogram objects.</li><li>JSROOT graphics are now supported in the JupyterLab interface. They are activated in the same way as in the classic Jupyter, i.e. by typing at the beginning of a notebook cell:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">%jsroon on<br></code></pre></td></tr></table></figure>从上述变更中可以解释最近版本为什么突然jupyter无法正常显示图像了。<br>root官方为了解决弱网络连接下jupyter显示问题，把jupyter的js运行库放在了新版本root安装包中，运行jupyter时会自动调用这个js库。 但是需要留意的是 <font color='red'>仅使用root –notebook这种方式启动jupyter才会生效！使用jupyter-notebook的方式启动并不会生效！！图依旧无法正常显示。</font> 而前面的博客<a href="/2020/03/25/Jupyter%E7%A6%BB%E7%BA%BF%E9%85%8D%E7%BD%AE/">Jupyter离线配置</a>中已经提过，为了解决这个问题，在jupyter的配置文件中可以新增<code>static</code>路径来解决，解决了在jupyter运行时的绘图问题。<br>但这个问题也带来了其他的问题。其一是，无法自由地分享<code>.ipynb</code>和对应导出的<code>.html</code>。分享的文件在nbviewer中无法显示图像。猜测是root更新之后把原来的链接进行了替换。<br>为了做验证，新建了一个测试linux环境，编译安装了<code>root v61902</code>，发现问题和<code>v620</code>一致，下载<code>v61802</code>并安装jupyter环境，无需任何配置，输入<code>jupyter-notebook</code>即可正常显示图像和导出有图的html文件，<code>nbviewer</code>也可正常显示上传到github的<code>.ipynb</code>文件。显然，这个版本和最初用的版本一致，在弱网条件下无法正常显示。<br>把<code>v620</code>和<code>v618</code>导出的<code>html</code>文件做对比，我们把<code>v620</code>和<code>v618</code>分别定义为<code>offline</code>和<code>online</code>。两者对应的测试文件为<a href="/attachments/offline.html"><code>offline.html</code></a>和<a href="/attachments/online.html"><code>online.html</code></a>. 点击链接即可查看.<br><del><font color='red'><br>需要留意，在本机localhost打开hexo时，online.html也无法正常画图，这是由于html挂在了localhost:4000服务上，js判断根据服务判断跳过了绘图。把该文件下载下来，用浏览器打开可以正常显示。<br></font> 此问题已修复，Hexo跳过渲染html文件之后正常运行</del></li></ul><p>用文件比对工具对比，发现两者的差异</p><h4 id="offline"><a href="#offline" class="headerlink" title="offline"></a>offline</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="javascript">    <span class="hljs-comment">// All requirements met (we are in jupyter notebooks or we loaded requirejs before).</span></span><br>    display_root_plot_1586256162911();<br><span class="javascript">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">    <span class="hljs-comment">// We are in jupyterlab, we need to insert requirejs and configure it.</span></span><br><span class="javascript">    <span class="hljs-comment">// Jupyterlab might be installed in a different base_url so we need to know it.</span></span><br><span class="javascript">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> base_url = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;jupyter-config-data&#x27;</span>).innerHTML).baseUrl;</span><br><span class="javascript">    &#125; <span class="hljs-keyword">catch</span>(_) &#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> base_url = <span class="hljs-string">&#x27;/&#x27;</span>;</span><br>    &#125;<br><span class="javascript">    <span class="hljs-comment">// Try loading a local version of requirejs and fallback to cdn if not possible.</span></span><br><span class="javascript">    requirejs_load(base_url + <span class="hljs-string">&#x27;static/components/requirejs/require.js&#x27;</span>, requirejs_success(base_url), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        requirejs_load(<span class="hljs-string">&#x27;https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js&#x27;</span>, requirejs_success(base_url), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;root_plot_1586256162911&quot;</span>).innerHTML = <span class="hljs-string">&quot;Failed to load requireJs&quot;</span>;</span><br>        &#125;);<br>    &#125;);<br>&#125;<br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requirejs_load</span>(<span class="hljs-params">src, on_load, on_error</span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);</span><br>    script.src = src;<br>    script.onload = on_load;<br>    script.onerror = on_error;<br><span class="javascript">    <span class="hljs-built_in">document</span>.head.appendChild(script);</span><br>&#125;<br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requirejs_success</span>(<span class="hljs-params">base_url</span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-built_in">require</span>.config(&#123;</span><br><span class="javascript">            baseUrl: base_url + <span class="hljs-string">&#x27;static/&#x27;</span></span><br>        &#125;);<br>        display_root_plot_1586256162911();<br>    &#125;<br>&#125;<br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">display_root_plot_1586256162911</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;scripts/JSRootCore&#x27;</span>],</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Core</span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> obj = Core.JSONR_unref(&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TCanvas&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">3342344</span>,<span class="hljs-string">&quot;fLineColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineWidth&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFillColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fFillStyle&quot;</span>:<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;fLeftMargin&quot;</span>:<span class="hljs-number">0.1</span>,<span class="hljs-string">&quot;fRightMargin&quot;</span>:<span class="hljs-number">0.1</span>,<span class="hljs-string">&quot;fBottomMargin&quot;</span>:<span class="hljs-number">0.1</span>,<span class="hljs-string">&quot;fTopMargin&quot;</span>:<span class="hljs-number">0.1</span>,<span class="hljs-string">&quot;fXfile&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fYfile&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fAfile&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fXstat&quot;</span>:<span class="hljs-number">0.99</span>,<span class="hljs-string">&quot;fYstat&quot;</span>:<span class="hljs-number">0.99</span>,<span class="hljs-string">&quot;fAstat&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fFrameFillColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fFrameLineColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFrameFillStyle&quot;</span>:<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;fFrameLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFrameLineWidth&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFrameBorderSize&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFrameBorderMode&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fX1&quot;</span>:<span class="hljs-number">-91.2875068014492</span>,<span class="hljs-string">&quot;fY1&quot;</span>:<span class="hljs-number">-136.475010235236</span>,<span class="hljs-string">&quot;fX2&quot;</span>:<span class="hljs-number">821.587506801449</span>,<span class="hljs-string">&quot;fY2&quot;</span>:<span class="hljs-number">1237.27501023524</span>,<span class="hljs-string">&quot;fXtoAbsPixelk&quot;</span>:<span class="hljs-number">69.6000541484835</span>,<span class="hljs-string">&quot;fXtoPixelk&quot;</span>:<span class="hljs-number">69.6000541484835</span>,<span class="hljs-string">&quot;fXtoPixel&quot;</span>:<span class="hljs-number">0.762426388748505</span>,<span class="hljs-string">&quot;fYtoAbsPixelk&quot;</span>:<span class="hljs-number">425.109273751662</span>,<span class="hljs-string">&quot;fYtoPixelk&quot;</span>:<span class="hljs-number">425.109273751662</span>,<span class="hljs-string">&quot;fYtoPixel&quot;</span>:<span class="hljs-number">-0.343585072223222</span>,<span class="hljs-string">&quot;fUtoAbsPixelk&quot;</span>:<span class="hljs-number">5e-5</span>,<span class="hljs-string">&quot;fUtoPixelk&quot;</span>:<span class="hljs-number">5e-5</span>,<span class="hljs-string">&quot;fUtoPixel&quot;</span>:<span class="hljs-number">696</span>,<span class="hljs-string">&quot;fVtoAbsPixelk&quot;</span>:<span class="hljs-number">472.00005</span>,<span class="hljs-string">&quot;fVtoPixelk&quot;</span>:<span class="hljs-number">472</span>,<span class="hljs-string">&quot;fVtoPixel&quot;</span>:<span class="hljs-number">-472</span>,<span class="hljs-string">&quot;fAbsPixeltoXk&quot;</span>:<span class="hljs-number">-91.2875068014492</span>,<span class="hljs-string">&quot;fPixeltoXk&quot;</span>:<span class="hljs-number">-91.2875068014492</span>,<span class="hljs-string">&quot;fPixeltoX&quot;</span>:<span class="hljs-number">1.31160203103865</span>,<span class="hljs-string">&quot;fAbsPixeltoYk&quot;</span>:<span class="hljs-number">1237.27501023524</span>,<span class="hljs-string">&quot;fPixeltoYk&quot;</span>:<span class="hljs-number">-136.475010235236</span>,<span class="hljs-string">&quot;fPixeltoY&quot;</span>:<span class="hljs-number">-2.91048733150524</span>,<span class="hljs-string">&quot;fXlowNDC&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fYlowNDC&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fXUpNDC&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fYUpNDC&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fWNDC&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fHNDC&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fAbsXlowNDC&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fAbsYlowNDC&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fAbsWNDC&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fAbsHNDC&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fUxmin&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fUymin&quot;</span>:<span class="hljs-number">0.9</span>,<span class="hljs-string">&quot;fUxmax&quot;</span>:<span class="hljs-number">730.3</span>,<span class="hljs-string">&quot;fUymax&quot;</span>:<span class="hljs-number">1099.9</span>,<span class="hljs-string">&quot;fTheta&quot;</span>:<span class="hljs-number">30</span>,<span class="hljs-string">&quot;fPhi&quot;</span>:<span class="hljs-number">30</span>,<span class="hljs-string">&quot;fAspectRatio&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fNumber&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTickx&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTicky&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLogx&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLogy&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLogz&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fPadPaint&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fCrosshair&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fCrosshairPos&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBorderSize&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fBorderMode&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fModified&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fGridx&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fGridy&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fAbsCoord&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fEditable&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;fFixedAspectRatio&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fPrimitives&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TList&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;TList&quot;</span>,<span class="hljs-string">&quot;arr&quot;</span>:[&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TFrame&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">8</span>,<span class="hljs-string">&quot;fLineColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineWidth&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFillColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fFillStyle&quot;</span>:<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;fX1&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fY1&quot;</span>:<span class="hljs-number">0.9</span>,<span class="hljs-string">&quot;fX2&quot;</span>:<span class="hljs-number">730.3</span>,<span class="hljs-string">&quot;fY2&quot;</span>:<span class="hljs-number">1099.9</span>,<span class="hljs-string">&quot;fBorderSize&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fBorderMode&quot;</span>:<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TGraph&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">1032</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fLineColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineWidth&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFillColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fFillStyle&quot;</span>:<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;fMarkerColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fMarkerStyle&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;fMarkerSize&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fNpoints&quot;</span>:<span class="hljs-number">664</span>,<span class="hljs-string">&quot;fX&quot;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">27</span>,<span class="hljs-number">28</span>,<span class="hljs-number">29</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">34</span>,<span class="hljs-number">35</span>,<span class="hljs-number">36</span>,<span class="hljs-number">37</span>,<span class="hljs-number">38</span>,<span class="hljs-number">39</span>,<span class="hljs-number">40</span>,<span class="hljs-number">41</span>,<span class="hljs-number">42</span>,<span class="hljs-number">43</span>,<span class="hljs-number">44</span>,<span class="hljs-number">45</span>,<span class="hljs-number">46</span>,<span class="hljs-number">47</span>,<span class="hljs-number">48</span>,<span class="hljs-number">49</span>,<span class="hljs-number">50</span>,<span class="hljs-number">51</span>,<span class="hljs-number">52</span>,<span class="hljs-number">53</span>,<span class="hljs-number">54</span>,<span class="hljs-number">55</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">58</span>,<span class="hljs-number">59</span>,<span class="hljs-number">60</span>,<span class="hljs-number">61</span>,<span class="hljs-number">62</span>,<span class="hljs-number">63</span>,<span class="hljs-number">64</span>,<span class="hljs-number">65</span>,<span class="hljs-number">66</span>,<span class="hljs-number">67</span>,<span class="hljs-number">68</span>,<span class="hljs-number">69</span>,<span class="hljs-number">70</span>,<span class="hljs-number">71</span>,<span class="hljs-number">72</span>,<span class="hljs-number">73</span>,<span class="hljs-number">74</span>,<span class="hljs-number">75</span>,<span class="hljs-number">76</span>,<span class="hljs-number">77</span>,<span class="hljs-number">78</span>,<span class="hljs-number">79</span>,<span class="hljs-number">80</span>,<span class="hljs-number">81</span>,<span class="hljs-number">82</span>,<span class="hljs-number">83</span>,<span class="hljs-number">84</span>,<span class="hljs-number">85</span>,<span class="hljs-number">86</span>,<span class="hljs-number">87</span>,<span class="hljs-number">88</span>,<span class="hljs-number">89</span>,<span class="hljs-number">90</span>,<span class="hljs-number">91</span>,<span class="hljs-number">92</span>,<span class="hljs-number">93</span>,<span class="hljs-number">94</span>,<span class="hljs-number">95</span>,<span class="hljs-number">96</span>,<span class="hljs-number">97</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>,<span class="hljs-number">100</span>,<span class="hljs-number">101</span>,<span class="hljs-number">102</span>,<span class="hljs-number">103</span>,<span class="hljs-number">104</span>,<span class="hljs-number">105</span>,<span class="hljs-number">106</span>,<span class="hljs-number">107</span>,<span class="hljs-number">108</span>,<span class="hljs-number">109</span>,<span class="hljs-number">110</span>,<span class="hljs-number">111</span>,<span class="hljs-number">112</span>,<span class="hljs-number">113</span>,<span class="hljs-number">114</span>,<span class="hljs-number">115</span>,<span class="hljs-number">116</span>,<span class="hljs-number">117</span>,<span class="hljs-number">118</span>,<span class="hljs-number">119</span>,<span class="hljs-number">120</span>,<span class="hljs-number">121</span>,<span class="hljs-number">122</span>,<span class="hljs-number">123</span>,<span class="hljs-number">124</span>,<span class="hljs-number">125</span>,<span class="hljs-number">126</span>,<span class="hljs-number">127</span>,<span class="hljs-number">128</span>,<span class="hljs-number">129</span>,<span class="hljs-number">130</span>,<span class="hljs-number">131</span>,<span class="hljs-number">132</span>,<span class="hljs-number">133</span>,<span class="hljs-number">134</span>,<span class="hljs-number">135</span>,<span class="hljs-number">136</span>,<span class="hljs-number">137</span>,<span class="hljs-number">138</span>,<span class="hljs-number">139</span>,<span class="hljs-number">140</span>,<span class="hljs-number">141</span>,<span class="hljs-number">142</span>,<span class="hljs-number">143</span>,<span class="hljs-number">144</span>,<span class="hljs-number">145</span>,<span class="hljs-number">146</span>,<span class="hljs-number">147</span>,<span class="hljs-number">148</span>,<span class="hljs-number">149</span>,<span class="hljs-number">150</span>,<span class="hljs-number">151</span>,<span class="hljs-number">152</span>,<span class="hljs-number">153</span>,<span class="hljs-number">154</span>,<span class="hljs-number">155</span>,<span class="hljs-number">156</span>,<span class="hljs-number">157</span>,<span class="hljs-number">158</span>,<span class="hljs-number">159</span>,<span class="hljs-number">160</span>,<span class="hljs-number">161</span>,<span class="hljs-number">162</span>,<span class="hljs-number">163</span>,<span class="hljs-number">164</span>,<span class="hljs-number">165</span>,<span class="hljs-number">166</span>,<span class="hljs-number">167</span>,<span class="hljs-number">168</span>,<span class="hljs-number">169</span>,<span class="hljs-number">170</span>,<span class="hljs-number">171</span>,<span class="hljs-number">172</span>,<span class="hljs-number">173</span>,<span class="hljs-number">174</span>,<span class="hljs-number">175</span>,<span class="hljs-number">176</span>,<span class="hljs-number">177</span>,<span class="hljs-number">178</span>,<span class="hljs-number">179</span>,<span class="hljs-number">180</span>,<span class="hljs-number">181</span>,<span class="hljs-number">182</span>,<span class="hljs-number">183</span>,<span class="hljs-number">184</span>,<span class="hljs-number">185</span>,<span class="hljs-number">186</span>,<span class="hljs-number">187</span>,<span class="hljs-number">188</span>,<span class="hljs-number">189</span>,<span class="hljs-number">190</span>,<span class="hljs-number">191</span>,<span class="hljs-number">192</span>,<span class="hljs-number">193</span>,<span class="hljs-number">194</span>,<span class="hljs-number">195</span>,<span class="hljs-number">196</span>,<span class="hljs-number">197</span>,<span class="hljs-number">198</span>,<span class="hljs-number">199</span>,<span class="hljs-number">200</span>,<span class="hljs-number">201</span>,<span class="hljs-number">202</span>,<span class="hljs-number">203</span>,<span class="hljs-number">204</span>,<span class="hljs-number">205</span>,<span class="hljs-number">206</span>,<span class="hljs-number">207</span>,<span class="hljs-number">208</span>,<span class="hljs-number">209</span>,<span class="hljs-number">210</span>,<span class="hljs-number">211</span>,<span class="hljs-number">212</span>,<span class="hljs-number">213</span>,<span class="hljs-number">214</span>,<span class="hljs-number">215</span>,<span class="hljs-number">216</span>,<span class="hljs-number">217</span>,<span class="hljs-number">218</span>,<span class="hljs-number">219</span>,<span class="hljs-number">220</span>,<span class="hljs-number">221</span>,<span class="hljs-number">222</span>,<span class="hljs-number">223</span>,<span class="hljs-number">224</span>,<span class="hljs-number">225</span>,<span class="hljs-number">226</span>,<span class="hljs-number">227</span>,<span class="hljs-number">228</span>,<span class="hljs-number">229</span>,<span class="hljs-number">230</span>,<span class="hljs-number">231</span>,<span class="hljs-number">232</span>,<span class="hljs-number">233</span>,<span class="hljs-number">234</span>,<span class="hljs-number">235</span>,<span class="hljs-number">236</span>,<span class="hljs-number">237</span>,<span class="hljs-number">238</span>,<span class="hljs-number">239</span>,<span class="hljs-number">240</span>,<span class="hljs-number">241</span>,<span class="hljs-number">242</span>,<span class="hljs-number">243</span>,<span class="hljs-number">244</span>,<span class="hljs-number">245</span>,<span class="hljs-number">246</span>,<span class="hljs-number">247</span>,<span class="hljs-number">248</span>,<span class="hljs-number">249</span>,<span class="hljs-number">250</span>,<span class="hljs-number">251</span>,<span class="hljs-number">252</span>,<span class="hljs-number">253</span>,<span class="hljs-number">254</span>,<span class="hljs-number">255</span>,<span class="hljs-number">256</span>,<span class="hljs-number">257</span>,<span class="hljs-number">258</span>,<span class="hljs-number">259</span>,<span class="hljs-number">260</span>,<span class="hljs-number">261</span>,<span class="hljs-number">262</span>,<span class="hljs-number">263</span>,<span class="hljs-number">264</span>,<span class="hljs-number">265</span>,<span class="hljs-number">266</span>,<span class="hljs-number">267</span>,<span class="hljs-number">268</span>,<span class="hljs-number">269</span>,<span class="hljs-number">270</span>,<span class="hljs-number">271</span>,<span class="hljs-number">272</span>,<span class="hljs-number">273</span>,<span class="hljs-number">274</span>,<span class="hljs-number">275</span>,<span class="hljs-number">276</span>,<span class="hljs-number">277</span>,<span class="hljs-number">278</span>,<span class="hljs-number">279</span>,<span class="hljs-number">280</span>,<span class="hljs-number">281</span>,<span class="hljs-number">282</span>,<span class="hljs-number">283</span>,<span class="hljs-number">284</span>,<span class="hljs-number">285</span>,<span class="hljs-number">286</span>,<span class="hljs-number">287</span>,<span class="hljs-number">288</span>,<span class="hljs-number">289</span>,<span class="hljs-number">290</span>,<span class="hljs-number">291</span>,<span class="hljs-number">292</span>,<span class="hljs-number">293</span>,<span class="hljs-number">294</span>,<span class="hljs-number">295</span>,<span class="hljs-number">296</span>,<span class="hljs-number">297</span>,<span class="hljs-number">298</span>,<span class="hljs-number">299</span>,<span class="hljs-number">300</span>,<span class="hljs-number">301</span>,<span class="hljs-number">302</span>,<span class="hljs-number">303</span>,<span class="hljs-number">304</span>,<span class="hljs-number">305</span>,<span class="hljs-number">306</span>,<span class="hljs-number">307</span>,<span class="hljs-number">308</span>,<span class="hljs-number">309</span>,<span class="hljs-number">310</span>,<span class="hljs-number">311</span>,<span class="hljs-number">312</span>,<span class="hljs-number">313</span>,<span class="hljs-number">314</span>,<span class="hljs-number">315</span>,<span class="hljs-number">316</span>,<span class="hljs-number">317</span>,<span class="hljs-number">318</span>,<span class="hljs-number">319</span>,<span class="hljs-number">320</span>,<span class="hljs-number">321</span>,<span class="hljs-number">322</span>,<span class="hljs-number">323</span>,<span class="hljs-number">324</span>,<span class="hljs-number">325</span>,<span class="hljs-number">326</span>,<span class="hljs-number">327</span>,<span class="hljs-number">328</span>,<span class="hljs-number">329</span>,<span class="hljs-number">330</span>,<span class="hljs-number">331</span>,<span class="hljs-number">332</span>,<span class="hljs-number">333</span>,<span class="hljs-number">334</span>,<span class="hljs-number">335</span>,<span class="hljs-number">336</span>,<span class="hljs-number">337</span>,<span class="hljs-number">338</span>,<span class="hljs-number">339</span>,<span class="hljs-number">340</span>,<span class="hljs-number">341</span>,<span class="hljs-number">342</span>,<span class="hljs-number">343</span>,<span class="hljs-number">344</span>,<span class="hljs-number">345</span>,<span class="hljs-number">346</span>,<span class="hljs-number">347</span>,<span class="hljs-number">348</span>,<span class="hljs-number">349</span>,<span class="hljs-number">350</span>,<span class="hljs-number">351</span>,<span class="hljs-number">352</span>,<span class="hljs-number">353</span>,<span class="hljs-number">354</span>,<span class="hljs-number">355</span>,<span class="hljs-number">356</span>,<span class="hljs-number">357</span>,<span class="hljs-number">358</span>,<span class="hljs-number">359</span>,<span class="hljs-number">360</span>,<span class="hljs-number">361</span>,<span class="hljs-number">362</span>,<span class="hljs-number">363</span>,<span class="hljs-number">364</span>,<span class="hljs-number">365</span>,<span class="hljs-number">366</span>,<span class="hljs-number">367</span>,<span class="hljs-number">368</span>,<span class="hljs-number">369</span>,<span class="hljs-number">370</span>,<span class="hljs-number">371</span>,<span class="hljs-number">372</span>,<span class="hljs-number">373</span>,<span class="hljs-number">374</span>,<span class="hljs-number">375</span>,<span class="hljs-number">376</span>,<span class="hljs-number">377</span>,<span class="hljs-number">378</span>,<span class="hljs-number">379</span>,<span class="hljs-number">380</span>,<span class="hljs-number">381</span>,<span class="hljs-number">382</span>,<span class="hljs-number">383</span>,<span class="hljs-number">384</span>,<span class="hljs-number">385</span>,<span class="hljs-number">386</span>,<span class="hljs-number">387</span>,<span class="hljs-number">388</span>,<span class="hljs-number">389</span>,<span class="hljs-number">390</span>,<span class="hljs-number">391</span>,<span class="hljs-number">392</span>,<span class="hljs-number">393</span>,<span class="hljs-number">394</span>,<span class="hljs-number">395</span>,<span class="hljs-number">396</span>,<span class="hljs-number">397</span>,<span class="hljs-number">398</span>,<span class="hljs-number">399</span>,<span class="hljs-number">400</span>,<span class="hljs-number">401</span>,<span class="hljs-number">402</span>,<span class="hljs-number">403</span>,<span class="hljs-number">404</span>,<span class="hljs-number">405</span>,<span class="hljs-number">406</span>,<span class="hljs-number">407</span>,<span class="hljs-number">408</span>,<span class="hljs-number">409</span>,<span class="hljs-number">410</span>,<span class="hljs-number">411</span>,<span class="hljs-number">412</span>,<span class="hljs-number">413</span>,<span class="hljs-number">414</span>,<span class="hljs-number">415</span>,<span class="hljs-number">416</span>,<span class="hljs-number">417</span>,<span class="hljs-number">418</span>,<span class="hljs-number">419</span>,<span class="hljs-number">420</span>,<span class="hljs-number">421</span>,<span class="hljs-number">422</span>,<span class="hljs-number">423</span>,<span class="hljs-number">424</span>,<span class="hljs-number">425</span>,<span class="hljs-number">426</span>,<span class="hljs-number">427</span>,<span class="hljs-number">428</span>,<span class="hljs-number">429</span>,<span class="hljs-number">430</span>,<span class="hljs-number">431</span>,<span class="hljs-number">432</span>,<span class="hljs-number">433</span>,<span class="hljs-number">434</span>,<span class="hljs-number">435</span>,<span class="hljs-number">436</span>,<span class="hljs-number">437</span>,<span class="hljs-number">438</span>,<span class="hljs-number">439</span>,<span class="hljs-number">440</span>,<span class="hljs-number">441</span>,<span class="hljs-number">442</span>,<span class="hljs-number">443</span>,<span class="hljs-number">444</span>,<span class="hljs-number">445</span>,<span class="hljs-number">446</span>,<span class="hljs-number">447</span>,<span class="hljs-number">448</span>,<span class="hljs-number">449</span>,<span class="hljs-number">450</span>,<span class="hljs-number">451</span>,<span class="hljs-number">452</span>,<span class="hljs-number">453</span>,<span class="hljs-number">454</span>,<span class="hljs-number">455</span>,<span class="hljs-number">456</span>,<span class="hljs-number">457</span>,<span class="hljs-number">458</span>,<span class="hljs-number">459</span>,<span class="hljs-number">460</span>,<span class="hljs-number">461</span>,<span class="hljs-number">462</span>,<span class="hljs-number">463</span>,<span class="hljs-number">464</span>,<span class="hljs-number">465</span>,<span class="hljs-number">466</span>,<span class="hljs-number">467</span>,<span class="hljs-number">468</span>,<span class="hljs-number">469</span>,<span class="hljs-number">470</span>,<span class="hljs-number">471</span>,<span class="hljs-number">472</span>,<span class="hljs-number">473</span>,<span class="hljs-number">474</span>,<span class="hljs-number">475</span>,<span class="hljs-number">476</span>,<span class="hljs-number">477</span>,<span class="hljs-number">478</span>,<span class="hljs-number">479</span>,<span class="hljs-number">480</span>,<span class="hljs-number">481</span>,<span class="hljs-number">482</span>,<span class="hljs-number">483</span>,<span class="hljs-number">484</span>,<span class="hljs-number">485</span>,<span class="hljs-number">486</span>,<span class="hljs-number">487</span>,<span class="hljs-number">488</span>,<span class="hljs-number">489</span>,<span class="hljs-number">490</span>,<span class="hljs-number">491</span>,<span class="hljs-number">492</span>,<span class="hljs-number">493</span>,<span class="hljs-number">494</span>,<span class="hljs-number">495</span>,<span class="hljs-number">496</span>,<span class="hljs-number">497</span>,<span class="hljs-number">498</span>,<span class="hljs-number">499</span>,<span class="hljs-number">500</span>,<span class="hljs-number">501</span>,<span class="hljs-number">502</span>,<span class="hljs-number">503</span>,<span class="hljs-number">504</span>,<span class="hljs-number">505</span>,<span class="hljs-number">506</span>,<span class="hljs-number">507</span>,<span class="hljs-number">508</span>,<span class="hljs-number">509</span>,<span class="hljs-number">510</span>,<span class="hljs-number">511</span>,<span class="hljs-number">512</span>,<span class="hljs-number">513</span>,<span class="hljs-number">514</span>,<span class="hljs-number">515</span>,<span class="hljs-number">516</span>,<span class="hljs-number">517</span>,<span class="hljs-number">518</span>,<span class="hljs-number">519</span>,<span class="hljs-number">520</span>,<span class="hljs-number">521</span>,<span class="hljs-number">522</span>,<span class="hljs-number">523</span>,<span class="hljs-number">524</span>,<span class="hljs-number">525</span>,<span class="hljs-number">526</span>,<span class="hljs-number">527</span>,<span class="hljs-number">528</span>,<span class="hljs-number">529</span>,<span class="hljs-number">530</span>,<span class="hljs-number">531</span>,<span class="hljs-number">532</span>,<span class="hljs-number">533</span>,<span class="hljs-number">534</span>,<span class="hljs-number">535</span>,<span class="hljs-number">536</span>,<span class="hljs-number">537</span>,<span class="hljs-number">538</span>,<span class="hljs-number">539</span>,<span class="hljs-number">540</span>,<span class="hljs-number">541</span>,<span class="hljs-number">542</span>,<span class="hljs-number">543</span>,<span class="hljs-number">544</span>,<span class="hljs-number">545</span>,<span class="hljs-number">546</span>,<span class="hljs-number">547</span>,<span class="hljs-number">548</span>,<span class="hljs-number">549</span>,<span class="hljs-number">550</span>,<span class="hljs-number">551</span>,<span class="hljs-number">552</span>,<span class="hljs-number">553</span>,<span class="hljs-number">554</span>,<span class="hljs-number">555</span>,<span class="hljs-number">556</span>,<span class="hljs-number">557</span>,<span class="hljs-number">558</span>,<span class="hljs-number">559</span>,<span class="hljs-number">560</span>,<span class="hljs-number">561</span>,<span class="hljs-number">562</span>,<span class="hljs-number">563</span>,<span class="hljs-number">564</span>,<span class="hljs-number">565</span>,<span class="hljs-number">566</span>,<span class="hljs-number">567</span>,<span class="hljs-number">568</span>,<span class="hljs-number">569</span>,<span class="hljs-number">570</span>,<span class="hljs-number">571</span>,<span class="hljs-number">572</span>,<span class="hljs-number">573</span>,<span class="hljs-number">574</span>,<span class="hljs-number">575</span>,<span class="hljs-number">576</span>,<span class="hljs-number">577</span>,<span class="hljs-number">578</span>,<span class="hljs-number">579</span>,<span class="hljs-number">580</span>,<span class="hljs-number">581</span>,<span class="hljs-number">582</span>,<span class="hljs-number">583</span>,<span class="hljs-number">584</span>,<span class="hljs-number">585</span>,<span class="hljs-number">586</span>,<span class="hljs-number">587</span>,<span class="hljs-number">588</span>,<span class="hljs-number">589</span>,<span class="hljs-number">590</span>,<span class="hljs-number">591</span>,<span class="hljs-number">592</span>,<span class="hljs-number">593</span>,<span class="hljs-number">594</span>,<span class="hljs-number">595</span>,<span class="hljs-number">596</span>,<span class="hljs-number">597</span>,<span class="hljs-number">598</span>,<span class="hljs-number">599</span>,<span class="hljs-number">600</span>,<span class="hljs-number">601</span>,<span class="hljs-number">602</span>,<span class="hljs-number">603</span>,<span class="hljs-number">604</span>,<span class="hljs-number">605</span>,<span class="hljs-number">606</span>,<span class="hljs-number">607</span>,<span class="hljs-number">608</span>,<span class="hljs-number">609</span>,<span class="hljs-number">610</span>,<span class="hljs-number">611</span>,<span class="hljs-number">612</span>,<span class="hljs-number">613</span>,<span class="hljs-number">614</span>,<span class="hljs-number">615</span>,<span class="hljs-number">616</span>,<span class="hljs-number">617</span>,<span class="hljs-number">618</span>,<span class="hljs-number">619</span>,<span class="hljs-number">620</span>,<span class="hljs-number">621</span>,<span class="hljs-number">622</span>,<span class="hljs-number">623</span>,<span class="hljs-number">624</span>,<span class="hljs-number">625</span>,<span class="hljs-number">626</span>,<span class="hljs-number">627</span>,<span class="hljs-number">628</span>,<span class="hljs-number">629</span>,<span class="hljs-number">630</span>,<span class="hljs-number">631</span>,<span class="hljs-number">632</span>,<span class="hljs-number">633</span>,<span class="hljs-number">634</span>,<span class="hljs-number">635</span>,<span class="hljs-number">636</span>,<span class="hljs-number">637</span>,<span class="hljs-number">638</span>,<span class="hljs-number">639</span>,<span class="hljs-number">640</span>,<span class="hljs-number">641</span>,<span class="hljs-number">642</span>,<span class="hljs-number">643</span>,<span class="hljs-number">644</span>,<span class="hljs-number">645</span>,<span class="hljs-number">646</span>,<span class="hljs-number">647</span>,<span class="hljs-number">648</span>,<span class="hljs-number">649</span>,<span class="hljs-number">650</span>,<span class="hljs-number">651</span>,<span class="hljs-number">652</span>,<span class="hljs-number">653</span>,<span class="hljs-number">654</span>,<span class="hljs-number">655</span>,<span class="hljs-number">656</span>,<span class="hljs-number">657</span>,<span class="hljs-number">658</span>,<span class="hljs-number">659</span>,<span class="hljs-number">660</span>,<span class="hljs-number">661</span>,<span class="hljs-number">662</span>,<span class="hljs-number">663</span>,<span class="hljs-number">664</span>],<span class="hljs-string">&quot;fY&quot;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">18</span>,<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">27</span>,<span class="hljs-number">29</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">36</span>,<span class="hljs-number">37</span>,<span class="hljs-number">38</span>,<span class="hljs-number">42</span>,<span class="hljs-number">44</span>,<span class="hljs-number">45</span>,<span class="hljs-number">48</span>,<span class="hljs-number">49</span>,<span class="hljs-number">52</span>,<span class="hljs-number">53</span>,<span class="hljs-number">54</span>,<span class="hljs-number">55</span>,<span class="hljs-number">58</span>,<span class="hljs-number">60</span>,<span class="hljs-number">62</span>,<span class="hljs-number">63</span>,<span class="hljs-number">64</span>,<span class="hljs-number">66</span>,<span class="hljs-number">70</span>,<span class="hljs-number">71</span>,<span class="hljs-number">72</span>,<span class="hljs-number">73</span>,<span class="hljs-number">74</span>,<span class="hljs-number">76</span>,<span class="hljs-number">79</span>,<span class="hljs-number">80</span>,<span class="hljs-number">82</span>,<span class="hljs-number">85</span>,<span class="hljs-number">87</span>,<span class="hljs-number">88</span>,<span class="hljs-number">90</span>,<span class="hljs-number">91</span>,<span class="hljs-number">93</span>,<span class="hljs-number">94</span>,<span class="hljs-number">95</span>,<span class="hljs-number">96</span>,<span class="hljs-number">97</span>,<span class="hljs-number">98</span>,<span class="hljs-number">100</span>,<span class="hljs-number">102</span>,<span class="hljs-number">104</span>,<span class="hljs-number">105</span>,<span class="hljs-number">107</span>,<span class="hljs-number">109</span>,<span class="hljs-number">110</span>,<span class="hljs-number">111</span>,<span class="hljs-number">112</span>,<span class="hljs-number">113</span>,<span class="hljs-number">114</span>,<span class="hljs-number">115</span>,<span class="hljs-number">116</span>,<span class="hljs-number">118</span>,<span class="hljs-number">119</span>,<span class="hljs-number">120</span>,<span class="hljs-number">121</span>,<span class="hljs-number">122</span>,<span class="hljs-number">123</span>,<span class="hljs-number">124</span>,<span class="hljs-number">125</span>,<span class="hljs-number">127</span>,<span class="hljs-number">132</span>,<span class="hljs-number">133</span>,<span class="hljs-number">134</span>,<span class="hljs-number">137</span>,<span class="hljs-number">139</span>,<span class="hljs-number">140</span>,<span class="hljs-number">142</span>,<span class="hljs-number">143</span>,<span class="hljs-number">144</span>,<span class="hljs-number">147</span>,<span class="hljs-number">149</span>,<span class="hljs-number">150</span>,<span class="hljs-number">151</span>,<span class="hljs-number">153</span>,<span class="hljs-number">154</span>,<span class="hljs-number">155</span>,<span class="hljs-number">156</span>,<span class="hljs-number">157</span>,<span class="hljs-number">159</span>,<span class="hljs-number">160</span>,<span class="hljs-number">161</span>,<span class="hljs-number">162</span>,<span class="hljs-number">164</span>,<span class="hljs-number">166</span>,<span class="hljs-number">167</span>,<span class="hljs-number">169</span>,<span class="hljs-number">170</span>,<span class="hljs-number">172</span>,<span class="hljs-number">175</span>,<span class="hljs-number">177</span>,<span class="hljs-number">179</span>,<span class="hljs-number">183</span>,<span class="hljs-number">186</span>,<span class="hljs-number">187</span>,<span class="hljs-number">190</span>,<span class="hljs-number">191</span>,<span class="hljs-number">192</span>,<span class="hljs-number">193</span>,<span class="hljs-number">194</span>,<span class="hljs-number">197</span>,<span class="hljs-number">198</span>,<span class="hljs-number">200</span>,<span class="hljs-number">201</span>,<span class="hljs-number">204</span>,<span class="hljs-number">205</span>,<span class="hljs-number">206</span>,<span class="hljs-number">207</span>,<span class="hljs-number">208</span>,<span class="hljs-number">209</span>,<span class="hljs-number">211</span>,<span class="hljs-number">212</span>,<span class="hljs-number">213</span>,<span class="hljs-number">214</span>,<span class="hljs-number">215</span>,<span class="hljs-number">216</span>,<span class="hljs-number">218</span>,<span class="hljs-number">220</span>,<span class="hljs-number">221</span>,<span class="hljs-number">224</span>,<span class="hljs-number">225</span>,<span class="hljs-number">228</span>,<span class="hljs-number">230</span>,<span class="hljs-number">231</span>,<span class="hljs-number">233</span>,<span class="hljs-number">235</span>,<span class="hljs-number">237</span>,<span class="hljs-number">240</span>,<span class="hljs-number">241</span>,<span class="hljs-number">242</span>,<span class="hljs-number">243</span>,<span class="hljs-number">246</span>,<span class="hljs-number">247</span>,<span class="hljs-number">248</span>,<span class="hljs-number">250</span>,<span class="hljs-number">251</span>,<span class="hljs-number">254</span>,<span class="hljs-number">255</span>,<span class="hljs-number">256</span>,<span class="hljs-number">257</span>,<span class="hljs-number">258</span>,<span class="hljs-number">261</span>,<span class="hljs-number">263</span>,<span class="hljs-number">264</span>,<span class="hljs-number">265</span>,<span class="hljs-number">268</span>,<span class="hljs-number">269</span>,<span class="hljs-number">272</span>,<span class="hljs-number">274</span>,<span class="hljs-number">275</span>,<span class="hljs-number">276</span>,<span class="hljs-number">277</span>,<span class="hljs-number">278</span>,<span class="hljs-number">279</span>,<span class="hljs-number">280</span>,<span class="hljs-number">281</span>,<span class="hljs-number">282</span>,<span class="hljs-number">283</span>,<span class="hljs-number">285</span>,<span class="hljs-number">286</span>,<span class="hljs-number">288</span>,<span class="hljs-number">291</span>,<span class="hljs-number">292</span>,<span class="hljs-number">294</span>,<span class="hljs-number">296</span>,<span class="hljs-number">298</span>,<span class="hljs-number">300</span>,<span class="hljs-number">301</span>,<span class="hljs-number">303</span>,<span class="hljs-number">304</span>,<span class="hljs-number">305</span>,<span class="hljs-number">306</span>,<span class="hljs-number">307</span>,<span class="hljs-number">312</span>,<span class="hljs-number">314</span>,<span class="hljs-number">315</span>,<span class="hljs-number">316</span>,<span class="hljs-number">317</span>,<span class="hljs-number">318</span>,<span class="hljs-number">319</span>,<span class="hljs-number">320</span>,<span class="hljs-number">321</span>,<span class="hljs-number">322</span>,<span class="hljs-number">323</span>,<span class="hljs-number">325</span>,<span class="hljs-number">326</span>,<span class="hljs-number">327</span>,<span class="hljs-number">329</span>,<span class="hljs-number">330</span>,<span class="hljs-number">331</span>,<span class="hljs-number">333</span>,<span class="hljs-number">335</span>,<span class="hljs-number">337</span>,<span class="hljs-number">338</span>,<span class="hljs-number">339</span>,<span class="hljs-number">340</span>,<span class="hljs-number">341</span>,<span class="hljs-number">342</span>,<span class="hljs-number">343</span>,<span class="hljs-number">344</span>,<span class="hljs-number">346</span>,<span class="hljs-number">348</span>,<span class="hljs-number">349</span>,<span class="hljs-number">351</span>,<span class="hljs-number">353</span>,<span class="hljs-number">354</span>,<span class="hljs-number">355</span>,<span class="hljs-number">356</span>,<span class="hljs-number">359</span>,<span class="hljs-number">360</span>,<span class="hljs-number">362</span>,<span class="hljs-number">364</span>,<span class="hljs-number">365</span>,<span class="hljs-number">366</span>,<span class="hljs-number">367</span>,<span class="hljs-number">368</span>,<span class="hljs-number">369</span>,<span class="hljs-number">372</span>,<span class="hljs-number">373</span>,<span class="hljs-number">377</span>,<span class="hljs-number">378</span>,<span class="hljs-number">379</span>,<span class="hljs-number">380</span>,<span class="hljs-number">381</span>,<span class="hljs-number">383</span>,<span class="hljs-number">386</span>,<span class="hljs-number">387</span>,<span class="hljs-number">388</span>,<span class="hljs-number">389</span>,<span class="hljs-number">390</span>,<span class="hljs-number">391</span>,<span class="hljs-number">392</span>,<span class="hljs-number">393</span>,<span class="hljs-number">395</span>,<span class="hljs-number">396</span>,<span class="hljs-number">397</span>,<span class="hljs-number">398</span>,<span class="hljs-number">401</span>,<span class="hljs-number">402</span>,<span class="hljs-number">403</span>,<span class="hljs-number">406</span>,<span class="hljs-number">407</span>,<span class="hljs-number">408</span>,<span class="hljs-number">411</span>,<span class="hljs-number">413</span>,<span class="hljs-number">415</span>,<span class="hljs-number">416</span>,<span class="hljs-number">417</span>,<span class="hljs-number">420</span>,<span class="hljs-number">421</span>,<span class="hljs-number">424</span>,<span class="hljs-number">427</span>,<span class="hljs-number">429</span>,<span class="hljs-number">431</span>,<span class="hljs-number">433</span>,<span class="hljs-number">434</span>,<span class="hljs-number">435</span>,<span class="hljs-number">437</span>,<span class="hljs-number">440</span>,<span class="hljs-number">443</span>,<span class="hljs-number">447</span>,<span class="hljs-number">448</span>,<span class="hljs-number">449</span>,<span class="hljs-number">452</span>,<span class="hljs-number">453</span>,<span class="hljs-number">455</span>,<span class="hljs-number">456</span>,<span class="hljs-number">457</span>,<span class="hljs-number">458</span>,<span class="hljs-number">460</span>,<span class="hljs-number">462</span>,<span class="hljs-number">463</span>,<span class="hljs-number">465</span>,<span class="hljs-number">467</span>,<span class="hljs-number">468</span>,<span class="hljs-number">471</span>,<span class="hljs-number">472</span>,<span class="hljs-number">475</span>,<span class="hljs-number">477</span>,<span class="hljs-number">479</span>,<span class="hljs-number">480</span>,<span class="hljs-number">482</span>,<span class="hljs-number">484</span>,<span class="hljs-number">486</span>,<span class="hljs-number">487</span>,<span class="hljs-number">489</span>,<span class="hljs-number">490</span>,<span class="hljs-number">491</span>,<span class="hljs-number">492</span>,<span class="hljs-number">495</span>,<span class="hljs-number">496</span>,<span class="hljs-number">498</span>,<span class="hljs-number">499</span>,<span class="hljs-number">500</span>,<span class="hljs-number">502</span>,<span class="hljs-number">503</span>,<span class="hljs-number">504</span>,<span class="hljs-number">505</span>,<span class="hljs-number">507</span>,<span class="hljs-number">508</span>,<span class="hljs-number">509</span>,<span class="hljs-number">510</span>,<span class="hljs-number">512</span>,<span class="hljs-number">513</span>,<span class="hljs-number">514</span>,<span class="hljs-number">515</span>,<span class="hljs-number">517</span>,<span class="hljs-number">518</span>,<span class="hljs-number">519</span>,<span class="hljs-number">520</span>,<span class="hljs-number">521</span>,<span class="hljs-number">523</span>,<span class="hljs-number">524</span>,<span class="hljs-number">526</span>,<span class="hljs-number">527</span>,<span class="hljs-number">529</span>,<span class="hljs-number">530</span>,<span class="hljs-number">532</span>,<span class="hljs-number">533</span>,<span class="hljs-number">535</span>,<span class="hljs-number">536</span>,<span class="hljs-number">537</span>,<span class="hljs-number">538</span>,<span class="hljs-number">540</span>,<span class="hljs-number">542</span>,<span class="hljs-number">544</span>,<span class="hljs-number">546</span>,<span class="hljs-number">548</span>,<span class="hljs-number">552</span>,<span class="hljs-number">553</span>,<span class="hljs-number">555</span>,<span class="hljs-number">556</span>,<span class="hljs-number">558</span>,<span class="hljs-number">559</span>,<span class="hljs-number">560</span>,<span class="hljs-number">562</span>,<span class="hljs-number">563</span>,<span class="hljs-number">564</span>,<span class="hljs-number">565</span>,<span class="hljs-number">566</span>,<span class="hljs-number">567</span>,<span class="hljs-number">568</span>,<span class="hljs-number">569</span>,<span class="hljs-number">570</span>,<span class="hljs-number">571</span>,<span class="hljs-number">572</span>,<span class="hljs-number">573</span>,<span class="hljs-number">576</span>,<span class="hljs-number">578</span>,<span class="hljs-number">579</span>,<span class="hljs-number">580</span>,<span class="hljs-number">581</span>,<span class="hljs-number">582</span>,<span class="hljs-number">583</span>,<span class="hljs-number">584</span>,<span class="hljs-number">585</span>,<span class="hljs-number">586</span>,<span class="hljs-number">588</span>,<span class="hljs-number">589</span>,<span class="hljs-number">590</span>,<span class="hljs-number">592</span>,<span class="hljs-number">594</span>,<span class="hljs-number">595</span>,<span class="hljs-number">596</span>,<span class="hljs-number">597</span>,<span class="hljs-number">598</span>,<span class="hljs-number">600</span>,<span class="hljs-number">601</span>,<span class="hljs-number">603</span>,<span class="hljs-number">605</span>,<span class="hljs-number">606</span>,<span class="hljs-number">607</span>,<span class="hljs-number">608</span>,<span class="hljs-number">609</span>,<span class="hljs-number">611</span>,<span class="hljs-number">612</span>,<span class="hljs-number">614</span>,<span class="hljs-number">617</span>,<span class="hljs-number">618</span>,<span class="hljs-number">619</span>,<span class="hljs-number">621</span>,<span class="hljs-number">622</span>,<span class="hljs-number">624</span>,<span class="hljs-number">625</span>,<span class="hljs-number">626</span>,<span class="hljs-number">627</span>,<span class="hljs-number">628</span>,<span class="hljs-number">629</span>,<span class="hljs-number">631</span>,<span class="hljs-number">632</span>,<span class="hljs-number">633</span>,<span class="hljs-number">635</span>,<span class="hljs-number">636</span>,<span class="hljs-number">639</span>,<span class="hljs-number">641</span>,<span class="hljs-number">643</span>,<span class="hljs-number">644</span>,<span class="hljs-number">646</span>,<span class="hljs-number">648</span>,<span class="hljs-number">651</span>,<span class="hljs-number">653</span>,<span class="hljs-number">654</span>,<span class="hljs-number">655</span>,<span class="hljs-number">656</span>,<span class="hljs-number">657</span>,<span class="hljs-number">659</span>,<span class="hljs-number">660</span>,<span class="hljs-number">662</span>,<span class="hljs-number">664</span>,<span class="hljs-number">665</span>,<span class="hljs-number">669</span>,<span class="hljs-number">670</span>,<span class="hljs-number">671</span>,<span class="hljs-number">672</span>,<span class="hljs-number">673</span>,<span class="hljs-number">674</span>,<span class="hljs-number">675</span>,<span class="hljs-number">677</span>,<span class="hljs-number">679</span>,<span class="hljs-number">680</span>,<span class="hljs-number">682</span>,<span class="hljs-number">683</span>,<span class="hljs-number">685</span>,<span class="hljs-number">686</span>,<span class="hljs-number">687</span>,<span class="hljs-number">688</span>,<span class="hljs-number">689</span>,<span class="hljs-number">690</span>,<span class="hljs-number">691</span>,<span class="hljs-number">692</span>,<span class="hljs-number">693</span>,<span class="hljs-number">694</span>,<span class="hljs-number">695</span>,<span class="hljs-number">696</span>,<span class="hljs-number">697</span>,<span class="hljs-number">698</span>,<span class="hljs-number">699</span>,<span class="hljs-number">701</span>,<span class="hljs-number">706</span>,<span class="hljs-number">707</span>,<span class="hljs-number">708</span>,<span class="hljs-number">709</span>,<span class="hljs-number">710</span>,<span class="hljs-number">711</span>,<span class="hljs-number">713</span>,<span class="hljs-number">714</span>,<span class="hljs-number">715</span>,<span class="hljs-number">718</span>,<span class="hljs-number">719</span>,<span class="hljs-number">720</span>,<span class="hljs-number">722</span>,<span class="hljs-number">725</span>,<span class="hljs-number">726</span>,<span class="hljs-number">727</span>,<span class="hljs-number">728</span>,<span class="hljs-number">729</span>,<span class="hljs-number">730</span>,<span class="hljs-number">731</span>,<span class="hljs-number">732</span>,<span class="hljs-number">734</span>,<span class="hljs-number">735</span>,<span class="hljs-number">736</span>,<span class="hljs-number">737</span>,<span class="hljs-number">738</span>,<span class="hljs-number">739</span>,<span class="hljs-number">740</span>,<span class="hljs-number">744</span>,<span class="hljs-number">746</span>,<span class="hljs-number">747</span>,<span class="hljs-number">748</span>,<span class="hljs-number">749</span>,<span class="hljs-number">751</span>,<span class="hljs-number">753</span>,<span class="hljs-number">754</span>,<span class="hljs-number">755</span>,<span class="hljs-number">757</span>,<span class="hljs-number">758</span>,<span class="hljs-number">759</span>,<span class="hljs-number">760</span>,<span class="hljs-number">763</span>,<span class="hljs-number">764</span>,<span class="hljs-number">765</span>,<span class="hljs-number">766</span>,<span class="hljs-number">767</span>,<span class="hljs-number">768</span>,<span class="hljs-number">770</span>,<span class="hljs-number">771</span>,<span class="hljs-number">772</span>,<span class="hljs-number">774</span>,<span class="hljs-number">776</span>,<span class="hljs-number">778</span>,<span class="hljs-number">779</span>,<span class="hljs-number">780</span>,<span class="hljs-number">781</span>,<span class="hljs-number">782</span>,<span class="hljs-number">783</span>,<span class="hljs-number">785</span>,<span class="hljs-number">788</span>,<span class="hljs-number">789</span>,<span class="hljs-number">791</span>,<span class="hljs-number">793</span>,<span class="hljs-number">795</span>,<span class="hljs-number">796</span>,<span class="hljs-number">797</span>,<span class="hljs-number">798</span>,<span class="hljs-number">799</span>,<span class="hljs-number">801</span>,<span class="hljs-number">803</span>,<span class="hljs-number">804</span>,<span class="hljs-number">806</span>,<span class="hljs-number">807</span>,<span class="hljs-number">808</span>,<span class="hljs-number">809</span>,<span class="hljs-number">812</span>,<span class="hljs-number">815</span>,<span class="hljs-number">817</span>,<span class="hljs-number">818</span>,<span class="hljs-number">819</span>,<span class="hljs-number">821</span>,<span class="hljs-number">824</span>,<span class="hljs-number">826</span>,<span class="hljs-number">827</span>,<span class="hljs-number">829</span>,<span class="hljs-number">830</span>,<span class="hljs-number">832</span>,<span class="hljs-number">833</span>,<span class="hljs-number">834</span>,<span class="hljs-number">835</span>,<span class="hljs-number">836</span>,<span class="hljs-number">837</span>,<span class="hljs-number">838</span>,<span class="hljs-number">839</span>,<span class="hljs-number">841</span>,<span class="hljs-number">842</span>,<span class="hljs-number">843</span>,<span class="hljs-number">844</span>,<span class="hljs-number">845</span>,<span class="hljs-number">846</span>,<span class="hljs-number">848</span>,<span class="hljs-number">850</span>,<span class="hljs-number">854</span>,<span class="hljs-number">855</span>,<span class="hljs-number">856</span>,<span class="hljs-number">858</span>,<span class="hljs-number">859</span>,<span class="hljs-number">861</span>,<span class="hljs-number">862</span>,<span class="hljs-number">864</span>,<span class="hljs-number">865</span>,<span class="hljs-number">866</span>,<span class="hljs-number">867</span>,<span class="hljs-number">868</span>,<span class="hljs-number">869</span>,<span class="hljs-number">871</span>,<span class="hljs-number">873</span>,<span class="hljs-number">874</span>,<span class="hljs-number">875</span>,<span class="hljs-number">876</span>,<span class="hljs-number">877</span>,<span class="hljs-number">878</span>,<span class="hljs-number">879</span>,<span class="hljs-number">880</span>,<span class="hljs-number">881</span>,<span class="hljs-number">883</span>,<span class="hljs-number">885</span>,<span class="hljs-number">886</span>,<span class="hljs-number">887</span>,<span class="hljs-number">888</span>,<span class="hljs-number">889</span>,<span class="hljs-number">890</span>,<span class="hljs-number">892</span>,<span class="hljs-number">893</span>,<span class="hljs-number">894</span>,<span class="hljs-number">895</span>,<span class="hljs-number">896</span>,<span class="hljs-number">897</span>,<span class="hljs-number">898</span>,<span class="hljs-number">900</span>,<span class="hljs-number">902</span>,<span class="hljs-number">905</span>,<span class="hljs-number">906</span>,<span class="hljs-number">907</span>,<span class="hljs-number">908</span>,<span class="hljs-number">909</span>,<span class="hljs-number">910</span>,<span class="hljs-number">912</span>,<span class="hljs-number">914</span>,<span class="hljs-number">916</span>,<span class="hljs-number">917</span>,<span class="hljs-number">918</span>,<span class="hljs-number">920</span>,<span class="hljs-number">922</span>,<span class="hljs-number">924</span>,<span class="hljs-number">925</span>,<span class="hljs-number">928</span>,<span class="hljs-number">931</span>,<span class="hljs-number">932</span>,<span class="hljs-number">933</span>,<span class="hljs-number">934</span>,<span class="hljs-number">935</span>,<span class="hljs-number">936</span>,<span class="hljs-number">937</span>,<span class="hljs-number">938</span>,<span class="hljs-number">940</span>,<span class="hljs-number">941</span>,<span class="hljs-number">943</span>,<span class="hljs-number">944</span>,<span class="hljs-number">947</span>,<span class="hljs-number">949</span>,<span class="hljs-number">950</span>,<span class="hljs-number">951</span>,<span class="hljs-number">952</span>,<span class="hljs-number">953</span>,<span class="hljs-number">957</span>,<span class="hljs-number">959</span>,<span class="hljs-number">960</span>,<span class="hljs-number">961</span>,<span class="hljs-number">962</span>,<span class="hljs-number">963</span>,<span class="hljs-number">964</span>,<span class="hljs-number">966</span>,<span class="hljs-number">967</span>,<span class="hljs-number">969</span>,<span class="hljs-number">970</span>,<span class="hljs-number">972</span>,<span class="hljs-number">974</span>,<span class="hljs-number">975</span>,<span class="hljs-number">976</span>,<span class="hljs-number">978</span>,<span class="hljs-number">979</span>,<span class="hljs-number">983</span>,<span class="hljs-number">984</span>,<span class="hljs-number">986</span>,<span class="hljs-number">987</span>,<span class="hljs-number">988</span>,<span class="hljs-number">989</span>,<span class="hljs-number">990</span>,<span class="hljs-number">991</span>,<span class="hljs-number">992</span>,<span class="hljs-number">994</span>,<span class="hljs-number">997</span>,<span class="hljs-number">999</span>,<span class="hljs-number">1000</span>],<span class="hljs-string">&quot;fFunctions&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TList&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;TList&quot;</span>,<span class="hljs-string">&quot;arr&quot;</span>:[],<span class="hljs-string">&quot;opt&quot;</span>:[]&#125;,<span class="hljs-string">&quot;fHistogram&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TH1F&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">520</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;Graph&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fLineColor&quot;</span>:<span class="hljs-number">602</span>,<span class="hljs-string">&quot;fLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineWidth&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFillColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fFillStyle&quot;</span>:<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;fMarkerColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fMarkerStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fMarkerSize&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fNcells&quot;</span>:<span class="hljs-number">666</span>,<span class="hljs-string">&quot;fXaxis&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TAxis&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;xaxis&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fNdivisions&quot;</span>:<span class="hljs-number">510</span>,<span class="hljs-string">&quot;fAxisColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLabelColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLabelFont&quot;</span>:<span class="hljs-number">42</span>,<span class="hljs-string">&quot;fLabelOffset&quot;</span>:<span class="hljs-number">0.005</span>,<span class="hljs-string">&quot;fLabelSize&quot;</span>:<span class="hljs-number">0.035</span>,<span class="hljs-string">&quot;fTickLength&quot;</span>:<span class="hljs-number">0.03</span>,<span class="hljs-string">&quot;fTitleOffset&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTitleSize&quot;</span>:<span class="hljs-number">0.035</span>,<span class="hljs-string">&quot;fTitleColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTitleFont&quot;</span>:<span class="hljs-number">42</span>,<span class="hljs-string">&quot;fNbins&quot;</span>:<span class="hljs-number">664</span>,<span class="hljs-string">&quot;fXmin&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fXmax&quot;</span>:<span class="hljs-number">730.3</span>,<span class="hljs-string">&quot;fXbins&quot;</span>:[],<span class="hljs-string">&quot;fFirst&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLast&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits2&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTimeDisplay&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fTimeFormat&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fLabels&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fModLabs&quot;</span>:<span class="hljs-literal">null</span>&#125;,<span class="hljs-string">&quot;fYaxis&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TAxis&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;yaxis&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fNdivisions&quot;</span>:<span class="hljs-number">510</span>,<span class="hljs-string">&quot;fAxisColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLabelColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLabelFont&quot;</span>:<span class="hljs-number">42</span>,<span class="hljs-string">&quot;fLabelOffset&quot;</span>:<span class="hljs-number">0.005</span>,<span class="hljs-string">&quot;fLabelSize&quot;</span>:<span class="hljs-number">0.035</span>,<span class="hljs-string">&quot;fTickLength&quot;</span>:<span class="hljs-number">0.03</span>,<span class="hljs-string">&quot;fTitleOffset&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTitleSize&quot;</span>:<span class="hljs-number">0.035</span>,<span class="hljs-string">&quot;fTitleColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTitleFont&quot;</span>:<span class="hljs-number">42</span>,<span class="hljs-string">&quot;fNbins&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fXmin&quot;</span>:<span class="hljs-number">0.9</span>,<span class="hljs-string">&quot;fXmax&quot;</span>:<span class="hljs-number">1099.9</span>,<span class="hljs-string">&quot;fXbins&quot;</span>:[],<span class="hljs-string">&quot;fFirst&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLast&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits2&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTimeDisplay&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fTimeFormat&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fLabels&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fModLabs&quot;</span>:<span class="hljs-literal">null</span>&#125;,<span class="hljs-string">&quot;fZaxis&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TAxis&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;zaxis&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fNdivisions&quot;</span>:<span class="hljs-number">510</span>,<span class="hljs-string">&quot;fAxisColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLabelColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLabelFont&quot;</span>:<span class="hljs-number">42</span>,<span class="hljs-string">&quot;fLabelOffset&quot;</span>:<span class="hljs-number">0.005</span>,<span class="hljs-string">&quot;fLabelSize&quot;</span>:<span class="hljs-number">0.035</span>,<span class="hljs-string">&quot;fTickLength&quot;</span>:<span class="hljs-number">0.03</span>,<span class="hljs-string">&quot;fTitleOffset&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTitleSize&quot;</span>:<span class="hljs-number">0.035</span>,<span class="hljs-string">&quot;fTitleColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTitleFont&quot;</span>:<span class="hljs-number">42</span>,<span class="hljs-string">&quot;fNbins&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fXmin&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fXmax&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fXbins&quot;</span>:[],<span class="hljs-string">&quot;fFirst&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLast&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits2&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTimeDisplay&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fTimeFormat&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fLabels&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fModLabs&quot;</span>:<span class="hljs-literal">null</span>&#125;,<span class="hljs-string">&quot;fBarOffset&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBarWidth&quot;</span>:<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;fEntries&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTsumw&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTsumw2&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTsumwx&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTsumwx2&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fMaximum&quot;</span>:<span class="hljs-number">1099.9</span>,<span class="hljs-string">&quot;fMinimum&quot;</span>:<span class="hljs-number">0.9</span>,<span class="hljs-string">&quot;fNormFactor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fContour&quot;</span>:[],<span class="hljs-string">&quot;fSumw2&quot;</span>:[],<span class="hljs-string">&quot;fOption&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fFunctions&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TList&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;TList&quot;</span>,<span class="hljs-string">&quot;arr&quot;</span>:[],<span class="hljs-string">&quot;opt&quot;</span>:[]&#125;,<span class="hljs-string">&quot;fBufferSize&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBuffer&quot;</span>:[],<span class="hljs-string">&quot;fBinStatErrOpt&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fStatOverflows&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fArray&quot;</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]&#125;,<span class="hljs-string">&quot;fMinimum&quot;</span>:<span class="hljs-number">-1111</span>,<span class="hljs-string">&quot;fMaximum&quot;</span>:<span class="hljs-number">-1111</span>&#125;],<span class="hljs-string">&quot;opt&quot;</span>:[<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;ap&quot;</span>]&#125;,<span class="hljs-string">&quot;fExecs&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-string">&quot;fNumPaletteColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fNextPaletteColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fDISPLAY&quot;</span>:<span class="hljs-string">&quot;$DISPLAY&quot;</span>,<span class="hljs-string">&quot;fDoubleBuffer&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fRetained&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;fXsizeUser&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fYsizeUser&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fXsizeReal&quot;</span>:<span class="hljs-number">20</span>,<span class="hljs-string">&quot;fYsizeReal&quot;</span>:<span class="hljs-number">14.28571</span>,<span class="hljs-string">&quot;fWindowTopX&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fWindowTopY&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fWindowWidth&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fWindowHeight&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fCw&quot;</span>:<span class="hljs-number">696</span>,<span class="hljs-string">&quot;fCh&quot;</span>:<span class="hljs-number">472</span>,<span class="hljs-string">&quot;fCatt&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TAttCanvas&quot;</span>,<span class="hljs-string">&quot;fXBetween&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fYBetween&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fTitleFromTop&quot;</span>:<span class="hljs-number">1.2</span>,<span class="hljs-string">&quot;fXdate&quot;</span>:<span class="hljs-number">0.2</span>,<span class="hljs-string">&quot;fYdate&quot;</span>:<span class="hljs-number">0.3</span>,<span class="hljs-string">&quot;fAdate&quot;</span>:<span class="hljs-number">1</span>&#125;,<span class="hljs-string">&quot;kMoveOpaque&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;kResizeOpaque&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;fHighLightColor&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fBatch&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;kShowEventStatus&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;kAutoExec&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;kMenuBar&quot;</span>:<span class="hljs-literal">true</span>&#125;);</span><br><span class="javascript">            Core.draw(<span class="hljs-string">&quot;root_plot_1586256162911&quot;</span>, obj, <span class="hljs-string">&quot;&quot;</span>);</span><br>        &#125;<br>    );<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="online"><a href="#online" class="headerlink" title="online"></a>online</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br> requirejs.config(&#123;<br>     paths: &#123;<br><span class="javascript">       <span class="hljs-string">&#x27;JSRootCore&#x27;</span> : <span class="hljs-string">&#x27;https://root.cern.ch/js/notebook//scripts/JSRootCore&#x27;</span>,</span><br>     &#125;<br>   &#125;);<br><span class="javascript"> <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;JSRootCore&#x27;</span>],</span><br><span class="javascript">     <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Core</span>) </span>&#123;</span><br><span class="javascript">       <span class="hljs-keyword">var</span> obj = Core.JSONR_unref(&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TCanvas&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">36896776</span>,<span class="hljs-string">&quot;fLineColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineWidth&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFillColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fFillStyle&quot;</span>:<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;fLeftMargin&quot;</span>:<span class="hljs-number">0.1</span>,<span class="hljs-string">&quot;fRightMargin&quot;</span>:<span class="hljs-number">0.1</span>,<span class="hljs-string">&quot;fBottomMargin&quot;</span>:<span class="hljs-number">0.1</span>,<span class="hljs-string">&quot;fTopMargin&quot;</span>:<span class="hljs-number">0.1</span>,<span class="hljs-string">&quot;fXfile&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fYfile&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fAfile&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fXstat&quot;</span>:<span class="hljs-number">0.99</span>,<span class="hljs-string">&quot;fYstat&quot;</span>:<span class="hljs-number">0.99</span>,<span class="hljs-string">&quot;fAstat&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fFrameFillColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fFrameLineColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFrameFillStyle&quot;</span>:<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;fFrameLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFrameLineWidth&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFrameBorderSize&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFrameBorderMode&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fX1&quot;</span>:<span class="hljs-number">-1.25000009313226</span>,<span class="hljs-string">&quot;fY1&quot;</span>:<span class="hljs-number">-0.131250009778888</span>,<span class="hljs-string">&quot;fX2&quot;</span>:<span class="hljs-number">11.2500000931323</span>,<span class="hljs-string">&quot;fY2&quot;</span>:<span class="hljs-number">1.18125000977889</span>,<span class="hljs-string">&quot;fXtoAbsPixelk&quot;</span>:<span class="hljs-number">69.6000541484835</span>,<span class="hljs-string">&quot;fXtoPixelk&quot;</span>:<span class="hljs-number">69.6000541484835</span>,<span class="hljs-string">&quot;fXtoPixel&quot;</span>:<span class="hljs-number">55.6799991703033</span>,<span class="hljs-string">&quot;fYtoAbsPixelk&quot;</span>:<span class="hljs-number">424.800047186661</span>,<span class="hljs-string">&quot;fYtoPixelk&quot;</span>:<span class="hljs-number">424.800047186661</span>,<span class="hljs-string">&quot;fYtoPixel&quot;</span>:<span class="hljs-number">-359.619042260306</span>,<span class="hljs-string">&quot;fUtoAbsPixelk&quot;</span>:<span class="hljs-number">5e-5</span>,<span class="hljs-string">&quot;fUtoPixelk&quot;</span>:<span class="hljs-number">5e-5</span>,<span class="hljs-string">&quot;fUtoPixel&quot;</span>:<span class="hljs-number">696</span>,<span class="hljs-string">&quot;fVtoAbsPixelk&quot;</span>:<span class="hljs-number">472.00005</span>,<span class="hljs-string">&quot;fVtoPixelk&quot;</span>:<span class="hljs-number">472</span>,<span class="hljs-string">&quot;fVtoPixel&quot;</span>:<span class="hljs-number">-472</span>,<span class="hljs-string">&quot;fAbsPixeltoXk&quot;</span>:<span class="hljs-number">-1.25000009313226</span>,<span class="hljs-string">&quot;fPixeltoXk&quot;</span>:<span class="hljs-number">-1.25000009313226</span>,<span class="hljs-string">&quot;fPixeltoX&quot;</span>:<span class="hljs-number">0.017959770382564</span>,<span class="hljs-string">&quot;fAbsPixeltoYk&quot;</span>:<span class="hljs-number">1.18125000977889</span>,<span class="hljs-string">&quot;fPixeltoYk&quot;</span>:<span class="hljs-number">-0.131250009778888</span>,<span class="hljs-string">&quot;fPixeltoY&quot;</span>:<span class="hljs-number">-0.00278072038041902</span>,<span class="hljs-string">&quot;fXlowNDC&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fYlowNDC&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fXUpNDC&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fYUpNDC&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fWNDC&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fHNDC&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fAbsXlowNDC&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fAbsYlowNDC&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fAbsWNDC&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fAbsHNDC&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fUxmin&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fUymin&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fUxmax&quot;</span>:<span class="hljs-number">10</span>,<span class="hljs-string">&quot;fUymax&quot;</span>:<span class="hljs-number">1.05</span>,<span class="hljs-string">&quot;fTheta&quot;</span>:<span class="hljs-number">30</span>,<span class="hljs-string">&quot;fPhi&quot;</span>:<span class="hljs-number">30</span>,<span class="hljs-string">&quot;fAspectRatio&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fNumber&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTickx&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTicky&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLogx&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLogy&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLogz&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fPadPaint&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fCrosshair&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fCrosshairPos&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBorderSize&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fBorderMode&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fModified&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fGridx&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fGridy&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fAbsCoord&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fEditable&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;fFixedAspectRatio&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fPrimitives&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TList&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;TList&quot;</span>,<span class="hljs-string">&quot;arr&quot;</span>:[&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TFrame&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">50331656</span>,<span class="hljs-string">&quot;fLineColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineWidth&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFillColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fFillStyle&quot;</span>:<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;fX1&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fY1&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fX2&quot;</span>:<span class="hljs-number">10</span>,<span class="hljs-string">&quot;fY2&quot;</span>:<span class="hljs-number">1.05</span>,<span class="hljs-string">&quot;fBorderSize&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fBorderMode&quot;</span>:<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TH1F&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">50331656</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;fLineColor&quot;</span>:<span class="hljs-number">602</span>,<span class="hljs-string">&quot;fLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineWidth&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFillColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fFillStyle&quot;</span>:<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;fMarkerColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fMarkerStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fMarkerSize&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fNcells&quot;</span>:<span class="hljs-number">12</span>,<span class="hljs-string">&quot;fXaxis&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TAxis&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">50331648</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;xaxis&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fNdivisions&quot;</span>:<span class="hljs-number">510</span>,<span class="hljs-string">&quot;fAxisColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLabelColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLabelFont&quot;</span>:<span class="hljs-number">42</span>,<span class="hljs-string">&quot;fLabelOffset&quot;</span>:<span class="hljs-number">0.005</span>,<span class="hljs-string">&quot;fLabelSize&quot;</span>:<span class="hljs-number">0.035</span>,<span class="hljs-string">&quot;fTickLength&quot;</span>:<span class="hljs-number">0.03</span>,<span class="hljs-string">&quot;fTitleOffset&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTitleSize&quot;</span>:<span class="hljs-number">0.035</span>,<span class="hljs-string">&quot;fTitleColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTitleFont&quot;</span>:<span class="hljs-number">42</span>,<span class="hljs-string">&quot;fNbins&quot;</span>:<span class="hljs-number">10</span>,<span class="hljs-string">&quot;fXmin&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fXmax&quot;</span>:<span class="hljs-number">10</span>,<span class="hljs-string">&quot;fXbins&quot;</span>:[],<span class="hljs-string">&quot;fFirst&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLast&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits2&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTimeDisplay&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fTimeFormat&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fLabels&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fModLabs&quot;</span>:<span class="hljs-literal">null</span>&#125;,<span class="hljs-string">&quot;fYaxis&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TAxis&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">50331648</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;yaxis&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fNdivisions&quot;</span>:<span class="hljs-number">510</span>,<span class="hljs-string">&quot;fAxisColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLabelColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLabelFont&quot;</span>:<span class="hljs-number">42</span>,<span class="hljs-string">&quot;fLabelOffset&quot;</span>:<span class="hljs-number">0.005</span>,<span class="hljs-string">&quot;fLabelSize&quot;</span>:<span class="hljs-number">0.035</span>,<span class="hljs-string">&quot;fTickLength&quot;</span>:<span class="hljs-number">0.03</span>,<span class="hljs-string">&quot;fTitleOffset&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTitleSize&quot;</span>:<span class="hljs-number">0.035</span>,<span class="hljs-string">&quot;fTitleColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTitleFont&quot;</span>:<span class="hljs-number">42</span>,<span class="hljs-string">&quot;fNbins&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fXmin&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fXmax&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fXbins&quot;</span>:[],<span class="hljs-string">&quot;fFirst&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLast&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits2&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTimeDisplay&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fTimeFormat&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fLabels&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fModLabs&quot;</span>:<span class="hljs-literal">null</span>&#125;,<span class="hljs-string">&quot;fZaxis&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TAxis&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">50331648</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;zaxis&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fNdivisions&quot;</span>:<span class="hljs-number">510</span>,<span class="hljs-string">&quot;fAxisColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLabelColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLabelFont&quot;</span>:<span class="hljs-number">42</span>,<span class="hljs-string">&quot;fLabelOffset&quot;</span>:<span class="hljs-number">0.005</span>,<span class="hljs-string">&quot;fLabelSize&quot;</span>:<span class="hljs-number">0.035</span>,<span class="hljs-string">&quot;fTickLength&quot;</span>:<span class="hljs-number">0.03</span>,<span class="hljs-string">&quot;fTitleOffset&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTitleSize&quot;</span>:<span class="hljs-number">0.035</span>,<span class="hljs-string">&quot;fTitleColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTitleFont&quot;</span>:<span class="hljs-number">42</span>,<span class="hljs-string">&quot;fNbins&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fXmin&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fXmax&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fXbins&quot;</span>:[],<span class="hljs-string">&quot;fFirst&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLast&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits2&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTimeDisplay&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fTimeFormat&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fLabels&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fModLabs&quot;</span>:<span class="hljs-literal">null</span>&#125;,<span class="hljs-string">&quot;fBarOffset&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBarWidth&quot;</span>:<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;fEntries&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTsumw&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTsumw2&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTsumwx&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;fTsumwx2&quot;</span>:<span class="hljs-number">9</span>,<span class="hljs-string">&quot;fMaximum&quot;</span>:<span class="hljs-number">-1111</span>,<span class="hljs-string">&quot;fMinimum&quot;</span>:<span class="hljs-number">-1111</span>,<span class="hljs-string">&quot;fNormFactor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fContour&quot;</span>:[],<span class="hljs-string">&quot;fSumw2&quot;</span>:[],<span class="hljs-string">&quot;fOption&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fFunctions&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TList&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;TList&quot;</span>,<span class="hljs-string">&quot;arr&quot;</span>:[&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TPaveStats&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">50331657</span>,<span class="hljs-string">&quot;fLineColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineWidth&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFillColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fFillStyle&quot;</span>:<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;fX1&quot;</span>:<span class="hljs-number">8.50000025331975</span>,<span class="hljs-string">&quot;fY1&quot;</span>:<span class="hljs-number">0.885937513201498</span>,<span class="hljs-string">&quot;fX2&quot;</span>:<span class="hljs-number">11.0000003278256</span>,<span class="hljs-string">&quot;fY2&quot;</span>:<span class="hljs-number">1.09593751163688</span>,<span class="hljs-string">&quot;fX1NDC&quot;</span>:<span class="hljs-number">0.780000016093254</span>,<span class="hljs-string">&quot;fY1NDC&quot;</span>:<span class="hljs-number">0.775000005960464</span>,<span class="hljs-string">&quot;fX2NDC&quot;</span>:<span class="hljs-number">0.980000019073486</span>,<span class="hljs-string">&quot;fY2NDC&quot;</span>:<span class="hljs-number">0.935000002384186</span>,<span class="hljs-string">&quot;fBorderSize&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fInit&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fShadowColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fCornerRadius&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fOption&quot;</span>:<span class="hljs-string">&quot;brNDC&quot;</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;stats&quot;</span>,<span class="hljs-string">&quot;fTextAngle&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextSize&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextAlign&quot;</span>:<span class="hljs-number">12</span>,<span class="hljs-string">&quot;fTextColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTextFont&quot;</span>:<span class="hljs-number">42</span>,<span class="hljs-string">&quot;fLabel&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fLongest&quot;</span>:<span class="hljs-number">18</span>,<span class="hljs-string">&quot;fMargin&quot;</span>:<span class="hljs-number">0.05</span>,<span class="hljs-string">&quot;fLines&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TList&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;TList&quot;</span>,<span class="hljs-string">&quot;arr&quot;</span>:[&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TLatex&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">50331648</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;fTextAngle&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextSize&quot;</span>:<span class="hljs-number">0.0368</span>,<span class="hljs-string">&quot;fTextAlign&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextFont&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fX&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fY&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLineColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineWidth&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fLimitFactorSize&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;fOriginSize&quot;</span>:<span class="hljs-number">0.0368000008165836</span>&#125;,&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TLatex&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">50331648</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;Entries = 1      &quot;</span>,<span class="hljs-string">&quot;fTextAngle&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextSize&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextAlign&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextFont&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fX&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fY&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLineColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineWidth&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fLimitFactorSize&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;fOriginSize&quot;</span>:<span class="hljs-number">0.04</span>&#125;,&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TLatex&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">50331648</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;Mean  =      3&quot;</span>,<span class="hljs-string">&quot;fTextAngle&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextSize&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextAlign&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextFont&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fX&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fY&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLineColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineWidth&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fLimitFactorSize&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;fOriginSize&quot;</span>:<span class="hljs-number">0.04</span>&#125;,&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TLatex&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">50331648</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;Std Dev   =      0&quot;</span>,<span class="hljs-string">&quot;fTextAngle&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextSize&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextAlign&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextFont&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fX&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fY&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLineColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineWidth&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fLimitFactorSize&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;fOriginSize&quot;</span>:<span class="hljs-number">0.04</span>&#125;],<span class="hljs-string">&quot;opt&quot;</span>:[<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>]&#125;,<span class="hljs-string">&quot;fOptFit&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fOptStat&quot;</span>:<span class="hljs-number">1111</span>,<span class="hljs-string">&quot;fFitFormat&quot;</span>:<span class="hljs-string">&quot;5.4g&quot;</span>,<span class="hljs-string">&quot;fStatFormat&quot;</span>:<span class="hljs-string">&quot;6.4g&quot;</span>,<span class="hljs-string">&quot;fParent&quot;</span>:&#123;<span class="hljs-string">&quot;$ref&quot;</span>:<span class="hljs-number">3</span>&#125;&#125;],<span class="hljs-string">&quot;opt&quot;</span>:[<span class="hljs-string">&quot;brNDC&quot;</span>]&#125;,<span class="hljs-string">&quot;fBufferSize&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBuffer&quot;</span>:[],<span class="hljs-string">&quot;fBinStatErrOpt&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fStatOverflows&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fArray&quot;</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]&#125;,&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TPaveText&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">50331657</span>,<span class="hljs-string">&quot;fLineColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineWidth&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fFillColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fFillStyle&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fX1&quot;</span>:<span class="hljs-number">4.74928160545941</span>,<span class="hljs-string">&quot;fY1&quot;</span>:<span class="hljs-number">1.10250001378823</span>,<span class="hljs-string">&quot;fX2&quot;</span>:<span class="hljs-number">5.25071839454059</span>,<span class="hljs-string">&quot;fY2&quot;</span>:<span class="hljs-number">1.17468751593959</span>,<span class="hljs-string">&quot;fX1NDC&quot;</span>:<span class="hljs-number">0.479942528735632</span>,<span class="hljs-string">&quot;fY1NDC&quot;</span>:<span class="hljs-number">0.940000003948808</span>,<span class="hljs-string">&quot;fX2NDC&quot;</span>:<span class="hljs-number">0.520057471264368</span>,<span class="hljs-string">&quot;fY2NDC&quot;</span>:<span class="hljs-number">0.995000004768372</span>,<span class="hljs-string">&quot;fBorderSize&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fInit&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fShadowColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fCornerRadius&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fOption&quot;</span>:<span class="hljs-string">&quot;blNDC&quot;</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;title&quot;</span>,<span class="hljs-string">&quot;fTextAngle&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextSize&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextAlign&quot;</span>:<span class="hljs-number">22</span>,<span class="hljs-string">&quot;fTextColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fTextFont&quot;</span>:<span class="hljs-number">42</span>,<span class="hljs-string">&quot;fLabel&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fLongest&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fMargin&quot;</span>:<span class="hljs-number">0.05</span>,<span class="hljs-string">&quot;fLines&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TList&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;TList&quot;</span>,<span class="hljs-string">&quot;arr&quot;</span>:[&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TLatex&quot;</span>,<span class="hljs-string">&quot;fUniqueID&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fBits&quot;</span>:<span class="hljs-number">50331648</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;fTextAngle&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextSize&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextAlign&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fTextFont&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fX&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fY&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fLineColor&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineStyle&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;fLineWidth&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fLimitFactorSize&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;fOriginSize&quot;</span>:<span class="hljs-number">0.0467500016093254</span>&#125;],<span class="hljs-string">&quot;opt&quot;</span>:[<span class="hljs-string">&quot;&quot;</span>]&#125;&#125;],<span class="hljs-string">&quot;opt&quot;</span>:[<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;blNDC&quot;</span>]&#125;,<span class="hljs-string">&quot;fExecs&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fName&quot;</span>:<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-string">&quot;fTitle&quot;</span>:<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-string">&quot;fNumPaletteColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fNextPaletteColor&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fDISPLAY&quot;</span>:<span class="hljs-string">&quot;$DISPLAY&quot;</span>,<span class="hljs-string">&quot;fDoubleBuffer&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fRetained&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;fXsizeUser&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fYsizeUser&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fXsizeReal&quot;</span>:<span class="hljs-number">20</span>,<span class="hljs-string">&quot;fYsizeReal&quot;</span>:<span class="hljs-number">14.28571</span>,<span class="hljs-string">&quot;fWindowTopX&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fWindowTopY&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fWindowWidth&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fWindowHeight&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;fCw&quot;</span>:<span class="hljs-number">696</span>,<span class="hljs-string">&quot;fCh&quot;</span>:<span class="hljs-number">472</span>,<span class="hljs-string">&quot;fCatt&quot;</span>:&#123;<span class="hljs-string">&quot;_typename&quot;</span>:<span class="hljs-string">&quot;TAttCanvas&quot;</span>,<span class="hljs-string">&quot;fXBetween&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fYBetween&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fTitleFromTop&quot;</span>:<span class="hljs-number">1.2</span>,<span class="hljs-string">&quot;fXdate&quot;</span>:<span class="hljs-number">0.2</span>,<span class="hljs-string">&quot;fYdate&quot;</span>:<span class="hljs-number">0.3</span>,<span class="hljs-string">&quot;fAdate&quot;</span>:<span class="hljs-number">1</span>&#125;,<span class="hljs-string">&quot;kMoveOpaque&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;kResizeOpaque&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;fHighLightColor&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fBatch&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;kShowEventStatus&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;kAutoExec&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;kMenuBar&quot;</span>:<span class="hljs-literal">true</span>&#125;);</span><br><span class="javascript">       Core.draw(<span class="hljs-string">&quot;root_plot_1&quot;</span>, obj, <span class="hljs-string">&quot;&quot;</span>);</span><br>     &#125;<br> );<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以发现最显著的差异在这一部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">requirejs.config(&#123;<br>    paths: &#123;<br>      <span class="hljs-string">&#x27;JSRootCore&#x27;</span> : <span class="hljs-string">&#x27;https://root.cern.ch/js/notebook//scripts/JSRootCore&#x27;</span>,<br>    &#125;<br>  &#125;);<br></code></pre></td></tr></table></figure><p>在<code>online</code>部分，调用了root官网的JSRootCore库，而<code>offline</code>则试图从本地服务器寻找。在</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    <span class="hljs-comment">// All requirements met (we are in jupyter notebooks or we loaded requirejs before).</span><br>    display_root_plot_1586256162911();<br>&#125; <br></code></pre></td></tr></table></figure><p>中添加<code>alert</code>函数。<code>alert</code>会执行。意味着会直接执行<code>require([&#39;scripts/JSRootCore&#39;],...)</code>函数，相比于<code>online</code>，缺失的正是上面提到的从root官网加载js这一部分。<br>遵从最少修改原则，为了将导出的html正常显示图，只许将<code>require([&#39;scripts/JSRootCore&#39;],</code>更改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">requirejs.config(&#123;<br>     paths: &#123;<br>       <span class="hljs-string">&#x27;JSRootCore&#x27;</span> : <span class="hljs-string">&#x27;https://root.cern.ch/js/notebook//scripts/JSRootCore&#x27;</span>,<br>     &#125;<br>   &#125;);<br> <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;JSRootCore&#x27;</span>],<br></code></pre></td></tr></table></figure><p>即可.<br>在<code>bash</code>中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -i <span class="hljs-string">&quot;s/require(\[&#x27;scripts\/JSRootCore&#x27;\],/requirejs.config(&#123;paths:&#123;&#x27;JSRootCore&#x27;:&#x27;https:\/\/root.cern.ch\/js\/notebook\/\/scripts\/JSRootCore&#x27;,&#125;&#125;);require(\[&#x27;JSRootCore&#x27;\],/g&quot;</span> output.html<br></code></pre></td></tr></table></figure><p><code>output.html</code>为v620导出的html. 由此即可实现导出的html正常绘图.<br>如果需要发布或共享ipynb文件,则需要额外删除其他部分。<br>为了方便起见，在bashrc中构造函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">py2html()<br>&#123;<br>sed -i &quot;s/require(\[&#x27;scripts\/JSRootCore&#x27;\],/requirejs.config(&#123;paths:&#123;&#x27;JSRootCore&#x27;:&#x27;https:\/\/root.cern.ch\/js\/notebook\/\/scripts\/JSRootCore&#x27;,&#125;&#125;);require(\[&#x27;JSRootCore&#x27;\],/g&quot; $1<br>sed -i &quot;s/\&quot;if (typeof/bbbegin/g&quot; $1<br>sed -i &quot;s/\&quot;    display_root_plot/eeend\&quot;    display_root_plot/g&quot; $1<br>sed -i &quot;s/\&quot;&#125; else &#123;/bbbegin/g&quot; $1<br>sed -i &quot;s/\&quot;function display_root_plot/eeend\&quot;function display_root_plot/g&quot; $1<br>sed -e &#x27;/bbbegin/!b;:a;/eeend/bb;$!&#123;N;ba&#125;;:b;s/bbbegin.*.*eeend//&#x27; -i $1<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>bash</code>中执行<code>py2html *.ipynb</code>或<code>py2html *.html</code>即可将其转化为有图的文件。<br>由于转义符号的问题，部分文件可能需要重命名方能正常转化.<br>此部分也可在<code>py2html</code>函数中用中间变量解决，这点回头再修正。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日程表</title>
      <link href="2020/04/01/%E7%A8%8B%E8%A1%A8/"/>
      <url>2020/04/01/%E7%A8%8B%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="81d51cdac79a74c14c9e49f5cc680c2987011c7fdf130833ade15f78c6c851be">c04d434e9f9b9f4f4248d4c81626eabfcd1188e9177d6a8a417acc0cff6aa7287bc73795ff97571c71769c73f33c57cfe1592911454e801702828f1f1f3442d6a760866896b08ead411661331326c0eed2fc6f1f2d11a6b09434074df478dca89abe3bff0713512634bef6b1dde36f5576f5e07ce7e7b839950123b8d3281fda1c57655a5b0d3d26488cd5149af3de7f6822ae48a4d12d9dc9d8aee00f5b0578fe361706535b18a432497f5aad5d3a697584083d6914823fdab131f2f9f8284a5d480adaee51d187023ad8217c008d12a06e0e324a17c488da2cad902cbfd27ff6c1276cab4f2f655dcd4843c781cb450f8da99b47b48c1194d6b50b727411eea205fb017b155ec10b9df06be337a285898343700e9f410a09df2e6212e4551dc45059820e05f6d8318a2db4b902920eca71ae337696afee6397c94a7a681a089f1768219b9327ccb502eb1fbbc554d897c8c225e74a06903a92bffe32fa9392746476ea81d7962cf05f8362a94513d5b134ad563dfd63218c4c3745d0179110b4c383de079d5b5be0f772e5e0f4a91a84552fc9e447aeda22c1593716cf40331bf5ae161231c98c44f8dd6d9a69460db6f2b3df5dff6669b192463a0c548c84a38d1f84f7a0837c737c163740a3886e9cf5be557ab9d7448f24eeae68906f230f721da1a16ca8ae470b16703f3212b5036cf433751aa70543e1d171ce43368b69026092d27904e511418896f5b729bbf5aea1e0ee4f5115fa9c4873e9fa24a2eac06e3a0d6fe18f8c1e96839c906a8468a32b255c2b09464fb5a2d1d5cfa233f630f1472dfa3dafd1d18bd244b74a2d5f51620417319bc5c1232709111da93da9154a6a23696fdbbbb33c917ae61ddc0fb9819a9e73892ac5390db20d9a32e835f14c1cc38425393b05c40c6483e906c579870e228df161adb700d80364bc9fcbe06d3e40e216ecb42bb8218a83707d7b05cc42437960347471cbb40ada9949f817fc21bb993064bb920af406492d98f456c5fdf8dd7bf95dd49e49d2deb0bf6120fddf3f36a0c7cc4c595c24276299dd6fe256459d2ab6d84a581d6f3a9a1816e8894fa74ac37b742d258989f62d895b596590cb0abb5c68e27521c8b754410441b20cb71968fb0d3cb4280a7e94bdbefa1820dd7b101bd03b4fc04f8fa038d1e9b8a0adbfa269c5b3a4797fea6c1aa5ff41b6f8994d1880c6ace68295dce8cd7e4d85cfae8994a5d53e8519364b152f6d8b9a90122522f1d9a0fd4288ce908b58c96e42eaab8090a4b6944f1036794d70149457c896bac0242b33939471cfd12ba5499abbf33fbe691083387d3df994525df322c350637b14cb348237b9de69e487310b833383a27ce193d4812a5607edcc774eb40abab9fd63d51041da9e6b84951590e148585d8c0e313821a85d3b3c4993fbd48abaa0a16cfe90599e8bfd084785cce6da44492bd63df9c145ed7a3febd6e10e8bc2ff286129ec8b5eae97d2a92fec48a4ffd7cc9ac39444a0523bd97254f835d5f135d73d06af45ba3f82fe9d42eae021eca129c3c228bfee9ada784602a5915ea9752102139282d7e5e901a9331c9a0af383b313b92815c454891eea8baf454637a7ef8d4f6418d2f4260854037581dfd2476b6e109327050d1f710672e88bdee45eb41172cb77bd6fa37f1add4d3d3f5d25e863769cc32c8802f1056d8f0cc5ccfcbf1a36e932aea0782dcfc4fe70795e6be7bb57a209d323df670a9cba65a5bbeaadc6ce30806925e2161efdc578324e7204c020d217f429a44665e270cce9c8239a080d2e6be665e7cf90ec04a736582bc2002ba4b61c98ddf06c604720a6b7dd5fc46897bffcf5528b8e676dcb3af60acac0666e9b212dcd5aab82405344becb5d4c46cad17a928278a2dc00f1c562d32d0c78a76dcb644dfd90906b8d5345b03da1af49a8fccacf150791746d7a3c9bf35bd1e27d5ce9275c7daaaf669e9951d97d3729b7262a77da7ad1852e43b4c5c655002c9696309984dfdfdf15f4bbb53593610bfb9f16d745cb5c967547d118c69eeaa38f4dd63ac8b6b13dd4cb8722d130f2c2322faa6cd47e728d08a67605c28202b81a56939d4f9435c40b805ea0d25c3ac14adcc99cb71fa79226cf57a056194020bbe5a853e7b99ea5a6d1a95a51c004176f11207620ca799800e0909871e12958239ff2abce16b5ebd032ddb02af58e22f31d58fe1634dec00a6120229dc1a02b4724327e3206409b3c77c052e87f91c7f6f5a2c7a68b067e4a94209e9254779fd4fc4aebc08977edb8f334eca1e6458820dd9bd0d4047f8382da4732047d393ec4d644015177cac8471c40b5e1b0feaed83513103dcedd419a8481c40e0af8ba71cb342afd31affe29a18be8f9498226b2ae14226dfb5c3b3280c097012b5388902556ae8c2536ba324b11366d3c97998472a88feb11510cc05ac2e3079e1a585e2d0c747a31cfb425de9579d463159e75065828a1302db5fc6d482a5e4071c8d95c4f1034aa8201514c4cad7c8b7954c8a7440ce078d05781fd3e0724055e75bb7c1392e03e85cc06e3dce2e41888f5205bda4e12dc6d7a9ec4191e19063cb9cac4f25919771661e717ee547fc329a10b9931676f27e90112e6989b716c04ebbd662cbf654af12eebd01d83a8ff196282fe54eba43ec4e11e167d8e64babd8251ece97836761eb04e7f9861881f2368a901af41be32900609a4dab192e1e67e37546ce335347aa9b7bb88c821aebf853a71217685d9c2fedd5ba27c84557c81a863142d803df38f3d5a3d5b2c95e8d0213e6a3ba077bf4a85e61fb0dc84b4dfe248fcd63da26f740d6a4165756e3f31c0b29ddbffb5b7e0e86b3d05080d4d3273d6883bc8a198ba20e6694c4d19907fad00ed7e23f5c599445bc08c511d5fb3bedb77d57dfe475a269523a0908ae591b3115bdb23677f866b2f5ffe6211baa9f67b7cbc3527beccde0b29ca3b965595c94a2ce73c93ff9329d027c31ff31a889c93ffeb004dc64a87184d247d691ae928003d8534d1ba6d15ab8269548a57633fce13d10cdec6c3850492b5b808f03f5581a7627581965f786f8e7844148140077d615bf3a227b4e09eb6dc19ffeab3c5698e3c7444706a54556d9af11f7aa6b2891b4b783c4719ebd67914038f2218cde7ba8a0b246a94ec7003b7e6e7fa4ae4725d1488ef0d902eb0a83d3a32c8d299f52144a6fcb300104ea1fd24caee589727236f3e1657d2f5f252cc504f1ae14470c0070ad0fd270c246c607fe626e4c404dffca0c5ffffa56d20252ed067716ca66e3b1fffbc0dee0e2f67d71714997832ee21c905c13d0247485d2524a5e947b7aa8ab23df4ab2d22cc4810cc2aee06e04d57cd829ba54e9349300768949133c73cd80f79275f962db3c3c8ab4772d912ebdf8e21c12bf550cb856a0590d0ff167d7179291694ea6cc0f145e244f921b7fb0cfc0f3b3544086b599433b3c659af0ef98bc2f29c390be3edee967249a71634c0c13396ccd3d4857ad1cc0b3cef3e590a78e615f857cd8825dd530291bcc3cb37614332c8e4bd1135dc21b3e84eca5723bf69776752ddd2eba8dbdfe7b2904942cc29e98c0621bd4e25ddbb6451289f2b30c36fc01724542478274689ba8bdc2cba4738b230659d62a795971d09bdad5cc50d642a8440f63bec4152cd3326ba320c3af83580b032a65cd2418f842665fa070b6d7c40497c6062147a64c1673a417f58a3a8dda2bc309555ec39273361bf90b1381bc45ba97c764f90bb7c4fface5bf13eeaa54c0736aed762cd7e9b6679dc56b369d2fe0f67a34b3d895ff4dc3dbe8761fbaa0727e93b1102d02a81985ecca61672597129319e9a1c7861997887c93997a088dd1698b835d9f3a392c8149268e94f3364426bf5e1100c7908f4e2c29b4aa16442de43b8d12f45afe5c2aab792773a65a77548acf20d6da929c5eba5cabd1b9faad14e2d2818fb77e4854ac81c0c31336746ae41407ee731b28bf52873ed85c49e2cc29e6043c400de1aa0d801c5003271ccdf889eca4062402bfa893a2c98b94780188b4d8149e04398bc7e63f583b4cc95ce9138316c933f86018760e6784acb21b2e4d75760c112613d25c0cfbeb3ec2cf12214466f06b6bea54f3cc77ee043bb3eb5c89fadedfd279675cffad156cc1cc7d4462416115798f4d2d4d3e13530a276ba95494b66c68c5ada1210f937207752c6beb29b4138a8162615ef3bd8748adaf2e4e09cafafbc2be07ba23e6a9f59f466dc4e651b82bbb658092f9a2d75ca79d7a1612fb5d195ed1731abc877f1b7b0f07e4f5d0eca3babf763a0b9e2d3d68e56dc7b3668b9f4bc2c33a893aa56e75471bb9f3203b2253e76f6c1573e2d691927a0d4f0c481bf357aa39fd8961cd2dff4aa5c922ca1f2e281b72db96c72c3686af1ad0fddfd085d0df67ae77f2ec86a72c8f5b46bf179adcd2fef43416674bb4e1efc564a0903b7644da753861f357397d106b5f15aaf1e34407e00411df06029998d6c1e38402c69e301625c141cade5bf03ad25201f53c303032834a065ebcba032a5d1af6b559c65b28b6fa61650a1155a3db4eaf9c3089a1e248ede5234481108b9abd1d1f84d56f3c850100fa12c053e16f8739f9673cece8fdd797811d81d7019fc210400dfcb03efde37b2c4b6c3ccd59b82f6ac510685fa1deb2a167151ba68df8746390acd250598144889422a818a53f7df22053fcbcb5f7473de983fc31dd1fae21e54920ed1d2126f372a47e6a894f67019507235c41340035ace67f01e9c4531305571ac47afef61cc724e46337176e165a70adadfab4fd6417b009e9de472546d9431721191eb327b45d677ef042d1a7f46e7209a0f5300960d165ec8f44c2d517d52af5436bb6dcdf63985672b44947180a2bad66f1d19894274f36129ec151bc8766f170c6b0aa60e9cc695e483c2202bb3fdb406254bc37608a8000828706e653778d905db90caa95ab5b34eb26b2efe9c3c7b6b63dd58f4614acde4038ccec11b09683c933388eb38959e46f6537040a4600ec48edcf5cf5c133f1785d2c987a1825198c0e9d5ea4dfade13d9d9e300ba9641496dbd560defadfefe00e10190cf8e2aaa42476a1026119a9ff98df50060a1c8474734e77efc1396a1b83a4191bc287f2a994f9a2ebbbcb0a4fb0d96fbb91828b61eb2b3e915f45cbade6e3d7e71a8c64b758675104cf43530f543fd5e4e67ef42538c5422124ab5985f22</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo设置端口和ip</title>
      <link href="2020/04/01/Hexo%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E5%92%8Cip/"/>
      <url>2020/04/01/Hexo%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E5%92%8Cip/</url>
      
        <content type="html"><![CDATA[<p>在bash中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s -i -p 8000<br></code></pre></td></tr></table></figure><p><code>-i</code> 可以开放外部网路访问，若去除该选项，则只能本机<code>localhost</code>访问.<br><code>-p 8000</code>可以用来设置端口，默认端口为4000.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter指定配置文件启动</title>
      <link href="2020/03/27/Jupyter%E6%8C%87%E5%AE%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%AF%E5%8A%A8/"/>
      <url>2020/03/27/Jupyter%E6%8C%87%E5%AE%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p><code>jupyter</code>默认配置文件为<code>~/.jupyter/jupyter_notebook_config.py</code><br>若有多种配置需求如端口，启动路径，密码，是否允许远程访问，则可以将<code>jupyter_notebook_config.py</code>复制一份进行修改，随后重命名或者放置到其他目录。为了方便管理，可以修改名字，如<code>jupyter_notebook_config_remote.py</code>，启动jupyter命令为<br><code>jupyter-notebook --config=&#39;~/.jupyter/jupyter_notebook_config_remote.py&#39;</code>. 而默认的配置依旧可以使用<code>jupyter-notebook</code>启动.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决vscode 打开WSL 系统目录出错的问题</title>
      <link href="2020/03/26/%E8%A7%A3%E5%86%B3vscode-%E6%89%93%E5%BC%80WSL-%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%87%BA%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2020/03/26/%E8%A7%A3%E5%86%B3vscode-%E6%89%93%E5%BC%80WSL-%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%87%BA%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>更新系统至<code>windows v2004</code>版本之后，在非<code>Windows</code>系统目录(即非<code>/mnt</code>)打开<code>vscode</code>会提示错误，需要手动前往<code>\\wsl$\Arch\mnt\c...</code>之类的目录用<code>vscode</code>打开. 在<code>wsl</code>系统下输入<code>code \\wsl$\Arch\mnt\c...</code>也会同样报错。<br>解决此问题，只需要进入<code>Windows</code>系统目录，再执行<code>code //wsl$/Arch/home/yfs/...</code>即可。命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> code=<span class="hljs-string">&#x27;result=$(pwd | grep &quot;mnt&quot;);if [[ $result ]];then code .;else a=`pwd` &amp;&amp; cd /mnt/c/ &amp;&amp; code &quot;//wsl$/Arch$a&quot;&amp;&amp; cd $a;fi&#x27;</span><br></code></pre></td></tr></table></figure><ol><li>先判断当前目录是否包含mnt,若包含，则为windows目录环境，直接code即可;</li><li>若为wsl系统目录，先记录当前目录，随后进入windows目录，code打开映射的wsl路径，随后返回原目录。<br>Tips:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">linux环境下,alias 的优先级高于$PATH.<br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Magic </tag>
            
            <tag> wsl </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter离线配置</title>
      <link href="2020/03/25/Jupyter%E7%A6%BB%E7%BA%BF%E9%85%8D%E7%BD%AE/"/>
      <url>2020/03/25/Jupyter%E7%A6%BB%E7%BA%BF%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>此文档不是用于离线安装jupyter，而是解决jupyter因网络问题无法正常显示图像的问题。<br>修改文件：<code>~ /.jupyter/jupyter_notebook_config.py</code><br>定位到 <code>c.NotebookApp.extra_static_paths</code> 这一行，修改为<br><code>c.NotebookApp.extra_static_paths = [&#39;/usr/share/root/js&#39;]</code><br>其中<code>&#39;/usr/share/root/js&#39; </code>根据root安装的目录来确定.<br><img src="/images/pasted-2.png" alt="upload successful"><br>可以通过<code>find</code>命令来确定该路径.</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jupyter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python执行jupyter脚本并返回结果</title>
      <link href="2019/11/24/python%E6%89%A7%E8%A1%8Cjupyter%E8%84%9A%E6%9C%AC%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/"/>
      <url>2019/11/24/python%E6%89%A7%E8%A1%8Cjupyter%E8%84%9A%E6%9C%AC%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<p>系统中只存在python环境而没有jupyter环境可用，希望python能够直接执行jupyter脚本(*.ipynb)文件，并将结果返回（同时输出到*.ipynb脚本和终端）.<br><a href="https://raw.githubusercontent.com/mission-young/python_scripts/master/jupyter.py">下载地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs python3">#!&#x2F;usr&#x2F;bin&#x2F;python3<br>import sys<br>import json<br>import os<br>class tovar():<br>    &quot;&quot;&quot;重定向python的输出至变量<br>    print()函数实际上是 sys.stdout 函数，默认输出到终端。<br>    这里将print()函数重定向到变量<br>    Attributes:<br>        str: 用于存储print函数输出的结果<br>    &quot;&quot;&quot;<br>    def __init__(self):<br>        &quot;&quot;&quot;<br>        初始化函数，必备函数<br>        &quot;&quot;&quot;<br>        self.str&#x3D;&#39;&#39;<br>    def write(self,s):<br>        &quot;&quot;&quot;<br>        将print的值暂存到str，如果多次print，则值会累加，必备函数<br>        &quot;&quot;&quot;<br>        self.str+&#x3D;s<br>    def flush(self):<br>        &quot;&quot;&quot;<br>        清空str，必备函数<br>        &quot;&quot;&quot;<br>        self.str&#x3D;&#39;&#39;<br>    def content(self):<br>        &quot;&quot;&quot;<br>        返回str，将暂存的输出返回到变量中<br>        &quot;&quot;&quot;<br>        return self.str.rstrip()<br><br>def writecode(s,mode&#x3D;&#39;update&#39;):<br>    &quot;&quot;&quot;<br>    update模式时，为累加模式<br>    recreate模式时，重写模式<br>    &quot;&quot;&quot;<br>    if mode &#x3D;&#x3D; &#39;recreate&#39;:<br>        w&#x3D;&#39;w&#39;<br>    else:<br>        w&#x3D;&#39;a&#39;<br>    fout &#x3D; open(&#39;tmp.py&#39;,w,encoding&#x3D;&#39;utf8&#39;)<br>    fout.write(s)<br>    fout.close()<br># 获得要转化的jupyter文件<br>filename&#x3D;sys.argv[1]<br># jupyter文件格式实际上是json格式，选择自带的json库来读取，读取后关闭文件<br>file&#x3D;open(filename)<br>data&#x3D;json.load(file)<br>file.close()<br>cells&#x3D;data[&#39;cells&#39;]<br># 命令单元格的id，必须设置，否则不会显示执行结果<br>id&#x3D;1<br># term暂存，为输出到终端，随后将print重定向到变量var<br>var&#x3D;tovar()<br>term&#x3D;sys.stdout<br>sys.stdout&#x3D;var<br><br>for cell in cells:<br>    cell_type&#x3D;cell[&#39;cell_type&#39;]<br>    # 单元格为markdown时，不需要处理，打开jupyter文件会自动转换<br>    if cell_type&#x3D;&#x3D;&#39;markdown&#39;:<br>        continue<br>    else:<br>        # 当jupyter清空了所有输出时，execution_count为null，如果不设置id的话，即使<br>        # 有执行结果，在jupyter中也不会显示。<br>        cell[&#39;execution_count&#39;]&#x3D;id<br>        # 将print重定向到终端，以便在终端输出进度，随后重定向到变量<br>        sys.stdout&#x3D;term<br>        print(&#39;process: %d&#x2F;%d&#39; %(id,len(cells)-1))<br>        sys.stdout&#x3D;var<br>        id+&#x3D;1<br>        codes&#x3D;cell[&#39;source&#39;]<br>        #新建代码单元格存储文件<br>        writecode(&#39;&#39;,&#39;recreate&#39;)<br>        for code in codes:<br>            # 修正jupyter中一些magic code<br>            if &#39;matplotlib inline&#39; in code:<br>                code&#x3D;&#39;import matplotlib.pyplot as plt\n&#39;<br>            # 逐行写入code cell的代码到文件中<br>            writecode(code)<br>        # 执行代码单元格代码，这种形式执行的好处在于，等价于直接把代码拷贝到主程序中，<br>        # 程序变量等信息保留。由于此时print重定向到tovar函数的str变量中，并不会在终端输出信息。<br>        exec(open(&#39;tmp.py&#39;).read())<br>        # 获取代码运行的结果<br>        result&#x3D;var.content()<br>        # 清空缓存，以便于存储下一次结果<br>        var.flush()<br>        # 代码运行为空跳过<br>        if(result.strip()!&#x3D;&#39;&#39;):<br>            # 这一点用来判定原jupyter是否有输出，如果没有输出，则需要新建dict，否则只需要替换<br>            # 相应部分既可以。<br>            if len(cell[&#39;outputs&#39;])&#x3D;&#x3D;0:<br>                out&#x3D;&#123;&#125;<br>                out[&#39;name&#39;]&#x3D;&#39;stdout&#39;<br>                out[&#39;output_type&#39;]&#x3D;&#39;stream&#39;<br>                out[&#39;text&#39;]&#x3D;[res + &#39;\n&#39; for res in result.split(&#39;\n&#39;)]<br>                cell[&#39;outputs&#39;].append(out)<br>            else:<br>                cell[&#39;outputs&#39;][0][&#39;name&#39;]&#x3D;&#39;stdout&#39;<br>                cell[&#39;outputs&#39;][0][&#39;output_type&#39;]&#x3D;&#39;stream&#39;<br>                cell[&#39;outputs&#39;][0][&#39;text&#39;]&#x3D;[res + &#39;\n&#39; for res in result.split(&#39;\n&#39;)]<br>            # 在终端中输出<br>            sys.stdout&#x3D;term<br>            print(result)<br>    # 每运行一次code cell，修改jupyter文件<br>    file&#x3D;open(filename,&#39;w&#39;)<br>    json.dump(data,file)<br>    file.close()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jupyter </tag>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习资源汇总</title>
      <link href="2019/11/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
      <url>2019/11/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<ul><li>Grokking Deep Learning （图解深度学习）<br>  - 个人主页：<a href="https://iamtrask.github.io/">https://iamtrask.github.io/</a><br>  - Github地址：<a href="https://github.com/iamtrask/Grokking-Deep-Learning">https://github.com/iamtrask/Grokking-Deep-Learning</a><br>  - pdf文档 <a href="https://github.com/mission-young/Hexo_attachment/blob/master/pdf/Manning.Grokking.Deep.Learning.pdf">https://github.com/mission-young/Hexo_attachment/blob/master/pdf/Manning.Grokking.Deep.Learning.pdf</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作计划</title>
      <link href="2019/10/11/%E5%B7%A5%E4%BD%9C%E8%AE%A1%E5%88%92/"/>
      <url>2019/10/11/%E5%B7%A5%E4%BD%9C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="TODO："><a href="#TODO：" class="headerlink" title="TODO："></a>TODO：</h2><ol><li>织围脖🧣</li><li>双十一买内衣内裤</li><li>提醒公考报名</li><li>数据处理-吴鸿毅刻度</li><li>数据处理-计算探测效率</li><li>学习swiftui</li><li>学习机器学习</li><li>整理房间</li><li>买西藏火车票</li><li>定西藏的行程</li><li>给宇宇买吃的</li><li>去健身房健身</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>macOS配置Qt开发环境</title>
      <link href="2019/10/10/macOS%E9%85%8D%E7%BD%AEQt%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>2019/10/10/macOS%E9%85%8D%E7%BD%AEQt%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="安装qt和qtcreator"><a href="#安装qt和qtcreator" class="headerlink" title="安装qt和qtcreator"></a>安装qt和qtcreator</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install qt<br>brew cask install qt-creator<br></code></pre></td></tr></table></figure><h2 id="配置qt环境"><a href="#配置qt环境" class="headerlink" title="配置qt环境"></a>配置qt环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export PATH=&quot;/usr/local/opt/qt/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zshrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export LDFLAGS=&quot;-L/usr/local/opt/qt/lib&quot;&#x27;</span> &gt;&gt; ~/.zshrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export CPPFLAGS=&quot;-I/usr/local/opt/qt/include&quot;&#x27;</span> &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS初始化</title>
      <link href="2019/10/10/macOS%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>2019/10/10/macOS%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="安装homebrew"><a href="#安装homebrew" class="headerlink" title="安装homebrew"></a>安装homebrew</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/bin/ruby -e <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span><br></code></pre></td></tr></table></figure><h2 id="安装第三方软件权限问题"><a href="#安装第三方软件权限问题" class="headerlink" title="安装第三方软件权限问题"></a>安装第三方软件权限问题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo spctl --master <span class="hljs-built_in">disable</span><br></code></pre></td></tr></table></figure><h2 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;mission-young&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;yuanfangsee@pku.edu.cn&quot;</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;yuanfangsee@pku.edu.cn&quot;</span><br>cat ~/.ssh/id_rsa.pub<br><span class="hljs-comment">## paste it to github</span><br></code></pre></td></tr></table></figure><h2 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h2><ul><li><a href="https://mission-young.github.io/2019/08/18/%E5%A4%9A%E7%AB%AF%E7%BC%96%E8%BE%91Hexo%E5%8D%9A%E5%AE%A2/">Hexo博客</a></li><li><a href="">Qt</a></li><li>root<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install root<br></code></pre></td></tr></table></figure></li><li>tmux <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install tmux<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs .tmux.conf"># Send prefix<br>set-option -g prefix C-a<br>unbind-key C-a<br>bind-key C-a send-prefix<br># Use Alt-arrow keys to switch panes<br>bind -n M-Left select-pane -L<br>bind -n M-Right select-pane -R<br>bind -n M-Up select-pane -U<br>bind -n M-Down select-pane -D<br># Shift arrow to switch windows<br>bind -n S-Left previous-window<br>bind -n S-Right next-window<br># Mouse mode<br>set -g mouse on<br><br># Set easier window split keys<br>bind-key v split-window -h<br>bind-key h split-window -v<br># Easy config reload<br>bind-key r source-file ~&#x2F;.tmux.conf \; display-message &quot;tmux.conf reloaded&quot;<br></code></pre></td></tr></table></figure></li><li>[geant4]</li><li>ssh <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;alias sshribll=&quot;ssh -Y -p 2727 wuchenguang@162.105.151.64&quot;&#x27;</span> &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure></li><li>xquartz<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew cask install xquartz<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 删除某个名字的进程</title>
      <link href="2019/09/19/Linux-%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E5%90%8D%E5%AD%97%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
      <url>2019/09/19/Linux-%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E5%90%8D%E5%AD%97%E7%9A%84%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>linux kill 掉所有匹配到名字的进程<br>如，要 kill 掉 swoole 相关的进程<br>ps aux | grep swoole |  awk ‘{print $2}’ | xargs kill -9<br>ps 列出所有进程，<br>参数：<br>a - 显示现行终端机下的所有进程，包括其他用户的进程；<br>u - 以用户为主的进程状态 ；<br>x - 通常与 a 这个参数一起使用，可列出较完整信息。<br>grep 过滤掉不包含 “swoole” 的行<br>awk ‘{print $2}’    获取进程 ID (PID， Process Identification)，我们想 kill 掉某一个进程的时候需要通过 PID 指定特定进程<br>xargs  将标准输入数据转换成命令行参数，xargs能够处理管道或者stdin并将其转换成特定命令的命令参数。<br>也就是将管道传递过来的每一个 PID 作为 kill -9 的参数</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git ssh中转设置 / git push多个终端</title>
      <link href="2019/09/13/git-ssh%E4%B8%AD%E8%BD%AC%E8%AE%BE%E7%BD%AE-git-push%E5%A4%9A%E4%B8%AA%E7%BB%88%E7%AB%AF/"/>
      <url>2019/09/13/git-ssh%E4%B8%AD%E8%BD%AC%E8%AE%BE%E7%BD%AE-git-push%E5%A4%9A%E4%B8%AA%E7%BB%88%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<p>实验室服务器尽管已经设置代理上网，但是访问git的时候，只能通过http clone项目，因而不满于实际开发需求。因而需要换种方式实现。<br>上网搜索，发现大多数方案要求借助于代理服务。在非管理员条件下想要实现代理服务并不容易，而且系统已经内置了代理，两者也容易发生冲突。<br>借助先前git内网服务搭建的经验，采用中转的方式来实现。</p><h3 id="在server端初始化git仓库"><a href="#在server端初始化git仓库" class="headerlink" title="在server端初始化git仓库"></a>在server端初始化git仓库</h3><ul><li><p>project: testcode</p></li><li><p>path: /data/d2/RIBLL2017NaMgAlSi/gitbackup</p></li><li><p>code: <code>git init --bare testcode</code></p><ul><li> 这一步会自动在gitbackup目录下创建testcode目录</li></ul></li><li><p>edit: 在testcode目录下创建<code>.gitignore</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Prerequisites</span><br>*.d<br><span class="hljs-comment"># Compiled Object files</span><br>*.slo<br>*.lo<br>*.o<br>*.obj<br><span class="hljs-comment"># Precompiled Headers</span><br>*.gch<br>*.pch<br><span class="hljs-comment"># Compiled Dynamic libraries</span><br>*.so<br>*.dylib<br>*.dll<br><span class="hljs-comment"># Fortran module files</span><br>*.mod<br>*.smod<br><span class="hljs-comment"># Compiled Static libraries</span><br>*.lai<br>*.la<br>*.a<br>*.lib<br><span class="hljs-comment"># Executables</span><br>*.exe<br>*.out<br>*.app<br><span class="hljs-comment"># root file</span><br>*.root<br></code></pre></td></tr></table></figure><h3 id="在server端自己的工作目录下clone-testcode项目"><a href="#在server端自己的工作目录下clone-testcode项目" class="headerlink" title="在server端自己的工作目录下clone testcode项目"></a>在server端自己的工作目录下clone testcode项目</h3></li><li><p>code: <code>git clone /data/d2/RIBLL2017NaMgAlSi/gitbackup/testcode</code></p></li><li><p>随后即可进入testcode工作目录创建自己的项目文件。正常add，commit和push</p><h3 id="在个人电脑端clone-testcode项目"><a href="#在个人电脑端clone-testcode项目" class="headerlink" title="在个人电脑端clone testcode项目"></a>在个人电脑端clone testcode项目</h3></li><li><p>code: <code>git clone ssh://wuchenguang@*:2727//data/d2/RIBLL2017NaMgAlSi/gitbackup/testcode</code></p><h3 id="在个人电脑端配置"><a href="#在个人电脑端配置" class="headerlink" title="在个人电脑端配置"></a>在个人电脑端配置</h3></li><li><p>push到github(执行一次) <code>git remote set-url --add --push origin git@github.com:mission-young/testcode.git</code></p></li><li><p>push到server(执行一次) <code>git remote set-url --add --push origin ssh://wuchenguang@*:2727//data/d2/RIBLL2017NaMgAlSi/gitbackup/testcode</code></p></li><li><p>同步push(需要时执行) <code>git push</code></p></li></ul><h3 id="bashrc-设置备份"><a href="#bashrc-设置备份" class="headerlink" title=".bashrc 设置备份"></a>.bashrc 设置备份</h3><ul><li>server<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git --init bare project</span><br><span class="hljs-built_in">export</span> gitserver=/data/d2/RIBLL2017NaMgAlSi/gitbackup<br><span class="hljs-comment"># eg. git clone $gitpath/code 用于clone server项目</span><br></code></pre></td></tr></table></figure></li><li>pc<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> gitserver=/data/d2/RIBLL2017NaMgAlSi/gitbackup<br><span class="hljs-built_in">export</span> gitpath=<span class="hljs-string">&quot;ssh://wuchenguang@*:2727/<span class="hljs-variable">$gitserver</span>&quot;</span><br><span class="hljs-comment"># eg. git clone $gitpath/code 用于clone server项目</span><br><span class="hljs-built_in">export</span> pushgithub=<span class="hljs-string">&quot;remote set-url --add --push origin git@github.com:mission-young&quot;</span><br><span class="hljs-comment"># eg. git $pushgithub/code 用于设置push到github</span><br><span class="hljs-built_in">export</span> pushserver=<span class="hljs-string">&quot;remote set-url --add --push origin ssh://wuchenguang@*:2727/<span class="hljs-variable">$gitserver</span>&quot;</span><br><span class="hljs-comment"># eg. git $pushserver/code 用于设置push到server</span><br><span class="hljs-comment"># 搞定上面几步之后，git push 可以同时上传到github与server</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> git </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>viscose setting sync</title>
      <link href="2019/09/11/viscose-setting-sync/"/>
      <url>2019/09/11/viscose-setting-sync/</url>
      
        <content type="html"><![CDATA[<p>Github Gist ID:1106f6e427b773a650cb0b038bdd2948。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>64服务器端口开放状态</title>
      <link href="2019/09/01/64%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE%E7%8A%B6%E6%80%81/"/>
      <url>2019/09/01/64%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<ul><li>服务器ip：162.105.151.64</li><li>开放端口8900：jupyter-notebook服务</li><li>开放端口8901：code-server服务</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>公务员备考攻略</title>
      <link href="2019/09/01/%E5%85%AC%E5%8A%A1%E5%91%98%E5%A4%87%E8%80%83%E6%94%BB%E7%95%A5/"/>
      <url>2019/09/01/%E5%85%AC%E5%8A%A1%E5%91%98%E5%A4%87%E8%80%83%E6%94%BB%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="2020年公务员考试相关信息整理"><a href="#2020年公务员考试相关信息整理" class="headerlink" title="2020年公务员考试相关信息整理"></a>2020年公务员考试相关信息整理</h2><ul><li>华图官网：<a href="http://www.huatu.com/guojia/">http://www.huatu.com/guojia/</a><br><img src="https://i.loli.net/2019/09/02/yX8lrKNdh7pkWbx.png"></li><li>照9月1号开始复习，12月1号考试，笔试历程整3个月，90天。</li><li>2020国家公务员考试职位表尚未发布，根据往年国考职位表发布时间推算，2020国家公务员考试职位表发布时间很可能在2019年10月中下旬。2019国家公务员考试招录规模今年进行了缩减，共有中央机关75个单位和20个直属机构参加，计划招录14537人,共9657个职位。</li><li>公告发布时即发布职位表，随后根据职位表选报。根据学历要求、专业要求、政治面貌要求、工作经历要求、地域特征等，进行选择。</li><li>笔试分为两大块：行测和申论，行测包括十个部分，130道题，120分钟，分别为<br> 1. 数量关系–数学运算<br> 2. 言语理解与表达–逻辑填空<br> 3. 言语理解与表达–语句表达<br> 4. 言语理解与表达–阅读理解<br> 5. 判断推理–逻辑判断<br> 6. 判断推理–图形推理<br> 7. 判断推理–定义判断<br> 8. 判断推理–类比推理<br> 9. 资料分析<br> 10. 常识判断</li></ul><p>国家公务员考试行测考试时间只有两个小时。<br>但是要完成5个专项130-135道题，根据了解，大部分考生做行测卷子后期都会碰到一个问题，时间不够，合理的时间安排可以说直接决定了行测能否拿高分。<br>在行测考试中共有5个专项9种题型（常识判断、图形推理、类比推理、定义判断、逻辑判断、逻辑填空、片段阅读、数量关系、资料分析）。<br>在这9种题型中有些题是需要快做的，包括常识判断，图形推理，类比推理，逻辑填空，常识判断20题，用时应控制在10分钟左右，平均30秒一道题左右，常识题不要去纠结，能做出来的很快就能做出来。<br>拓展资料：完善行测答题顺序，可提高效率<br>考前一个月左右的时候建议考生开始刷试卷，一来为了查缺补漏，二来就是找到最适合自己的做题顺序。<br>行测不仅考察的是你的解题能力，还考察考生两个小时的思维转换能力。每个考生的性格都不一样，有些考生适合从理性的思维跳到感性的思维，有些考生喜欢先做自己擅长的专项，有些考生需要一点时间才能进入做题状态等等，所以找到适合自己的做题顺序对行测作答可以起到事半功倍的效果。<br>先做常识进入考试状态，再做言语，接下来状态最好的时候做资料分析，趁热打铁完成判断推理，最后再做数量关系，做题顺序没有好坏之说，适合自己的就是最好的。<br>  申论只有一道大题，分为两大类题型，对策类和启示类。考试时间180分钟，总分100分。  </p><h2 id="时间分配"><a href="#时间分配" class="headerlink" title="时间分配"></a>时间分配</h2><p>  </p><ul><li><p>全面基础复习阶段 6周 手部受伤，前2周重点复习行测。根据书目录统计，<br> 1. 数量关系–数学运算 10节<br> 2. 言语理解与表达–逻辑填空 2节<br> 3. 言语理解与表达–语句表达 2节<br> 4. 言语理解与表达–阅读理解 6节<br> 5. 判断推理–逻辑判断 6节<br> 6. 判断推理–图形推理 7节<br> 7. 判断推理–定义判断 2节<br> 8. 判断推理–类比推理 4节<br> 9. 资料分析 3节<br> 10. 常识判断 12节</p><p> 课程总共有54节，2周时间为15天，需要一天完成4节内容。考虑到手的恢复情况，应将数量关系、判断推理–逻辑判断、资料分析三者往后放一点。剩下的部分大多需要在脑海中思考即可完成。因而复习顺序为：<br> 1. 2+3<br> 2. 4<br> 3. 4+7<br> 4. 6<br> 5. 6<br> 6. 8<br> 9. 10<br> 10. 10<br> 11. 10<br> 12. 1<br> 常识判断每天空闲的时候看一点。每天完成学习任务之后，查看app，进行做题。或者在路上的闲余时间进行做题。<br> 额外的时间听申论讲座。 </p></li><li><p>重点提高阶段 3周</p></li><li><p>纠错阶段 1周</p></li><li><p>冲刺阶段 2周</p></li></ul><h2 id="贴吧攻略"><a href="#贴吧攻略" class="headerlink" title="贴吧攻略"></a>贴吧攻略</h2><p>各模块的备考方法 <a href="https://tieba.baidu.com/p/5995995816?pn=1">https://tieba.baidu.com/p/5995995816?pn=1</a></p><h2 id="知乎收集的一些攻略"><a href="#知乎收集的一些攻略" class="headerlink" title="知乎收集的一些攻略"></a>知乎收集的一些攻略</h2><p>链接：<a href="https://www.zhihu.com/question/28345057/answer/41074035">https://www.zhihu.com/question/28345057/answer/41074035</a><br>我的计划就是按照3个月12周的时间来指定的。一共有四轮，<br>第一轮时长6周，全面基础复习阶段；每天上午行测，下午申论，晚上做题；复习时候我的方法主要是视频教程，这些教程都是在网盘上面免费分享的，我直接下载下来，每天看视频学习，做笔记。老老实实把行测和申论的基础班课程都学习了一遍，辅以少量的练习题，目的是全面的了解公考的知识点，做好笔记，并尽可能的掌握。其中申论是听张小龙的课程，行测数量关系部分是魏华刚和郭亮的课，这三位老师是讲课比较有风格和方法的，推荐一下。<br>第二轮时长3周，重点提高阶段，提升我第一轮复习中比较薄弱的地方；重点提升部分是通过第一轮学习过程中总结出来的，这一阶段主要学习方法是听视频+做题相结合，视频的话也是重点提高班或者高分班视频，相比来说课时短了不少，做题量增加，把重要的知识点认真学习一遍，掌握做题技巧与方法，并通过一定量的习题训练巩固。<br>第三轮时长1周，纠错阶段，我有一个错题本，在头两轮复习过程中做错的和不会的典型例题我都记录了下来，错题后面对应的都是考点，因此通过错题纠正以及练习同类题目的办法，把薄弱的考点彻底掌握。<br>第四轮时长2周，冲刺阶段，1到2天一套真题掐表训练。这个基本就是1天按照考试时间掐表做真题，然后晚上纠错，直到考前。 </p><p>链接：<a href="https://www.zhihu.com/question/28345057/answer/267088186">https://www.zhihu.com/question/28345057/answer/267088186</a><br>我认为行测复习只分三个阶段。新人先学习一下整个行测模块，有哪些题型。(看书只需要2-3天)然后开始做题，计时110分钟做一套真题，你就知道自己的初始水平。有复习经验的可以跳过这步。<br>(有人问我就说一下我的做题顺序和时间安排:常识5min，言语30min以内，资料30min，判断30-35，答题卡+检查核对8min，数量放在填完答题卡后，有多少时间做多少。都是大概值。)<br>一阶段:言语、资料、判断正确率很低，离80%很远。这个阶段我建议就不用想别的了，除了找视频和资料拉通复习一下行测各模块并且做好笔记以外，刷题请着用粉笔app练重刷这三大块+间或做一下整套款。然后日常看人民日报+常识积累，每天15分钟就可以。<br>二阶段:言语、资料、判断正确率基本达到80%。恭喜，一般达到这个水平，一个套卷就基本可以得70分左右了。这个阶段视频只是补充，需要每天大量刷题来强化，让自己的分数从险险上70到稳稳上70。(粉笔模考+自己套卷建议比较能够判断水平)<br>三阶段:捡起数量和常识，继续刷题强化三大块。在70分甚至75以上，如果抓不到数量和常识，你会发现分已经很难提升了。三大块的学习也会在这个时候遇到瓶颈。这个阶段，三大块依然是不能放的，一是三天不练手生，二是不仅资料比较容易提升到90-100，言语和判断也有提升空间。但是可以考虑少做点三大块，多学习一下数量关系，做一做常识积累。数量开始提升得比较慢，不着急，每天30+数量坚持不到一月就可以看出来成效，常识积累我其实从一开始复习就开始积累了(算一阶段就做了准备的)，很简单，每天粉笔刷一组常识专项，每次模考都做一个常识错题积累，每天听一个粉笔常识音频。我以前常识全靠乱蒙，后来常识也是乱蒙居多，但是正确率就很稳定了，大概60-70%是正常正确率。(常识比较玄学，数量关系的提升会比较看得见。)<br>我这样规划着的走，最后考前的模考就发挥稳定，也有了比较满意的分数。</p><hr><p>二、国考要考多少分才能进入面试？整体如何规划？<br>国考一般职位在130分（副省级行测要过线60分、地市级一般55分）就可以进入面试，而要做到考130分，那么暂定一个目标就是行测要考70分，申论要考70分。行测通过备考学习训练，一般人情况下考65分是没有太大问题，申论的话70分也是挺好争取的。具体，行测的常识20个题目要做对13道，言语理解40个题要做对32个，数量关系15个题要做对7个题目，蒙剩下8个题（俗称做7蒙8），逻辑判断40个题目做对32个题目，资料分析20个题目争取全部都对。申论，前面4个题目争取拿到80%的分数即48分，后面大作文一般争取在二类文即20-25分。把这样的目标定好之后，接下来就是分模块进行各个突破。<br>如果将学习分为四个阶段：<br>第一个阶段就是掌握基础的知识，对每个知识点和考前进行全面覆盖的复习，掌握每种题型的解题技巧。这个阶段就是对公务员考试的基础常考的题型进行全面的复习和掌握，为后期提高做题速度夯实基础。很多人都说要提高做题速度，但是如何提高做题速度，很多人说要大量做题。但是，我想说，大量做题是无效的，大量做题的前提是你打下了很好的基础，大量做题才有意义，如果你只是为了做题而做题，那么做再多的题目也是没有作用的。而如果把基础打扎实的，看到题目能立马辨识出是哪种类型的题目，这种类型的题目该用什么方法和技巧能立刻自动反应，你在刷题的时候能带动训练和应用做题技巧和方法，以及基础知识点的回顾，这个时候做题才成体现出意义和价值，如此反复训练，上了考场自然能够秒杀，自然能够提高做题速度，而正确率又不会因为你的速度受到影响。把做题能力变成一种本能的反应，在考场上这才是真正意义上的凭借“感觉”做题。<br>第二个阶段，进行模块练习，这是对第一个阶段的查缺补漏，同时也是对自身有个客观了解的阶段，更加清楚了解自己的长短处，之所以要了解自己的长短处，是因为：第一，对于自己优势的模块要牢牢把握不能丢分数，另外还要加强这个模块的练习，压缩时间给短处的模块。第二，对于自己真心不会的题型能够在考场上面马上识别出来，然后一看到这种题型，直接跳过。很多人都在经验贴中提出要放弃，但是并没有人告诉你们要如何放弃，必须经历这个过程，你才知道怎样放弃，如果你没有掌握这个技能，往往在考场上你花了一分钟才发现这是你不会的题目，那么这个时候你再放弃已然没有任何的意义。第三，对整个考试才会有一个整体的格局感，那些真正裸考的人是不可能做到有格局感的，而裸考真正能上岸的一万个里面很难找到一个，格局感让你能对整个考试有个全局的掌控，如果考场上突然哪个模块出题非常难了，你可以进行全局的调整，就像我考这次，言语理解阅读量增加了（从2017年起国考增加了篇章阅读），那些没有格局感的人做了一个小时的言语理解，那么整个做题的计划就完全乱了。那些说裸考上岸的，请万万不要相信他们的谎言，他们不过是为了证明自己很厉害，装作没有努力，靠天资聪颖就考上了，其实都是谎言！<br>第三个阶段，开始整套题的进行训练。各个模块研究透了之后就是将这些模块组合起来，找到整体的感觉以及各个模块的做题顺序。对近5年的真题反复做5遍以上。每次做题的方法和顺序都可以有所调整，不断尝试，直到找到最适合自己的方法和技巧。这个阶段你会明显感觉到自己有质的飞跃，而前提是前面两个阶段都打好基础了。对套题进行训练的时候，要开始严格把控时间，提高做题速度，这个阶段求速度才显得有意义，也才有现实的可能性。刚开始可能速度提起来有点困难，自己会有几天不太适应，但是习惯了就好了。这个阶段自己会有一些窃喜。<br>第四个阶段，做全真的模拟训练。这个阶段是根据市面上的一些模拟试卷，进行找做题的感觉，因为真题做过几次之后会很有熟悉感，所以在考前2周可以做一些模拟题，第一，这为了上考场的时候不会因为一看题目好陌生而慌乱阵脚，第二，有些热门的预测具有一定的参考性，尤其是常识的预测和申论热点的预测，有时候是可以贴近的，特别是大作文，通过预测卷去着重背诵一些热点话题的素材是很有必要的。<br>具体的每个阶段的学习任务和时间的安排因人而异，在此，我以今天写此文的时间来做一个简单的规划，供大家参考和借鉴。第一个阶段，8月初到9月中旬，为期40天；第二个阶段，9月中旬到10月中旬，为期30天；第三个阶段，10月中旬到11月中旬，为期30天；第四个阶段，11月中旬到考试（预测11月25号，2018年是12月10日考试），为期15天。各个阶段的任务安排大家可以根据自己的情况来设定，但是大部分该复习的知识点我想还是必须要复习的。如果大家希望我在这方面多提供一些建议的话，那么可以在告诉我，点点赞同，或者在评论区里表达下需求，如果确实很多人都需要的话，那么我后期抽空对这方面的进行全面的扩充。</p><p>一、复习阶段<br>笔试根据复习内容和复习进度可分为以下几个部分：模块复习阶段、刷题练习阶段、反复巩固阶段、总结提升阶段。<br>行测可分为常识、言语、数量、逻辑、资料等模块，申论可分为单层次题目、多层次题目、多层次格式题目、大作文等模块。我们复习的方法主要是观看模块视频、练习真题、总结错题等方法，我们所谓的复习阶段就是指针对上述模块，侧重于某一种复习方法的一个阶段。特别注意，第一节仅将宏观复习思路，行测与申论的具体复习方法见第二节、第三节。复习阶段具体操作方法如下：<br>模块复习阶段：根据模拟的二至三套真题，找到自己的薄弱模块，查找专门的教学视频，进行有针对性的学习，夯实基础知识。与此同时，穿插做套题真题。对于行测，可以一周做一套真题，剩余的时间全部用来看模块教学视频。对于申论，可以一周做两道小题，剩余时间看模块教学视频。所以，模块复习阶段并不是只看模块视频，而是绝大多数时间看模块视频，同时辅以模拟练习。<br>刷题练习阶段：在夯实基础之后，我们需要练习来巩固基础知识。对于行测，刷题的原则是多而深，即尽量做更多的真题，同时将每一道题背后所蕴含的知识点挖掘清楚，目标是熟悉基础知识在所有变化下的使用技巧；对于申论，刷题的原则是少而精，即不必追求过多的题目，做一道就要将材料中所有句子的层次琢磨透彻，题目要求把握清楚，目标是在未来遇到相同或者类似的题目时，能够分析全面。当然，这个阶段绝大多数时间以真题练习为主，在遇到个别记不清楚的基础知识，翻看基础视频。<br>反复巩固阶段：这个阶段实际上是二刷甚至三刷基础视频。在一定量的基础训练之后，往往对于自己的实力有了清楚的判断，能够知道较为薄弱的环节，这时需要有针对性的再看一遍视频，查缺补漏。特别注意，这遍视频切不可跳看，要一点点细细琢磨，一方面，是为了学习薄弱的环节；另一方面，是为了查看是否有遗漏的知识要点。你会发现，每看一遍视频，都会有崭新的收获。这里我分享一个小故事，有的同学看我出品录制的视频时有一个疑问“夕川师傅，为何你的视频2倍速度播放时，声音与画面不同步？”我在遇到这个问题时，头脑里出现了黑人问号图片，我要求的是大家一个视频看两遍，不是两倍速度看一遍！<br>总结提升阶段：这是复习的最后一个阶段，经过了前面的复习，大伙有了一定的基础，也记了各种各样的笔记。在此，你需要抛开以往的笔记，采用回忆的方式，将所有模块的知识点从头到尾认真串联，形成做题的思维逻辑导图，将老师的思路幻化为自己的做题步骤。同时，可以翻开以往做过的卷子，用新的思维逻辑再做一次。经历了这一步，大家的复习才是完整的。<br>夕川也是用上面的四个阶段复习的，现在原原本本的教给大家。下面解决另一个问题，每个步骤用多长时间！<br>二、时间安排<br>有的小伙伴总会问：“我还有四个月考试，现在学是不是太早了？”我真的想和这样的小伙伴说，四个月已经有些不够了，还是早点复习吧。当然，可能有的小伙伴在剩余两个月或者一个月时才看到这篇文章。所以，我下面将分别说一下长期复习与短期复习两种情况下，如何安排四个阶段的复习时间。<br>如果时间大于4个月（大于120天），可完整的按照四个阶段来复习。第一阶段时间为40天，第二阶段时间为60天，第三阶段时间为10天，第四阶段为10天。如果时间更长，则可以将第一阶段延长至50天，第三阶段延长至20天，第四阶段延长至15天，剩余全部时间放在第二阶段的复习中。<br>如果时间为3个月左右（60天至120天），则可按照3:5:1:1的时间来分割。例如100天，则第一阶段为30天，第二阶段为50天，第三阶段为10天，第四阶段为10天。<br>如果时间少于两个月（小于60天），则只能完成第一阶段、第二阶段和第四阶段，时间比例为3:6:1。例如有60天，则第一阶段为18天，第二阶段为36天，第三阶段为6天。<br>小伙伴们能够对照自己的时间按照上面的比例合理安排复习。<br>四、复习资料<br>大家可以准备三类材料，包括各个模块的视频讲解、考试真题、机构参考答案。<br>各模块的推荐视频在第二节及第三节中会详细给出。这里我说一下选择基础知识讲解资料的基本原则。原则一，视频必须应试。咱们要面对的是考试，不是去研究行测或者申论，因此资料必须简短精炼，直戳考试要点。所以咱们不要选择某图某公某笔的教材，这种教材的确有一些知识点是有用的，但是有过多冗杂的信息，往往看过一遍之后无法提取有用的信息，只会白白浪费时间。原则二，关注老师信息。现在有太多的机构，选择一些假老师讲课，假的是这些老师自己都没有参加过公务员考试，没有上岸，仅仅是学过一段时间公考，就给大伙讲课。这些老师讲解的出发点是让人信服，有理有据，他们的思维是从分析答案出发。但是同学们考试是不知道正确答案的，一定要从题干出发。所以，假老师是逆向思路，同学考试是正向思路，出发点存在着巨大的差别，其结果就是所学的知识无法应用于考试之中。原则三，务必试听。大家学任何课程都要有自己的判断，切勿盲目学习。可以试听公开课或者小班课，如果觉得好，那我们就要反复多遍学习！<br>对于考试真题，我建议购买某公、某图的纸质版真题套卷，关键点是“纸质”、“真题”、“套卷”。大家切勿在某笔APP上面刷专项，首先是因为电子版与纸质版差距过大，做题习惯也完全不相同，练久了会影响考试感觉。其次是因为专项模块往往汇集了不同省份的真题，每个省的卷子题目思路、难度、时间、长短皆不相同，将这些乱七八糟的题目凑到一起没有意义，且考试是各个模块的有机统一，模块无法模拟整套卷子之间思路的转换和时间的控制，还有试想一下以后抓套卷偶尔遇到刷过的题目，是一件多么恶心的事情。<br>最后，大伙要多准备几个机构的答案。主要包含某公、某图的纸质答案和某笔的电子版答案。对于行测，是查看不同机构的解释；对于申论，是查看不同机构答案查找要点的不同，查缺补漏。<br>五、行测与申论的平衡<br>复习公务员考试，行测与申论必须齐头并进。失行测者失公考，得申论者得公考。不管你认同不认同，行测是公考的基础，但是行测无法让你与对手甩开差距。而申论则不同，所有上岸的考生大多都是申论分高。这不是因为申论难学，而是很多人忽视申论。你付出3个月时间冲击行测，未必能提高5分，但是申论却能提高15分。所以，多宠幸一下申论吧。<br>综合申论与行测，所有模块的学习效果和性价比如下：申论小题＞行测逻辑＞行测资料＞申论大作文总分论点＞行测言语＞行测数量＞行测常识。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>和小宇要说的话</title>
      <link href="2019/08/31/%E5%92%8C%E5%B0%8F%E5%AE%87%E8%A6%81%E8%AF%B4%E7%9A%84%E8%AF%9D/"/>
      <url>2019/08/31/%E5%92%8C%E5%B0%8F%E5%AE%87%E8%A6%81%E8%AF%B4%E7%9A%84%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="f5a7f49e600bd2a0d5dabcd8b156803ccb30509c5312017a151f6731a213f40a">2fb0dc6f5af78a4498e34920f51c908f532de7c66add8c279d55f06254e5375afec81c15f19edf150f3022d5088ca6cd91b51e9c087ac64ed06d50dacbd713e58d02385ecf493c3781e5000122d962cc5c55690387fae0f2781a0f1bd4fca1647e1bcdddbfc9e9feac14673a73166b294eff51db9747c943eaed3f37bf8f1840bacf34d7c35df8a8729b7bc26483dcc9036791218e014fbfadf70060c40682ed225326ed9920e1adf6bef99ded9e1af457d67ee2f18c4a8535ac8b1e79aef62f72cfbc03b0481d5366ad9718d88f5b137136625ddbfcb70025d58a1110b80995256cef02e48277f7ac4c71173e0d5eb6537a608187475d60eb2147946774f2de4f653928d827af64b9a81e0720199344fed5620c54d26239b7220835ffeb3eaa5e86cdca04bd403fed0197c66978aeea5d4b798984cdeca1141da4b31a4d6f7251af3175316c1c8a991a6e5388319629dd00540f405c36217a6ce9aef8b94d8c850fb9b266bd1cf96f34f3b5ac3a50803e04269294fc79a83e26ec1ca76830e38be0e88fd3b7549153283b502cdead271cce806b55380e3f2a5b56bd845ee0c2f6c06526bc196677b21a6cf310c9848b227dd02b32e2c3e386d88ba67f9919ee51c8e97c8d3c04c37cebdd12d6c14e91a1162f8339d827764e454810d57e207076d5a29e1ffb995627c2b723a07b443698c7fed4f53bf78fa06670121f436423cfb5ff0c5820c0e6a65061b45da75549da99bfbbfb9f081b61455bc3fc2d4890d5da9d2900f15161d0f604f0161826907ffe46a60c37621a192d8b999988ca1869f1fec8695c6fc69cb65732a26304a2307274315c3830a2e5dd9f194fe48ff582af70c1a8122468247d918e599a198ea8bbc58c7c00288eb1d82cbbef77e87f53cc0af91d4c0a478fa09116d21065803426dfab2ffd10e1fd5b2dce233e465bb6a0600b5e81abf9e01057ea21955f08a15ab78d2015f106f77831eb856426d4acb285f08cb156e7829706903d08225e8df1ed1591b3ad0f3769f088cbf08454536b510cb4144f3f52531e145f0fafed542e0bce92f115b8c993190f496c582076471b2283be44640b944afca61325c58fb1d9d0aeda3917e7dc67d299b68c864dcb94b31e94c8541a43d3d66b1b6c20a898048e5e55fb139ae7664e9c4ab56115bf0d7237c9e256cfe4e0c1188421b73156e2d909d0daebd79a50819ef4552d24b6673678f427d80670ce36ace10b57dea260fd750a434afc0f5d467e61278e530ce93f33b2132304a7aab4daea8c2dc1237a773ace7855a78f0479fd5ca4b112397ca81a529c6a04aea51a2dff16576df3f86e66eb0cf18cf2d3402aa338da5b3a1b1734d81c54e0dfb92bb1531e6b7b84ef40c1b996f1faf97b016c8f02f2072a88e6ed073d99bb83084530a952a382a8f0fd624887a34797821c9714c76ab8bc024832436570908c628f6ae50abd4c5145e104bce5e18c2b27c6348addaf00f370601bd4c6e79ded7eb2fa8b3bd1d7cfd05a8f501caf36b114e6976dea5497c4136e1ffcde7847a8191b19033f4450d560fbd2530970e922effb197886a7ddc4a9cab438ae156dfa7078438ca37afe8335afd3676deecbc94f7173fc0ca7e3ec736fa9dfefa5bb05571a5c9d987b6b63dce33754c9f828bca65af55b0cd397164901a3992d542b40d61ba894203b6503936db2cf7b5b215e91bda3ed2b18c46748eadc28024a9c01abf0342d6fa82238e7d8824370aa65bd504418166382cb180e7814cb1788f2584e9ec826cddb7eb04f555419421cc01554b4eddf5bf57e67a1b0228715db2def8ee9b17ad245dbfefdc3e6eeca9d91ddf2b81876d4c9cb9a11ec1eafd33ce74fecfd16d547c01d132b3bb0350bec15ef66f203950c5e541de3c4ccbfc16f9c0419568af3f0c771d86b393f0e414a96da586316ff8d6b1020eb1e1b0aeba5dc185c71e8ddad713cec14dd1a1ed651a4ce2c1a7c4f0e91410b0f478c88456c8a4de875dadad10b315b7ed960ff7f8c8f1f2c90e21ee8ed5868a2d72ba7f6b49a407e7486370878f44729e597c338f509708f2b760b89a2944d3a0c5440e333da7132af3da489f19805c48a3f376542c43c45dcb29a668296d22cf9296eb1d25b811a9d328d115a0b10701398af0227cc801cc667c1b8c1762afdbfa04352904578908a9376894303126c5421e5dd6e67e9cf757c43ea3d546a1b5642e9874f550299c32c04ca89062f65c3c7f6951edba1f804087eea6c38f3c60e118d6dfebf53064a07296b226848f01f678ade4b5048751d72929b0ca53f89dc58bef4685811bbbe0136d198008ea65f55c2f013b469d753da792ae00f96779224865c3a59c9132b60b2033973e511e95cd2efe5185ca7c19b6b9570687878803870376ab7c09d04ba017b7f0af9c6eeb75936f443f63d94f91632727bc58223eefe85e4237155b878239447bd7bf1ba43e19f781792dbd42e99e02d60ea0586dfcc71467cadc820f96ac1cfa0d01efdac144fd29e56200a6cb390930bd2fbdd7a0b5f997dae7a7eecc65f6efee7aa7788818bf3b37f96b29a0559a7db9a9d1d36a96223e0ef88a4db70e0817f419bf38e3679c52fa02c071b4ae3339db7e1d4ab867cf3cc366da41e9132d1cd8cba7576f29b57d890ad1375c5cc4bbede5ca440a2b5ac67aa0f31cc55554d101f74bd24df881212209e931dda02cc59850d03a881006c3526ef0427167390ba9aa2640d308a3e7e37c8b4ec0e67c9220c9c56467e5c891bd1c19655a57702af2684b88fecc93c9df2ba9e771fba29f8412ec4f087e76b77d99f1954acb97eb07ebd1336bd85c4b53b4c5b7104be975823659b986225c11b9b9f869ff6e2b911e30b81b2ead9410568a99eacf79d27c78757c2ba184b52b013a800eab4c24e33599867ee13465e31b7cff3ff2e203165b053e163e5f070664c05fa68708330f1a25aafed803606ebed8ebbdc631b77cd255f7045d3bd0b171f0e52882182303a72b796172d1f48a24e929d07edee4cb7bb100a1039951e9daf0c4dade0dcad37a302d0acc10bf7b611f8ebb1b213bfeeb58e704740fd3494adceda5a1c5eed1b158f184ca02fcc63c19e2a43c876fcbe9dba8ad96c34fcd788e9dfc46804aa44953c086d5186846c886ab57c6b59e479167d508576bcc90533fd1acade2f3ee38316fba1a2213bbc27eb1e9e70947a01a0591014a2b930f406134651e15c68f31b3af051d284292e54af18f41b630e5ecef9655d57ec2b92a6c13f50d3f0eee9458c22e40be9ebacf8b33474bb2086cbccabc38c3f01f222015b90e606e3a369b23e7cd92e38ef3ffd1a2220d71691c101e0a5ebffa8d32f0a39f7b6f3e79d0ad0bea7ae3ddb76dd4a2314b1a06fc42bd48e8f7158b16ef79e53fe51b9365ba4bf227099b06e20e68827ed277c0f6a1e21d3f0a18bc71bf3aae2925cf4bec4804d7772552a7796a3a71ffdbeb081d40446e58f0d077085ca9124e92f7d5518eef393e318f20a985f1277e7569601ac65cdf14985ab88c518e1b8cc8baa55a6f0870216837f85691b4c82307907f4952ff494ed343f412fe2c9f24f3fd71e82c84bf248b4fd0b7dcfe104c19282d5995e543d3a05764fe233c72b124f5539be42a29d6c8e5cca051e80c1bd8e1515e68946bf63aca1f1d801595a235792edcc0313f6d6fa916b0ed34947413983aae36f92d139af55395d7ff6414f142b7363a155ac1ccb4e4543edff9758e4189caa3449ad98a16d3f6b6ed05a9a7c52f89d312f09e71911cdc2c323ee05881532bb89e9627b058ffb6b87a8c68c308b9792ae9d06639cd18a614db40ccf4f6c8d7b26ac05c3f58f9c1c38f0157deb96315d4a7b480d40de771596743bdc7ce9982489f818a2e49c4c3e04eee8987bf42b93415101094712c7a6b1076592f4e04f50fd36ee091c728a3a2dd266def55786205a5dc57ac6508cadea3124651230407801f4256d363039930c9d65acd9aaefd6aaa022eeefabe7144486433ee7fdfd234154f5da96a9d97b902e99050e5abf9453a86b9b39185b05743d2ec8f400aa96d58b28c38cd75cf14bb785738cb3ad9e93363e209e53b309748e5689f80553378256f733219c17749af5cd03636d04dcd8d37910995585aecd795e731f2b4c6c8a9a956c873a9c447e13147a5c2ceafe0218d2bfe08517ad73e7fcc0f607b3d651c4ab0344acc38d37062ea79705a261e071a029b3330f91d208f57db4c67b3ccdef1a0f40ec45a82fbdfd737fc32493aff557a346ccf4aa3f37b10aeaf85a354766de4749cfb9a50d1c25d0e82c629e0b0c6b01a04040f41d1eeb187df9652279b23518629019ea0c41e151d31e0e604bbc058f324a76cbd0c168388570711f9bb8a912e34ad019bbd4d48cb420d10a643a06ac70369f7a0c99ac7fb9afe20d39e1c2e537813c0273bec16fcab4ec885877eb90402259a997566a37d2cf0483f1aacc20c3087e7a36f5bd50704d14b6f1207fcad9b86292575f913fc6411864e998ccfca9288267c6da769e2e09f51b8562ec493f80de2dd324bb12dae44b2f9f76646c2bde3b7321d7a17cc7aeed31b922a884c0c7612aa29e5d631dbd1b7f44545f2926f90e532d276cac3f90cf3c8ea2990e8b675018818db6a0a112385eb2d84a0a929a01f9e95b87f8b4bc7c5e88f1d76d7c776c4f1047c3b61ed3fc7f600b00ef786ee8520065e29b3fde10615454af2f24d6c3e599f858468b1022788f3b839d477366d94db08fbf5e86aea07947b502da5d1d50856fae4eaac6bb45ce3b11c3a4c2663ec21be07aa8d000949e43275cebcd261884637064f74a099ee5a8fe9e2013f6d5bf21d53e8cd7a82c5681348e5adeb860d008bc90ab00ec0506c1833cf5c2f477598c55647d5238718dbd0497d8c721195e04e70dac21888bfaa74cb047bae5f58878ae64a581940692db69a09b4b58f7e95a0ce613ca96a39bb6773c1e3e93b1482d9ca190d69a40a6a61560b40a86c4ae4ca213c997222af186c43606e32ff51e15e9a9bfecdc68a911987e8bbd97c157ab4844ad2a5662019ced84a8cd41cc18dfd8e53bd349409346941e212f5a7c7c823ecaac52b5ea5234251b231706d3baf7565000bc6865c8187f8e3adb7b7068990d8e1faa1561c661c01a58f9d4f6ed6b7f9abd67431d3e76373145d1ee34bcb7445565c6a257eefdf1e68efc74d4e499e52ecb94610eb5e605cb7736a33bd877a5603d8d436666c412ac6606773dee04f67b15e424e99e8505125c22f8191e29dc7223769affcf5be1c399472667b7a1583d63ca229f6034368dc33f57abc30333c05b61893caeedfda46f7f7a98683cae04e7cf3b30c2172824bc81bbc0226c5db5348cba44a2523a549376a091ce6c93a67fbf7aa3efc1dad65bcc20bdad9343215f58cb13ac621e36b679f4fbbe301bb14b441eb4adebb6f3150acbbdcbc9e9d86eda97d384a6e7eae4e94166563ea93525d27d62b2316b43f6dd68b2dc970cf59ecf084c079b9e19656d412989c5ce701c7e96865f8d6512ecb9bd0f8e48d18738d33d34613ba666045a3aaf96628a3f6fc1751dad13a3d32bc5bec55d89e19e5db56e0cda72ea7e50f3c572e6c1f186850f899d6e10ff14325e07b06dbe3c87c6675f3ed081f87bad2c037c035746e9678bb8dd2a95798f79ac4ef009535632afb1dc174ebdf114b74e8e83f97affbcab66ec0ec59116b86584d37db0138f1c93d9045b23b05b8ae6ea0666852e91f39d0b828587c668ce919535b44f03513b3354f36309a6de0bc064de0501c1e563c4b8dbb37b9d799d309ec310913fd4cbcecfbcb75aa993f675e12aa0c8181a3e182d1a2f85426a7760425aabc697b2e56a10e025f06c17a6c2467d5b76284a5ab0c42bfa149d84c8f514ec185735b6c698847ebaab5c7cd2240c1a05e31221e9e8ad8e96bd5e38eef19ad60adfebcaca9734cd3e9ad4a4446e05232e81403269d2e4d47f00c4989f36b9b2990b59051aa7a459b63caeaa73f7039fef420094df06d91b0e7f943049164144527936d1dd56b848c350a139c28595d9f6786b5956927ef7b6f4493557f752c5b38f9f32913ea91c7c2c486dbabce7c78d66d80179be228591602de48dd206eaece16ba7bf9698ed031f52d33827f5cc5a9fe1f80134263ade172e4fcd376f2a3aa3d7633d3fbd363274f9252e5865e3dd59cef2a73dabe8395a4a973dd62cecb770753f2e69dd9a79cbb30e7542ce80f72070a8cc4458bb2cd4a91a5e2fb00edf670ac213a207edc35d2c2014a8c57f35dc08a2551a626d25755f94c3c6642122620bcf0a9574b0b21b1932634d93c186caefebcd61c5f45c7d0d7092250bf824bae5cd644269e2c91739ef0475564e75ed60b31e02f6b3f02a5d604dd228ff659ef7d869218b3e985c8ea365becf8a2ace118aae73568715ff3e0c3584f684cf611b7c757a2531c2e94be850e035a98908b96f3b874d0bcbe760112dcaeb2be94ccf2f0e46be556c8b4257723acb55e886f46a4d5014965f50d425055823295197ea1c6930711620c271bd313eaf3c8a18e7b56e2c8682d68191db23c489c06661a3bb1358ba19fbc92c8fd8c06673da155f76236cf9143aeabe720f4f7b560325b5d9a19c3264990898b1434b530820d0ce7fc5fc51572b9ed3aad61bd5b0544721f497ea4477adcf6def4586ee648d3df3f7111d907a0b42ef7d8fa9b5163b902995da71681dc92429b87d74e4c6e84bf0c7eb2793e1f9f2dcc41a6ac5102788e00894dabcce3c7e1cf74b355c9d0b43960982cde0de6f8a78500773565eb26f075b35ce586b981cfad15667ca5b2bcf94a30daa7850ece8d2d8488c0842073cb6e2b6c85c1fc6b71eecc3699ee67035856c6c76306b80b6d8c1edf0e5589f000341e673213440ff7ab9f91a6fcf324edbc29ee4b8402967c14f7ffe3c000bd71de382e9b01e471987784863ca8d92c3b9fae229ea5736238fa5f005cd0636ef35d5c755a406f3005b957712b660d55f7374c506e08f34ba9d4f872981d18e81ce7b19c8b7b84f13623b320fb60e7e69d967c8d6a1a9f90c6f9281f66b6401883d279935cde4c4134b6b176adf7aff22b2e423ff88f86f192013c43611d08c4e92cb6d7bb479d0bf8094ae12cf6cb684b399bd747cb654521eb7f4e1be86cdc378e108db950229b65c530393c35119f15c6fec35a964774f262210b938032fa177aa88c663833cb792d8ca11409455c445ddffb8aae64fbb5c58f30ab394126405c70f112248bcde6aaef07b848a4ab055f48a23a6f2b9b38878d34cc844022e9eb1220d918b4bfbc4bfad45721b0f2afcc15468fc8f9ee08159790e8c01ccc74ce38d9527cb50e7edd1d178719dd926118cd5a757eac6039c9d71f9b94018ee1e64896cce7d9f025b925b73b88338b3e2dd386aef7ae0342403daa913aa8aa9ffd3e5c3eddfca6f3d75a329bb164226aed5fbce78a8b11ca3d46e5a4c1f5724e4d37e661dbb1d85c1f28fcc58637110a74f39250bb03455b3b604a7d1e6f79672207cd64f66d61d5c0de33c5f8abb7861029f0b89d304f464900138a231b9e3e7e1e8efad2e6fe0fa8830c89b0f330780b032277b6a65746c43e3d7b54f81cd76abcb70f7ed363d228309ecf50009514579e0de010523cc120842a56fe3d0aa27523c8cdf0de86fb5bd76fc1bf084b9d8320aebb059a8509661551b2986f1a45e889ad7e7ce8c89ffe58051a0172724160383c60ccefe10ca1df7a43507500d36d5935d877dff550a450725276fd9591b19f075ef496876a2e86630a1971c4afe6ed95ac3960995e45110d4ed052ab3b9e56b892ec650def6579eeb67fcc827fb4bf983d486085a34c37ff8e8053d87ee05d15cf69d455340c7584f1e66f298acdf6fe41fe9cebc5184016797eaf48b717081bb93bbf040681aeebc4d9dada4195b3846cb3508145c829ff82847e8c455660cb9fc4273d6485ad511b1b384b3555c328f2707f49c0f2ad1abc33c32259d48c3dd2230fdde5281ea59ae03b43a3b67385b6ff852b85632d12e9fee98398540a105c61eecf5d3dc9d65ddca768f7e3a2161b870fb61fa5a8f9cffb700309c40d12dee2b524fbefa57f1c42555a7610085c0e7f572e2d5e66c77cf0a2ea140be5185571465ed56b589926585cf87222cf086f5f654db35f6e67dcf81f2be9ea0bf76d31534357eb91f174eb37d07c72782c3f878ca07293ee5c7087728b959740c81c7701697d37de4ac84743cc7e3bf6f1299b633d8e5f7150964c830f5b38a456d83518e0f4dd3b5fa3d21ed3c2a5f76cfc5ff275f1b62754c093b4b7749b8243384f3ed059aac14d4bca28d2bf820fafc40c087f17f0cb6fb3e165a343e01fce36b75dc321795e64c784980a49b56f65f4c5ef1cc8ca8d33ceed5605566fb36d075723ef274fd551e5b011a7e8484154fa60765b97f3289f6886c49d3b2e5b0fd2b12e077d0dfe915b02b1cc4764d241bd241a626ea05a409a20dc071b7a3b1d22fa96eb55c30b610ff61a2eb2b239567c8ff03311cd4185d3868fce4efe50482f105318760e0d8950ce8b08d8f2fe385e8db1093508e4f26779fb8dee84cac05f76b993c13c2ea2801fad46a5d91691b2ce6765be2bffe0a924e57c5bb766a37da272b61ac530b5bd1a90200ed8c73d389b9ef7cc42671ba1e209e2732ada474105cdc2227a7b74c60f422bbf17e98072337477ff2fa65ad92127221bdf11449ad8bcc606a8ef52b18b56e0279f9e61aec6f78ff0f07812460733b5292ab1ad275b46c27dab8267a8c0f14428d394d6fb6269f7a9db609e3633dcf1cc0e372f069fd1def3b167a1b53d6e9c2cadacd899152de38827e3de971ffff7dfb7ce62cbd61bc285bbb7cefb852b06b5cc40e90a7c183f0a0b6a72e85bd95b9303172428e0df263bbff5d7e611eda347a52c7ae22a040def3fc2f72bcedbdd2f4774f10647316d23c594bf568ac0f267abd59b8fb358d49ea28c7584ee77c1e3b87dab34d80c16f3c6c3a9e949036d74c2d206436d77b258c1ed1e8804438295e3dbf7889c4d1142a84052d53580c132c5cb2ea9c6c32a4a528cbe18d05485fded124ea656574c841d3e256a5332840e8ec06570b52d5d1eceadb22050f89a8dc3685b6c79cb1bb5667f941726ddc3acf0e77d2d5166a6da9c6811f0cb6fc0a57d9032d2febe18d613d9f672900fae68bdc4763baca4c494f354e01352b5cbe448505b1c8e1f761231a261d9d22072fffb050fc4e3ee247a544e49c578c0626552e408cc1226d185bafd3ece90bffdb6089f3b149828f792ade7b4febc840cefae6caf8dd06e31fd306ae9dc8f383109c1062471f6269441908cdf275b3039257c12e02730da6a8466c1d2a224780a98803bad6e6f8fab52a1783d7839e862c1367a02fe5882bada4811bb039a96f651132bfa2373c58144b2d17c98ffcdf9e545bed3d0af5b1f99e2b018f39a6a8ed6710cf3f4a2469d71c66f0fd4fd58d8c3f2ce36e70ea72bbf588343f8e690fff6d38a0508cd8094b88e707aa6873eabb7d9ec68d027cf042d80eef5300e72ea216ae6dd88c9fe57f9957fb0120cc359cf13314cdb0ee54140f0822f5704812579092ae3b4a91930a46a6055f452c55aa7882b7c148a514c3bc4ac7c2776f44bf847adc9de740b8ce0dfb20c26d8c475906fc807eca4dc8adf5435d56461ac65a2c26c114213711ddda0fe365a137183da818d204a180cee4b931c525165b3890de200e1c347eb8f4380a743e3061fad02dc3c896e552c6df40aea3135b94b3ebc385ef4f69027cd6ed8473500d7fd88baf2de9118a577737335246f298ebcc31172748ba630a575a3b6c9d7ff185b16aeb8563d1ebee0811c33e6adfbe0ed58f7eb4f6de96fe063658fccc3ad9e6871a817a603efb7d4df276ff2403da0c701714f26b2f7481cba6835f17ac2d358a60b501aa0b474d5035cf08e70302e4d61db838da988794a832a1b585fd0d523f73b9fcda8a3037dddeae734252eaa51307f25dc49088238380d278b1795d955fa46c3aae88ec10f706b7ea3ba5acbecebefb45d84bb51e070b5ea81feee3a2aeba24c88b2fa9e09e96fd2fd288ed57bd46ea5b51dd0d7f65a5f5b9f279cb2697ef9cf070df7fd1aacb7b414d7d86d1eed0634f7c502e2a6f8563441bbdf54643b2355abc2fd0ae23f93ce7673a563769f42705652d2d3fbac30f84633f762e252a654cd87b4cdba19984a4cb24d982ded9f5781a6c51bb76f9e40f981d3cbcb85ad293060dbbf1da540edcb022201e6ff63ba3b35ad85173ed82f6494c1b34d460884b3d17b65ae5c3f617f56a5aba79740ec286a6d66830064113018d00f919b94d87fc5ffbc69f634214fa4c23639e812cfc91b18648bc6a6089ce6ee0b19aa63da57ecad1390e07d57317b0b8d0f982862a3e86dca27627f540c15957d8ff41775004cb46b58b9df5c3e5165d0b575cd6ce3b2a46dfd3ba39def775465817ec679bb5076c13ab3ef7b8fc926de9e378fa74114cb16b3a7823b291cc90e1d6dc8e2ddd2c7ee111a8790fda73c65c4148fbf06a05a95d4e88e70c34865333447cd9440e5b924342b6ac22f50cb544444366a4e914e573147f197abe444eb56fcdd9d7509d5bf5c226aff0653f63c410e7cb8a3d29de38f7326a65f3774c06fccce25b6473cf6e89dab8bbbe19b955a9ad28019df311ff396cfedcb8ca6a6e9ec441c8506f53989cea31d81c1f2fd4a377e48e8f39c541e4ac2bb168d8ebf175a04d70e3ec54ac438d805c0c7998f9c89334aead9a36353c37a7f6d73388152b4b2726fc264c8a576203882f7fa27c3b1ce5408c2b654e95d389cd0af05e6ba801e88f6aa9a467f639915ac96b1d6022c02f06b7bbabafd851694053ca273c105a50f58773c755d5af6028384044189723fac5748ba9e410dfd9b71438eebe65264ff80d23d4da27d10cd9a845ac5b853b49d29740b2a43b4f121020e06e1e331d7bfe2df612428fb540410825b8cb0f760ac857353ee763463c7f6036e99db9fbe26d1ad52b2d2ec9ad1d87213141e435446dcf1143ad7420e16f4f7c739dd83a8f9a4d144d94a95fa7db98bd1657a734ea721b68decbdc2d706e81fd22cf4ba30829883dbdb21e22da227f79c32577eb8bd5cab89a5ac0c2ce2a53df67e001cbaae4feadc5591cd0f8d4dfacfa15c58af3e69d62481a36a0cf1480aa2abd8d483ffacd67b44ee8d51f0ed924bd70f137347579de96e4c943cab4571c7c770da91b0dec8a4345aa52883f46c693839d0502f0d7a5304d134729935dd26b390cc4928280b317c0b5cd5f5ba8af33aab6996cd7b226382ec5f0626f5203e97a170592fb3f5ffe9413f657d002dad0d564bb5d7f63e4d73c6fa45fa5ab5a208df767085e8675208fd458b061bfd1456c172179c940210c7d6b254a46572fe97a5704d5f9e909e2cf0724e70f7b1c79cd65cbe28da509f1ff79342c061f71763f8a6b0ec92a2a92defe0a475cefa200511b2e03cfac3751020a3fa75fa17c9bf5031009e699c12d8fa11d92082df7492aae1107586cf6264141576d99011f82111d16db149633ffda853bafb47b9e1fd0505fb55b41ac61bb0ab0cfbc15d8018f7969a3312fa5ddddd4a551806186da9bd63c093aba225ec2e4d4643245e385315886024def5ef3fb3b79d09a249809cb15d4efef11d8fd6a57cb9dfa5acee47891e8aafeeeba1025fc940da1cbdde219d69658c5393d8bc455d2003e1f78b34623dfd6d2086ab6ea0377b11959e66c43366b548ea496800dbedfd49c97eef25cb28d9d9f37b1624bfc4d599d2929dec6bc4e1b279d00c0cd1c0855564acb0d4b10e07ed4d0aa979bcac47a9415df2ea91f7d3796a9e761611b0b8b38c065c474aef734152a0ab8a81af157c1a22320b6f081c9b5ef068121d1e6781e8af06489055c1db10515014aee4d7f730f45d182ab689167c1875ce734e9b5a4fb0e17a9834aebb632e7c4afba60e83c4c7cd28390f9fcd08d719be5b5ff40fba0b8a75a24ce7fa5d87f4f90472f5bd17107c8740d84b1f6023e886cbb30439b4b3b981eb2605176f0b9c6351a87109c113edf569173b0ab872f8503864974be7fa5ff764163f8a0918bd20fa5cded953aa91ff992bdd227d38ef9a171de139b78f369ea45bf4954622e78b13b3beae9efe840f47974a7dc5c66c3cc85f13f52883229f000d9daf92c2d0025808634bbf2b8d6f68ae1ac85aa27908ad9f18146a27b9ad99df0db0d4ea2d860b354b0a32bd49db2abfd30a864668928f41de4364e67732ce2cfb839ead482a0d05fbc6a3649a5a8df32d9181b9bd79842b75ccb04620df9cd6f362c88b043c3ada80d6ca2fdfe672eda3baa5e0910f64b2295a240c59233d0715a1bde6379ec8a49bd0377ac27865b6948fb2026a9ca0bed749991621657b8e0b085537352618f5cd9c2ab3523b4573c98823ef53dbbf3ed971d78a071d397cb1303eb051cf50c9f949895fa58f176187580621db7c34321b078caf3b42669033444ca5b2b41af8860dde920ec029d0a65f024ac20df0080e5a2c9f8244fd3af01bbe05c892718bf6368b312aed0c03b25b096015fd590a324e544438dbbfa846a1cf9610072e82476b9a700a75c2134c260200ae7d43d100821d8a8b3ce58f6d26d7da4df99a4ab6aadc0269a2d0f3c54cb5ccec19f031a646a6959ce4ad2cd9f83362116ae876fcfa10190a7ef10e6ad5189ae6977d3c953ff6805c789901de93e1a04207416dd05281e3f8b9de6f14a3489722c7ed7c6a671836b00d19090598cb44da906ec1357712012c1f91291fc13f595640a9b5401ce0f86f9b4c3b8ea49729077a2882c462bece95e6ac8f8f9896cab1042e328bdb8089989752794699333985fa706b3580b47aa4b6baeee21b46ce264f99cd2d7abc6abc555ae06a94c659d2da403d6aa81734fc8680f280556aa1cfd8d8dd90ffba9112c1da7316882aab276208b19fcefc02feb181824832ea8c1701dfd9f35acf23257da0a03d28cb75fd73b1d9679aaf576320386d11f9944b0eaad5c86900bed9c48b2ca616d99cc2d09b266340c8b08d9358d183fb27cb9360786aa23da8c615ca2f377deaff68dbc04b67be09ed9ffb8e9dbff1450dbf04a5da58f2169363358f2be7331199cd75b8175c9e261ebaf099d1ee66b65e1a8aeb6381f28537c0b3acfbd00306c5bddfda938340cdc6ec376bb3b27f829fd1f7dd0b930d4fd740de709b2ae59c0ebb200f4ff1c6d778f499fd61087a55b628049d0259750993a7e085e09783083f302fda0f4c343c68edbefda3028e519d1af49ee4721c0a1e7cf1c29659ea8505a00b6df61fba4bcb6a73a3565e226ef728e6ffbe00242e2455205f9677b347cae7d211fc43d213273cbc1b0264299ded1394db6bbc169b792a94232d3164a94c9a5436917509de2b94818b228dbfe720b73b4708430cf5881f8f21672df34bc7eef3aba04624063840f830cf0179e6657d9bf2f45a4d26cf650cca5f0614f6fc6a248a22b6672884c3ea9c2c81023ca1c9fc699b7ecdf8ea4e0a937213fbf21af69abd41d2650efa10ebd325fd27135cec6d2274342fd4f5d89ca5d4275cbbd1e1042353304ae0fee336072dd1572eeb45f4043e7f34545271136ab369ee0c30965535997e13c0fef85f48e49a4b993ee49a3eea9a0f0499977b1344609768528ec0f1f237bb3e73b0999a00bea3ee4153722e043f3960cac7d1c8822b93cc698669e6ecff071a6384677f9edbb714785a1d953dad49bca6ba99509c12ba28dc4aa5aa49c0174c648c21457d4547ec0fb83d964913e57e9acd41a1584fcba33fe91483659066ce119f1622cf08c144657c4d8364909cc2aaba6e9572c79c339a7b2ead2b682143b64503ff1721f7b3c490dc1290047b84ce6e27d80614c6dfbc633104cc4d21e17f6b20caa48f9ea1cbddb2cc12c588348f0f70fe9db1216f951a625d413b7cff16c9289f20f83bf28f836a26790e437c6efefbe3946cedd7a9e6914d3d5ca09a82df91fc734916b88b0076839ded54177d5925e548de7aad476466d3d8ab4b024970964a057cdba91446d65a84d7abd2ae90dabea36c68dc4017f8c8e2bbaa1071e217b5b887b61f0191d09127399a014745a20743ff8c91252baedb35e5619bff2c3a4281f3b001d4a7a2c761ae24b6df5f8da00b4fafb894f8b6a54381ecf3f2a4097d718579523a73aa37ab2c4c073d9af622e79c350e62dfd378861b5ce12b5d409d619062f614f2341e7020563b5dd269d7379fcd0cc278459f5a1276b074d95c2a533d67d8e6e7e8d0edecdfd2edf3a637cc6af8f932b18c0f29fa64fc68d6be1759d72ee7acc97fb3abc38c73166597c2ea0a7b34d6531130270ab4799f2a9e9a118845b4476486b4ede0a132ab5bbd6e9269c9867de534cc498e9988277aca9560ad3f12c2ec2f92fbd1b608de476ed9b0e6ccbd922cbc69fa2d40c0a1ed73b1e8f46496ec5a85503e3b5e69f1b9b1f4e44ac5f5db1664a84a3d1179006097d2b15831dd6404ff13218fcbcffa736d4050aeaadd5cf273b847b74bd3710f715b520db17c2e354a67ca6b72dc09953fcd8f6f7ce6e256b5d7912c5c192ec1f90485147a204e38a97e15d6a8a576a02b0b7ef48bb66d2c133de1521803127765f7d4e60a6b0d557cc99b512b52b374380b876ad3fca49789781ede728470b83df2a2415fa62b61b0ab0f2a5d764931716bed87cfe7702b2e99858e666a711bfe77cb55a0337dc646ee707fb4cbb46d9e8934130102f3a088c17e5a00e0e34f3d9e8279d05b1b9f6cb763d45fff7a117e690f59608e222e643963c5effdbae3e807686051266637a985d1f985d81339182d082adac66f2294734028b612e7ffc9d26de5917b8f2600856d056f17bb352ab0d0440a4ababb39843cf6593678ce75dad2f9b564c316dc5e664fd09551bd2c724917cb7268342a5549a585c87ed3e08cdc5ef08d79c86b039cef495bc27972b740e78f58134abaa6daffde53bb6683e295f3d19b7d7de4bd1b1fa4bdac8396b22c208c5f2680cda3bd973d0356a3eab8afed8b123220c1b580508f0a3d64d32c3dc2144a95c0b63138a2b5cc16819b4c92432ea1e7f969ba41447a29cea16f204e608cf38f8567180fb49004b87650b274edd0de04ada2c5ef86625060bf1c7154b77aa70be4dcc131e088d62334aa5702de62f92942a706d7ab706bcb32c81adb8d4a70bb975bea127d128e8582095dc8748fe257b30af5d73918c7b8433d65b48e6bc716ea0e18f559dbdd0e878db949b02bae3b606a659a8eef1aa6fb38df9f8903ee22f843f84a9f4a749fb98bcbd0ed2f82a60797109006ced35b43809d53c902a9b904700f89e7fc6392a14c6f14178694d03448787a9eea87c6bd854f4719b9603867bf03be15c7d873b72ce5e67a12cc0e52f3772c1882e7bfca5aaf29146a8614beb0623194883e31465b8a03d673ccdcde6a9950f7a0bdcf0ae1d61907b8a71dde47ea2961e30be69f78f499a2cbc09feee300952628e758ac1657da003764cdd79787b6e1fe46f1b66c78cb9c8e7cecbde05dc23a7e7210826f27dc916b9fed13c063b3b8f6dbf322d0c255d6162aca450887e7de47d30364111641c5847fb4167ef9fc688fae2dd7ac7ac42e193f4f29dd294f481528a25473911ac6f08f92f1411458385fc5c60ed81e7afaa53603effa9606a32395df16a212f8899e0d9b92a6b82b8b5d6c059c230e53c8ebf20184cba7cbe837b91de34eb04bac3c36d4dae7e172d3cbef12e0474335ac2df1805f97436c1ef7f0a16d22e763be180e9a411f2844a3fdb4fe300e931d577354e1888eaa978262d2005a3772f135100c020a40789ef20b31363f89a1e5fb8165573cd69aa72d67c1ced79f12fd7b04c753108ca0b6c7eb9ef691fb240dff1256affb2ad3afe84b66e7b2b7a7af575946fb62ccefa6f69c641334892dbddcb12540fe6f27543f784d29cb26125ea852932bb64296c76656c61e1cb71fe80119c6ce7aed943dcc2f9a29030a248aac26603036b7bc83bfd1babe59975dd810ac87f41cac2633c92053f07e00935f8314bbc30608514b357952387459ac79527e5c3615e5768922a9716b15f216ec385b45c90a856fdf766a52ee04ca4e21e16f0ceb9727b90916976e22917b92f4420c26ea251700d3d6e270e728970eb5d7211a3aa8b07b0af7daa760b3414811bc09150d796a5cd6d9ab62ac2553ba776723d84e449d5602c8b5b745870ef946feb96672ba4ddbf9e56c05bc23655c2888d13c9cbd4f7d52a8f4bee0ad4cc47dd86600a70aeb563a5a40255f0347365d116645360403fb97471f7acf23972a0de9e3ca9e9f0436014e0019f73ef53fe9d26b9d96c4a7ea3fe57131c308124bcae533fc0ebf773a4175fc9425521302f1252a91adea075af9ca23b1c79a5c72c2770139de9342c96f3ecbac6237d5e10e5529fa946aaf717abe34a3976d6752b09115330f624760475891e393d14387b8ba250e7f8d72fff8cc215567baf29a8026cb4d523fb9b9064957b7feb62bad74f53df8390d68bd5825d27f877b9c1a8876265cd42cae5c01d81c9c59145d6381429293dc93fe140d2bed87ecf57091fcfd254795185a4f1b9a6cdf53c8cc080aa3c37852e0ffd6cb57b99583d102fc8e71509f8ce970251c92b52c2187ef534076af3146fe9ad6d68cd2a4a308a3af5557891f2ad2282d113b7078d7b965c95e84e8f617a4c731417d8daab589b230235476fd258b9c975aa10d845a1e5ee39b431728ce16b3a5ad51beebf4d369644389f8e01bb362aea2dc029a0c7b138447419d327fc97f7d0518f3c5a2f185b37a9157e443adb756975834920c9d8d55e228513b7e456744006a5df287621984e3d8b9afa1d1c848991ad63d2d80d9dbc03049536aa23ac14794795d1671e832dad0985bbbc926ea0a385ed26c288906424763ffe1d77282f27c9c1c0a3fb3abd8da5930c35fa67f74ba96a8c2ed62ffbcb0eb9c471b40a8376f6025cc107d0f18429e2b878ca9c97c4e4488d6d7e21a818d99798a6428daabf5be637af9dbb9f5d844ced39dc41086968cd17e066a9d514435f80a5161e4eb39a0c66e010b0e99d0c49f231da23d63c575a196e5e1f4bf99d8479fbb5aaefb0c93dc5dfe3a7e76b927969d51b6bc3b3bea9e418e4fa04156d45827fc76f1d5029d3ac932eef9f0a3e18ae654cb8b7522adfbb9ecdb2db29593a67e22ad4ea16a696c699cf0e68960bc0961fc8aeb180ef11c260e0c92b1bd7640865b64257826e20cf01a9eb427f6771d91ae17e182563856db013d1cd0e521f93c703c2e930bc7bbd288838b4a1dbdc1a4cf08485f99243636d6ae6b5060c619371ce6ca0f3067304248e4c20e5cc53b893f4acc960928312d73f60f3faddceb6b522d808a8406537227c5ae17f8e46befaad65856aff2c8591277cce93932187a9bd26656a78dff727712869970a619b3f52c2d14ade206442ac83bac0dd148d09aa66b5480b67ddfd13623790bfaa1f3d5dd9281befb21fff6c96bacb107d199c829a2ed439029008d4650394a0279b33df908d33cbcc44c002934248f16732e6cd136992fe3b9eda186f0be5a7ddb87b27fd5ccf12847bab614c3bf66274d86ad34c4ab7e19c92aa8ac384a694a92b7670ea81ff491c8d5f351cd3a2623748c7e3464df47a38ebcfb968841c44d10a409aaaabbb0ed8f60e2995a446a4136b83daab45c52d96282c2581d790823882083e1d65d67b4bef9dfea8b324e9bc5c1de234a409a205336640dc711eaf502bc53bfdb008a131ad568905c6a5d1724a16c666201ff0716ab4bac857b02313666d11e86aa87b55d03457012c8874b36bcb74cc07bd9e9d118b1dd89ffd3a8c99fa092a0f28737f507bbd8941851b1eb475da6f8d865249abe964bb94760e848b3706a0a01cb764b516dc3f6f60e0b20c7c84f1df090309908043fb8fae51d183f6e572e8101f952662db63042816a9613d7a42bf61f510db7b4af13bc6aba332bf856e1efa39b900541ec62a6f39e7af59622277c10ee1d285fe6580570dfae635ec56e6ae948682bbe500891a03c404eff461ae145ff31dc3834a1315c287eec95ff60bcda1c91104a63bc91b39e231936c58e018ee599945db8617ce02345a71c6eef85836ceda384bb37774c953868a4ac8ceca27e1ee4013032f16841840a9fc2393a2354ffce21b32e68198efd4a92dfddec474a70ca4a8158bed1470480e188d07a1b2f6b4f52796c568d70164489f564e84667fa6fcb8c72e30c6cf1d94ca971908fe90dda1cbbfec5631f11d7bcaac0217baef196b728891a125e44a48c6ab38f0d1b506b7f5dfc784d48af33af4a8db4d60030af9c83ede8d401deaf9f4a0ac9937bd12199510330241aeba45ab016a0cf9d40dd79e34868b9c8de4edffaf33d98a0c04d538af88c5c28636e96220fbd8b492d584f7b4c42878c4b079db271b6dcf8bb76016d429d8239dbf9def575ab1a8eaee45bfbf93bf600617ba3a22379ef20ea2265c54a94a733bd3a51a050e0a68c5ab935e23702fb5c847a1ae846557c6836cd76541039bfb3568d4027d01df991454584b7dca31fd30244e3c70e2db58aa3bdba6364f94d9c716d3e271ec86cc9b9a0d673269f5c8b3c3121ebd84fde883afee7d68b97b208970ca98314a813b63ac1343109d0985430c2c30923c57df2cf197d02a8be4da725055a2090eb883bf5f2f5d000e514fc0104041610abfa717e1661a02e036f82c7c3273f8d96d3b0d222e1e90f968385304ced9606197c399dc01f48483a0c788829ad8086e07edf54459c77a10fff6ec4d7f8aea071e8303291b2d505f107ca4150724886f4cee069584644020e4f574e2740291b2301149a3ae14578d46bb70581b6a0aeb130b2f23a01177774cc6580ada6443b904925a1e6141638dd3f2c86cfebedc9979b95248d7473f4039d59b1a2edcbd20275a6904cecb61b5f39eaefdafb405cd7e3ed7b00ab29708d94fe1da343cf37c70ac8290e5e813b5fdb0430c9b1f7b186adc06b9b543feeba1142c03ea99527a5be3199a6c2912b65253b6f7d119a24b70bc24e81b5c36b75f0dac701fe9895bd10cf1c062a3965888cc8e469cf44d067f186751059ccd0b66bf031f031d889a8616284321a42566ef2058116aa78b7d802d7c033716bd39ffe227516a92892971fd4cb2c41da02a47d3ed3fa68ce60a2d8d0b966cd975ca7efefe22691489bb313eb1ae0b2b4742f6163677b26e7589f3f70c9cd0737dc45cc5bc45b88a5779903107538cce32fad0f87b903706fd4041dc25fe64b43ebd298f1ddf7503dde4b2ac5e4b4e144eb9ef3b6378ba7c1ecffc424933d72e6c65db742287b5097cb51257824fd813c71e9fbe4a6c67d8ca8b0d1930cd2775017914d4aeed48e36b259b1e72c5d6f217d5934a9d5e2aed08632b837512586faa37d84545d10a41fb9e7a89cbfe3aa6bcdbeffd88f5ffac3831fd31c0a91b47553b5f8c6186cd094eb05e651cccb3ebcac545c6b8e74c03c1c4fc75e4f6ae08255c8428a71ef88a60345750892e33869962acd207b929c3b0512176c6b92c2bee7172772b38e873737823731456e9e1ec86adcf52d88e443364262f470286d76b30cefa68e55df260a62e3e65b2aea16fd4f49c2323b356896067acb53022ad0fa81ca374a75dff8769fab62cb7183d4915c6891dd9288c1dc89dd5e4e5aa28694b8a5796ded9457fec3499c73dfc06b64306dfbe65c594f8e5eaea4afbbfaa09088fc87ec943df435a14c5048f6b71d73c8691cc764e6b351db4b7fc9153e0cbc84c61fefc2d7b485d7ea54ba13cb38d13107086bd12afc63f0c5dad25e35270fff8569e17c9404d17de9667074a8ba371075daba65bf58f91ceff90d36be6a45682dd2e35f65904d71804da92e16874fe4d56947dd69b0612c0bf3cfc60615e14e50e31ba17cf2323eade4bb66c9b7992a3035b8106b62ad32efe04bf366b809ac81494f2ad0d8467d2795874be90254f16065017f0bf108a63b2ea304413f070fb94db345715c6a63592b049f2ecf523bb1890d03e19edde3fe929b0b8b46974878d32c435a41c6ccbfd955bb116475391d725deec68b95f4c96f9d423ac9b82a8e1f79a2ee1f6df6a4a640d6e7a75cc68a681d6cf425f315301172c5b5cddc492814d95d572bfefb232bec6934f78982af75d189f4e0d2241e49d7ffda6282b4d681bd773975050b4bac522ccb9c08d6d6680d59e4dcb043b84a4ce5bf9395c1c0154c321ef3536b73967920bffc1eb2e3112fe43e1714855a499a8d2d46706b6adb409ca2e8efd22c7bbd3285f829677d95407d104a50a82b262d50d5881b09e1e7db091bfdb662299b266053197e7e28c0f10577ccd6346dd51e64d61d3a738376017b97836bc3b81f5f0cc7e6ebe5f6028245ff20185cb2c3d0bac2b889583b9002540e4ec0ef24ab1213297b1a4ed86124d79d7c9559006cfc6283884851fbecd8f92d7bb7557a7f1c30ecfc58e57d2f4d299ac9c1ca18f5850fd9e4ac6be62fa0d1f473969ebfaeaea9db4af6f308c36a47bb1c0b0f26beebf34617486db2b4d7c048908f6a37c1a1f65372e4e659d079234250b0f00f90891e621e704d55489236495962814dbff806b4888e1ee941b5816cac322558aaaaa7d46ff81c5f8d2c9eaa750973eaf85e88153f32ce9a8584da8cfbbd79c34a6235c29aee421062d20181670513f988739113bd79e7126d6e2f134305b3400fe9adfdd18c2444fe49f90154c0c74f9aa98abde03714abeeff9176ffe2d3753c5dadcda70ac56e1ec5134e538e97a522a360d86cc77e2cad827f83fea5675932cf648550b6fa73072481fa34339978f02ace60d9810880f57ea3cc31268193cf2ba8da5e3383369bf03a086362089a808cf57ef42aae8f65c7854e6a7cae16bae0f556c5b805a77fb4aa0a36cdb808d9f06ae920af2bf0fd0debda5976683aacc38fab605adbf987d7689f3291e79838e34a5fae61320809053115f7216938476b3a8b72753a184c787b0f141ba85def3f606431ddf4159bfc1ae7615fd89270dae0fafd7920e9c64d728e519feb2613ad1d5b8fc8155b651f9211444afcee08fd398815a56755f9bd3c9d311ceafcc86fa0315d18347036562ceb01d18b4969245d12391e8604b54101cbf0d598d13f4bae1dcda854e98d73dc686de94d54df423178a7ba79bae2ead82a29e903a2b6a18f5b49b4f779ce808c7190f05802f3691cd2aa73a80c1c7b897ad06cc9a2531273fe3a346ee5f7ec8283a4e31a6de1344923ddf5c63d014db4b85f66164e0afb897b18ee7a2d5953074535695bedc575d85d5cdff99dddb19d7b20c7f5bb000acf336eda7fe072696a28e855b6921085a5152db6055ed2b4d445a9a58960f4d054c10ba98bc90ff2c73c6b11ab40431c26b99d1c5493cb5b6087eb3c84407f9b3c077119559a6d33c7596b686f82afa98e6f787ce408c32683420570cbdec4dfa96bd57ae00c75115062d18c34a4a2a976c687eb6c4d3c0a38da7f342b39ba51aa09512e7c7a60c83cf9480a93c605c513ce1da1e5f4cc8859c84608b74c043d9d27171aac94b5d8eb32ee672f608a64be3aae8ace0f016cdc693cfe3636ca114c3957649b3faecf27e035c309471639216e051c9f97f413c47502b69c5b8e78cdf1c5b8aacbb42b12916ed964b5ad6b03c0f079d406445101f20c301ccc11024f948929168574d205dd2d34efa8242c4634dcfcddf3d254d309c99689bd59f48f5c061d6e045fce813f5c5547b9e5c17026473ac067e48b3e2be80831820a81442c768b3c0b869726cf0c60bcc2f4d799fa76d4fb78d51ef228f68671fe7a0af61bcf143bfc51b4870875635b73777d4d823a95afab3bbf68136610e0192b19f9b34d5efde6a9062621fa3592bf184f6a3d94f07fb06efe8e2972be2e3f336bacc80c4b4623b1961d76146238bec22ec96237f95808845f999e459e9919111a3cd059feacda2598470419167d0c144c91e3d051bf8c444e726a10076fd2c1912ab930a0e84ca6f08d9a0d63da138a619b2be19a94c88d8a873da93326894eae7bdb3b7a56d6f6c6fd7f63aa37bc2a9bb17fbf8cd8d9654599bb90c4a06f9c870ebe44c28806349e36e121570cd46a6b7d8a917918ed837274b26e6707288ebba2dc2227ce87ed7e8293c83264a0e3ed61bcb5f30ee505fea8d0889d2f465a111ee921e12cb72f15522d2cff57cf50653ecbe2840d8230c597c7777499ed3f8bcc8d19d9e0117265712935b2e52bc38694eaf2debe72da316dcf0341a7144fb19ae3f0860c8102c155e2dad54668140cb5f4c8d014f150295fae2b31b2cd57e6cd7464c10d3f88016c7d9730badd84c351b8dc20c8f9fbe9956896d1262d306d583955f22414cdda5651e6390b97713daf77660b25ab042ff13c56b657ff19a2e9c6c49827756815afd10ff7019d730ff91e3209a53463eb575775be8ed3779350cc09937b0b4c8554972de38ac718642e4d260a01bb8a3b09959768f2392ae4e99dd3114deedd73fff4d77882a6780b0360fc4b5a8600c51513a75780f53ade91cc6ae0784a21f55272b3a55f3bbc2c97912fe03f8f308173b95a0fe714091c31b1e23621ee607df9ed0011f79deabc29cd7866ef59b534a71059b1fb26654d00df854b5c1f4bf49a062318d6dd5e9c8ffe1d2a2e4495ff6bb89ad95dbd16598561c317f2e206fab4e8ad6ab8ee67f96403c7b242db18161ba94134b28dc3dcc043c2f1ae2f948c4b94f780c0d4314ec0289c2642c7dd1c03b469a8d260da12ed7b8be704df05e06dafc2f283499776da18c6536c27fa88c65571de6d77274a32912e61d31fc6236ece17b9004d950898107c0a52c99ed18a015036e6f777cbce00071f88003bf5694f20ab8c30ea571b49a7863ac1ecfd74ee1d40aa6bd42b3bcb4b8045ce49cdaa144bbe00a1a53ad711e52b4ea16f24c3ab63fc83c8d40d07b36971e35172cbc514a16bf81f4231b0a5f35a9d60cdd9b2039e8f246fa38a3d23ff9f8d47cb2bfa90fe8986de0009bfdf876ac3546d21c935cc34010cdfdaadc98d2f25009241b2dd073e7cee2ec7e2da5b99fc61625de1993f21bb26c1cdf73e94bee11567393e1d7adcc915e54bdf7f8b6705deb05e5797bd0d21c3cac4a2097828863af4b97227801f38a97909c399b044ce58278a960fc8a55de486dc5712e7b74ca559a47e2597b748454c9731e7bc9faaafc223c54f215de5f05f99bc1516716a97d08782fb8a804d116f9a4193f2b3b55e0f943107a730f55233626eb98b1d9e96f14c0c79a4f93fb1471da27fa6cd2f4e50242f5d81b4cf81994ea55299ee06ad8885c5b7664515535ac1ec03270f56fec81641129a1ace931b8b466095a970afd7637cf585345209b7bb5408722a322b9985bbf5b26bb851cc6c48b49de67f69e297b36c1a9ff6ddfba29a0c09e88ba8f88835a63b21f559afeea7c4e7b57907cc15fd14ee5d10c5254e825b9e55fa5c36fe4c7c65b3e5517c35713c1fa04488ee3a237a8a4398842e509085259dea971588ee319ac93c142d2e4ff89164f86aa254c8c2c1bbdee24fca717a46a2be1b95a25f233b90139af9dcefa2d412bb141c567ac1152353cd3987f3c557badeeb82de892eadb88a5dc3407ecf500c5047355f5828329ff2686225aa3e5fec1db81a46a0716651a80d2c64e48692cbef9620e43bb2e14d37083af8b7c8a8fb0ee2d88a914cc7a67a27b5aede42b1f4334a69bc21e6df311d590d6c6d112f59fcc71b5a7abd4562cd54743c15a18bf047df44d1e5c812f23bdd6b2f79d4b57655e1d95832042a4a1236e2dbba677d55582e93ac45d8a0cd53519daf8bec83f8631915911dd25516363f0608ed6570919e2c41f96d6590ebbd2cef856e40f16ba49a3a0092f91716676762d5034e2d15bcd0f75d42b0c5219a48c3a925c87789e22b7e0cb8cd4a64cfa797db12435e58c684d7938306bf605e14772fd019be2374cda4488d39c214fb693e60ea83228efe5053939bdc4bdb1bffab49ddf190aa35258ada2c2c58f0d2f7acbb85eec8b5402a8f3d6777a04e4e86368db13402dc452da2a45b1ff121bf75f24a46d11a18b8571ee3e7b88703a82751d128d0f4de1693e976fc9e3537288910743e7e2f5e1950b2051b539a86d2fdd222f4b42e78a48f72202496c6c8c44c574bbf714f6ddf520273629045ad3a8cae02cdb8e423ad9b87d282f96ca17c510d3393596e8cf88a3b4814c87350cb28b918e84959a923cf085f60ff9a4ac12fdb496d091fc899941213b65acf78152f57141a5cb3547397c1f316a4853f2a9e9ae85fb15c915211b32b5159a01049ed9a92dbfa6bacb43729eaf7035e90c8b28773a8055995880d95cd36dc812941867ce55aa4e211ee438b18d9c5c34fc1a76855411dbf8eda967d59faf04b56bc78ae39d686d085608188b302682c52205ae5c6f0269e69e0f3db16595d7109114c6057d0a51ac3095819f099d6fce791f038dea42d6323e77901859d7a60a4792ec33093fe4b0abe290df92a4ab1d1b3eaaf86bbb935c99fdf9d026a7df86bc516a3960c9f5064fe07afa5278784fda70575839542ef8eeb05e5280877670f5bcd0e7a535e45d5b8330cda3223993c51a6226ae67870c43463e4f0ff1677fde479cdba93f268be0d906c51424c43bd319cf45c79eea2eec089796eeeca68cf7b4c46e0a341d4d8e00615a636d32e7219c66b857dfb127f9e0b71c6b6ff0d74d9050374fc1e06adf26dd7c709d68a72a2129e7852efae630d23c4efce49563c6c7a75e029be301dd65060e6463f449c86a9305c213a5c2ed4cc0fffe7970858bc66cb87b8523a3f25888ec901f09f0b8a92eeb8a15f3b955ffe41d29e9f9216fd0270f0727b713ee8cb1cef975a30f4c178ed7006ac88df97b66731fb3eb8a19479604c57019e0f48ed1e48d44adf06ef4f874f482a2d4b9e618cf9414ff5e2410e63e94d3aab57afda382986852eefcf614ecb8637767cdbb4eb6f830883e5dee0181b290ed9157380bcce3b313e7da27405bfd88d1aa5fbf002228f42f82586737d179a7fecb9564502b78d77ff3c3988b92ae70870347f9124aab3219c471195b7c4bf30c4358ba1d2bd30e366a6c495777b26a234cfe86f43cb06f3ae96b8ed90ef8f349cb90536de1bfbdc7450eddb8b3c58f0f53a5ec862e8b4a128caa026cacb4d1b682ef37364413aa6b3dba0bed3ce4137c29b962e2ebfa5a9ba9db849c87bb615fbdc3f06963f477acff1780877699aac253a70067879df7c991231de7d2af93696611a6170e29f70e5445613bb317cf362b3a0cb3ba821c7a2dcb6afe571b79619c701dd413f0441f131e6e2d1361ab458eeaab87e157aaec75eb966745a33f575ae752b08ba54e5ee438f318ed786b2ce334226c35a6bcf498f3ac1cdbe3c6bfc70096e638a3f2b16582d7b2bcfcdeebf4e1365f082df13ee8a55a51d00728cb718bc57dab5a59355b7c4e2df39a323f1ca3d8d80d7135c9fad7db5c9fa8f26ef97a9580165f2c901a31df343a2e43fb8fca9422abeb99c4145aaacb6e92efd6e6d620821b52a8aa5fe0877eb18696df0da42a6e3e16436be2cea89e58cd29b7441cc08748f09d584a10c72c026ff569692c7bd0a5eca0ccb0bd4b42ed19a2e4c3b9ce502755d00edb27d55521a27b8eaa27bcffb447e977ae60f58e45a8eafff5e0327d45e8dc703457255249f9bd6ec4b680b51b76b603bba18bda900afaa17dca238392b850217b8f460442fe6a0a749c072b607408bb244c67d73848f381ebfd05a03704421f5e9fb4dcac846a7b92c48db35d32eb4f8725e6fca62b9ccbb051a1353313a946c4410dec9b12c6a4a50a7d5381aa6f59f8a732600144fb092d3c80e9a632319c8287ba1cc00c99217e60fea272abaabc833e43264792d38d584c36d90581c5b0b40b9cdf8c8d1e1152c91fd0a45fea6aacd9726d9855f0b8b2a2900079676710da80fbf8d766f09d50e2955c9104fcde11a2523a30ea05f047c738d5a4f53ea40170fe15cbf247837250af005678e5d7c07ebabb89c20b3a29880425865e4c3f4e99f811da97341038995ba43591978e8ce0f3ae0943fed56afac4fb7be3ba77e49c5e57dac5f09654cd3e26f9a3f7238c70d67e570c2382857d2a740a932562ab4d461b522fcb406a2df23771fc1c1332386a83c7fc105eaf1c4d11dcc41802faf18af1d079fc8504537b84ae9ccd2e1688f33acb530300ef3bca9fb20b3f032fb50dc41b7379dc3e89c447117fcd2faa3152b6f115aada1b1dae4c0b8b717a6927ad36ebcabd08d55b5a8eb84a21b62eb4509e4963e0fc73b2e9020d62ee1a5bc92d74324d070d34ea9900490a20fe836491b77d3aecb5e3574e840b14152bea283b7d3ba645552f86dbc56fa66a51e585baa580a0b2a82e84ae8c538b623a2d669195a6210dba7c18909ccf539bba8cecd19d1bbe6afa263f79a979b207d4e9c20d3bea0b67694c9a24b0fda756f1e67c389b91ca32b70d4a03c28c1625bc5ca3e9604f4ca7df0e3821eb0e8d4bd9918c55ea88e5983730be24708eabbaaa35bd444e67a6d1c80cc76d94427eb8bdf38e1356040f099bc9c3522c295decd83281a2fe252d75f6f2dcfdba6579666c6719c76594a614ea6600e5ebf8fce6befb49052d1ae8e706f44133ab26a23ea5dba75f951311d09e7537bc8a14673c9f9f6ceeb5f681c0bb8b558fd56dda4660a17e30063cf3a025cf0891ff03b0e26e2532c822c21fd2a9e9b587839714cc6b1884cb4b399d05c5f5b2a6a970d225556af2fa4744e72396dfc8a6ad2a259953e51690546568719c89a53c54eb7ca4aca3c2f5d696267e653a89beeb8b40fd7b19049c3f065c834d00d001b961a420a822da7842ba43e509e011df7a4eefc88d59bb8935627067cd155c232e5655a1d6bedc0c93ae2d051f734108eae9809cdeacfc853efdbe119375ae4fb07cdc1a4b6f54d4fbc312ed484147ebeec42eb0a70d9228ed078ebc44b4d414824e8da3d8467704e1b83de1b1bfcbccabdc1c044425a680be6f8f9a1ef7a7f2909a37df8c287cb5b8a14604ccf349bf73effd141bfdf7c6975a2443c06bcb979ee7eb081945dc2dac9a50e1d11c1749715d22941010c5b597d60ae89d24fc076ca39af1129f8ad0bb60faecf24d00946b433c48bbc916c915e6d6afb24d80c10069cdd55610bc76cb014975402401c90ff321c9e402d49ee489c1de43f4f91973c01cfd823bc99363341380ea536bce2a0089182f8cf5e3a393ca3c12b9cdac57c081fa7d4e23df2f1b364182df9a7682b80e3cba85e5873f5416784ad945ba050b15bfa9bc17429a35c8040fbd72b0a54844b3885ecec3f742853995ce3a64dd489de3e7d21959035c3b5027e073c2e87879e8eeac4bb5c184a13cc24fde217383bcb0f839c249cf7558d23c0ef6ce738cabb1828b81234170f5f207d0ebfa6c7157e7b5487073d112e95b568de631e256074afa52c1bf7ac6e824c5351e4df92d865764e5fcff0cf5ea3ee2acb728a7b147d1314c293dd4aff9d98793d460ddbeaf46875ce4c5a2e4709cece173588dfdfdd5edfd17ad6edfb8b8a2393c8bc0cce9d727d0432ed4268d724fd33aa052a080c6eb04667b6cb23d54c6d529c96094554b3f2883de09085426e2784e0551879aaa307b7518446682df3a049c0bff2c98c8e72c507e1873c72808a26419e60d22e0c82329597b71eb32b874b7135579ccaada71c7a262081221801a58e2b9865ac4cc364b60ec5911faf52e72e50d1ecc2c4d75fe86b543a9d2047f6cda4b18027cd179c9a10b37c405bf39ee97a83a9902f2037e8aa60939e7b8ad9390ca07a42c075588a592926c18ce07cfe18d01f9faf393dfbd04640f1c2b76ae4eb11386cdad93a5c29212482f0ba91dc49ffd8366fe3a87edde6d385285468d27a19242d4c19d0da45f83c5fb1863aab5054c8cf5344aaa0c6789c0a44c71a685147eaae21f542f846c04f0df9ad8f963c89c4837d44e3f298be083fcd705b08614cf58f551fe21d8beb03e0df3c8e1051daa5a4bfb8647b32a471d6e872beabb6494ba57a5e32c05a53b9fa40463c380077d65025c82d7fa131f4c3d4dc3018e49a6a10b15c1d73e2906b92a55063933ef5f37b004544b947b8ea3e163dc88109b0ef5e61e21b7f330ffd3a81bd8a04720f3758e0a5433865a762a29f33dcb42c4825e80f6d657dbb57781b84563fce1c3e8a97a6adcb07deaa1acdffbfd637ec73a25845742d093f6eebf476e4daad23dee3ce20a48f71787c4949a6eef590962a0922f988bf1db7bca9c08792ca8249fc308e5ad1970db0bdc5193e79ec59d25b62b88d173e09223937d35cf9ebc5d28200e313536cbf94bb708cca11790dec3b5a376a20058ea8ebdc7ad785246e17785a6a6ed0d1d4169144b3c8afc2a4399ac79b52816b5a598c49f3b30b06862fa555bbf5cb0b94a8cb460c4640723a5251140d1c2058a7497f99c1f895dc80dc1f4eb6b0590bfdbddce3155e7c6905099320c7222668124ffa3995902c3941dcbd47eac48c56e085ea4b02d24a0b0cfef372574bd64b54c33575753b21aa98273cda70bfe422b6a988c2e3d5d6a36c84639225e8d2e92f79a4b8512ce64809ef0f73da7bbf48f5dd280935221b47713f48812b83dc1c02df1b678f92c4e55ffab41160095f641b1c765ebec043fa308dcd04c4d563dd4684e546ba280e08c49eecf94f6272be0a28a3f3204dd2f853452d68e1e96ae695fc08a76df6fe6f5f93a9399da8b66f08187e73e12d6866b701a76c34ba993777f6b7b5a1a239d173612ad5a9eec2df2792b452e45dad52aa6968d919fa025ff23ee3ec0ce024d850d60441287813e6ffd4a22465a5d773e6a8937e3b23ab6e20308a791023494a7ba8f0ecdae92fe3a60e587d3eb2ffcee762cca397d320d27e70159721c1c3213cf61f13f41df9156799e452113d95d2ecc81b6b33b27a671e2bae5879a3342f6ed044e1962084f7e0ef690173aca4e50037d5e556984004f42c6f1e2402414bd0eb0cdc1db1f1150f82b589f1f63028550d74cd4e94657bf3d2531e6e184d604f38c0bf2a742514b262d011b54d610a923287a1097133ccfd0756999063ef5685b944244d86ccd5d7dac69eee0f0bfc56169a9f73dbe8412adb339e507d07d2b3d5d502b5ca5505b47ece23cc9a2de0343f91000403d1ca8b932d810b762598875537adb0b1d12e4222a064600603ccd595fa327f4f27c22d0c09b92611f29e8df6732e03697d7c06dd186e19eed8e05ad76c178546094be90de6da3a17930a2cd345a95005cefa2d7888927f0b4e8d76db511c6afa6ad6c80ca08cef5485a7f8c3b9022f59cf2da63caa2a5e811bf102ee9a3e228d769b779db5a27731c0d375bc40ee2c77766e18f1a2ade6a56044c42d24c78e8f97255e31dff81c8fe4927629796ec7373252c39720bfe5dd949a4cb7d79aaaf6d3bf975575369e3cc16ca42da7ea13ac5c70f1de278cb630bf6d7ff8c6b736d21c8b27bda97318545a9705d67dc72dde5b2ee8a7a1fd8b4c15e93ac7781b60b9d412ec095c81434014ff533c26033a865a10f7965448f2d4203cac65ac9d90e5b354fd0b09cc8ed93a3310c19d8a61ec3b6553c3b8c169f3a8cb5af75572bab825952cf21de317ff4ee32798b435cc86d5b3126de57b1b114c00c90e5a80dffcd109b468ad55d846fe44e9f21a2ec381c20b0469570ab6e2b5714c22e8ce87d7ae8d27a3d39a69c79d45075fc773674af92954446e9794618fbae500a684050d6b22e802cd2a994d4b96f35a33f59b9b00e464235e3ad1c250c25517fe1782f5460b656261f3953a2aff79342ecbcc40c5ffc978a43bdae2f3a4a5aa39058c356d3b46d6ab273ec6dfc2815afdb5a15d9de12347985c6c394ff5839c054cbe524ddaf9eeb7280a80e015ba83865c99e71f9332566dd0181f7ec8ad8eada556d425890bfc8511260afb09ff2e4f3f5b843e8ba66edbee908b95069c365e4fe2e004479214b0a4e196e3294051332343601e209ae99b7835125c6a13fa8abe22ef862f9a5dfaaf364e9de43262eefb50ab32e2637c9a219f109fe5aa5fe9e829ed4087a91cfd36d727b0ce3f50aea42bbb08fb238dd82b84d4caa027c4fe12918a1e3e746bdf577f794ddcfaa3879b11be83926964dd1a779e378dfa34887b470a47589202ad2fd48d8b99204d165a15071f4776e241e3f716c590eb87c0074a15af764fabd4a4d227b74889590441a0d3387b694c044698e1cd86146205a31218b8f46b829c583742c32f1baf4ee13ea4ef0d315c2fd5c2053020470f1eecda8b9051c734ffaf6e48e41bab3f57870058ad7252cd1e647d88b10f439895664209fb76c70eb11a8b91b324e1b7d7b181be8f6c1b5d10e084ab3f44b3e8707ee25ca9912a33d767b3cff17b0e17e8460c3eb5833eb171b740f18ecd8b18f4860017f5b73bc2e743f5b35a8d99b20ab08a74794a8bba4781e87b5639b67d8936a244fbaf224eda90fa696fbf55d861640acdfdab59ffc7c0d5a4de7844bc7abeec426f67ceedc305588e8579002e6cbfac41614641b71c331e27aeada58aa72f366f26409b92248fba8c1568742a9f4c4c082683384e2dfdca2088c22ba0f3438a161120b05ac457696d57e79eff1e9b3109fd7a9cc6ad9eca0aed4b92fe760b98168180500329c3a05ffe8d58a9e09598387a96c62a0206eda730c7b946addc951a20da80046b93be570e804e2581896811f12a4b829c8fc22d82c04038cc3e7173d59218e93caf5d51513f7509e16a9ed7177e39b2cb498ebe6cc21f3e3e0a7f897a526d33df8c34457fc24ae25d7b24d17bf3b8d60732d53bd471cc8e6b22c8205117fe84d9cf0482f99d4cd65fbe89085dcc3f37933d1bca069c3a37606408a68a8772dad598412115c9ec6ac7766e362e3868a2c31c1ff0238089f0dbd11d5e0a89ef848d0f7b2d499c97da97ac07a1fe8aea6c30428c0d57268c57ef26af654c3ee09ff68765216caeee098e945325aa7ba1485a6a92ac5aab304af37ec82102fba24986d3fde2544c48b9f6bb452216d42686afadac4061ddcb16bd78d526f1f480d2cf98ee847b83005e87de8ecd916e55cc6dbfe3f1de95b5de65c2d69a93a35a5000cc42adb077ceb01771567b42770b63edbe5cc09b3eb9234b834a2bfe42e309837d6b81c25cb78cb1a72c02fed220c6aa9471fa238bf97fb6471c613807dd8bfe5275bbec14b2426d6d238e877b26945c4de318af0ba566ad76c60ddbbcc64411b10e2c10a26e3be8b00153c38039c09a2b00865394c496090cb72cd0cfa2ec92dd754f047dfcdd98446484b23ab31e33d87fc74fbf7a12fd58a3e2d1faea219c828aaa46888dd27494e0547878f359701029cd04927d3293ab6d79331401653a54504f36c986345e791abc5fd08bc87ef15e3f336a5d5dc29d8367aa872b41ab9a4d6b828e2f68a078646210c363233a7d379c5b69c3e210025d4eaa0a2adc0a2df9482ae4836edb34c8c3ca2801651c109258fefa35f86af7fe6572e4cd7a84e6a0137876ed5d46b47164eef1d17390cbffd619870fa63baa6cd79dfeacce88045f3be058cb916a424c8c59477418adb187cf31f04fbe8c31b687232acd1b287fe0376f855be632465c385015accdc6958fde8318b10ee35c9cb489e33d619eff111f0113f514b1fce8605b9796d94e0f95e2cd1f4fff4f253a2a1ca745bfb4d72553ce9bc6101cfdf79c5e410ac8195ab36d3795df47060c5148d5a1a198b68acdcecafa181e8faa52605cb72692e1929da7ce025d0163146cd02242f2670c5e96230b72d2e330bf55af968fcfa648199ad6339255b5de413e91f8b943f829cbb1cd793a7b5a9708bb20692926a90df2c0bb56f8fa95be0f9b7537ca98f9854b65784a4d9106d33f4dc1deaac6c206720c826a136c88cc58fc8dbf6e0bc4edcf1b3c1339888e7ab0029ee44999bce78079c5ed7261d7d9a693ee43934518ec42b177b80f11406db82423099de33a725c8560ef1d5a8a889a67a63add562333150f9a1e625f548335ee85017f7121d27d06642e7995cfc01084795dbcf5dba07d2a0ed0b3849aa0ea9cac38e368a0ed60cc1d4813ae5b593e9d8e198959c6c08a05e1ab1e365975b3c3fc61a161694a81654c455b6c6e912046853bda8b21cdb6e9bdf4c7c889822a58f619b404293064f4e2004b6a12492521365236d1307798ed42a244478d46311db4578e41a59d8e6b6ff5a11e9381699512dfaebc4653a94cb8c420d592e89966eeeb0a3a49a0ab193d8cf58b406e5815075ca4cbca41f8e6aca1f32e9fa68b69d38eab6dc8337558c387013bec09dea8a95005c12e6f1837b8aa1e9a2b1daaf517843456bf40eeba5fe0a258d8ee19126f2b2ad14ad9a825cf43ff5a968cb677510f118ccf30b85cae3afb3d78a074f6cdc195251cb44597af2eb1a477d7b441b9482c53d7fae15396c69855d4f5e2caaf4d49853ce46a7c893d5f7cd636aef57366ae538fdbe121e667beb314fba110b2596af33edbac809cc7802817fe5e7ca906cd45c2592a33366bf9c695135f6c32b0d02edfba1609d32ce85eaf028a7b57fb6b10a9180d7721765f843b47983c7c98ff3edc3475c13acbef146084cd9e420ed9e4e38c9e6d720f909a646cc0eebfcf271913b6c8556dc90735f0b69f46e873447488fb5d402d08c17054677163fe84356fc3c43b4feebfcec0fe610d33bfe30deb312b672b57d2aa3e12e688ef568400812668eded3ae1ee26af8b99f620687635196de937dbef72d6e32de2f5d2a00affbb8300c42d87a1897a29ce7b11295bc4dd1ee856042657bc266cc9ebd24f569e2d1d97809a02c84ce95bc1e90ca7a742ac112f99bb0ed2f39d9fc7bc388c7c248dc16075ad307606e82464bf287e90422f305eee221abf1137d7b083ee21a49fb40eb3574bbfd3965580e805b148e0b13decd46114edb1e7d7ee62e0dfe04b37855ce42edb671d41d99359b66c8a9acf96ef392bd2a305bb732ada86d0c87ff5a7a5c0266719843aee941efb91cc7776ff58aa8d7a4b72ed34247fda04e83e363852254d268deec9ab24a902ea895a36c69cae22430b7c776f2cdc07e41f25876303d2cbcc5a0d79effad3e4674b1e5020f0e9463f084e4060a128f85f70cc19a08f878abd3998809404cef34ded598b0df8abf5cccafb863c19f0430026412d42a1a816d612110cc7494e4de5c3cc75301ba82a2c502e2a2927b685361e32c6fe9ce61d30d6b61f24ed366316c101d0d1396b77c19ad8e62c5872208461b41c400ff0cef338db4c6ba1c89e536cd9f2144ee5139c0f46ad5be2aed9db208aa35b8d49477919c44dfa73cc1458c5e45839ca0d92c8c92bf66749f5858bb05e28468ceea9fb1a5727d8a27b0e33ad8b36b51c6f00ca165e7721de142ed3b80c67975bd4a87a18c56a6f29f0522e5df7d1501fb2dceaf1a6f5a69b93d7a88b9099e488ba36082e07280e270922b76bc25d8468d556cbb6d90cf2d1f6446a470d22866b533fd306030006d22e7d46481df380926a0f345fbb6787c0c767d15ae4c7a0d9ac9a417981cf5d9738259fea652cf226ddca792f2bd3b6e995bd66f06c477d71a3a840672840c0ffaadcb429c2d73a7964a898d5a8bd73e54983b3f0e195c5750307314d482019de615d680777e1e54975d07ed898b19e34036bc43c273b405fa253a1dae045cb1bfd94c8f489a434aab5e98298de0de12a06e3d043f514a9df601615185c4fc312030e4d2f88cbe8dc643903b49ad30170b2726fcff5ca95daedd8645cdb80eb96713229cf639c87a3e8ce5eb4a3964e291b3c5c8203280ce9eb54ed50d07e48a1066c002f7ce9c3ed450a084ff81e511e04514d26a864829cb3cd77f964543223ce9b1d16fa0f5f9f57f625c4c52289c256bda9eb2a423469ac555580d14aef31f0e0fc3052e87559cb84bd1d1047cee7827627dd19c801e96423f8ce903054d4b32ab5a12ef188cd2e3c067e40956478649dc55123e027e36474c85223c1c04500daf76facbb8ac43c9fd436e719f59b1a3a3661730f60f5048e140861b02377b6661774fafe8b0ba99f11e24aa25a0d8c35b927b04cdc862b5fc225fca3f04ad0eb57f872fa6c5dcac8fc6b272742b860cfe51feec40e5e55d9c5f04776a49f695eb68c3d07ca896add1a87ef29da91846abd78fa663b0a848d9f2ffe100be507fee4d865f99eba4aab83baa0c9e863c3bacf9b94f6217cd3eb4ad1c309600b15a2df982ef9f71e401d7589759b99d562a88d0bf3aa3578cd9d00e0bf1146bb2f17678555853aa3172dffe115caa0c5b81e64b32bc21475a586270be035ca694417d08b70dd58c0d6bc27a549da8b342b4b9049191d3bb0741ad4b8b1c0e20db580fb05dcfed7965e8857958a206c2ff38aeed821cb11f69a40d3ac450824460d215571a8e1c5375735de24b826ff5884e58492811e9c87fc994180df6cb30a1718d9fcccc2ec4c33e5ecb403e72306fb5e16ba611fb1463cbe2b65f1a962746407e0b990da1aabf2758c90fb64712da8f3b59736fb3eac4f487f63e394f3687fe88afeba0c5ee761c7104af36c3e8af8afe741395ffc2e11469789c79bdc1ea2f60bdc63251679c35ed74c95416f1e1d8f5f99bb970d32aa59b5bb7b711091107e4a60cf9597812d5bba2192d8f315c5b6913d79e7f33a061be687ae881c36a94a6a9c0c20e6f9f279feeffffeb1d33e525723ea6fdb8f7f4052a22ddb0d7d31026ebe79c3d1b74c03e4f4c6263b01ac4620f5a177a10b612c79cd2c0781cc0e22c1c5202b2e7abd559984d1013fc7f35df3bda812d36351b6cd0a2c9fb4fdfb4e44f09fa549a36819876197aa5dac00c591f350f9119587940272a2bcb8efd1bb3f1989703532521624a70c003e3eb0a6ad91df136cb862ea39476a9bc125972242d8ec67449c5a1b0642f3d542bca59c5dab48aaa07583a23b52df2373d51294ea1fccca7bbeb7e8e4186f0f4c4ae54229befe92b125f1bd98c273a5439b9982980f3f9b5e3cc3bef1ceb3327322ce9a448fc82c642de7032b2a4c05e03accfca04209ebb2432bc862af161524278d20688fa309cea2a16ca0467cc844827234bb857bf8969e7a92032aac4002ae72fc1a27a9930cdf1e31b931ef67dad6f60638c84e212ed80a9f79245f72086d6d202fa7c81faebf47dbf3bc22321e825fed447f043e892ea24e856e24b8f00091a0940fa63e35c296819578d514dbd2cee8cbb4565bc27b686740b2ebe70eb0aae4e64cfd1d808a1d24d3c448a0b09e92d487fe3c370734c27a1d57b3d106ad2184ba5b1761a5a80f65f811e29f1c2b8d97f3602bfc17cabc26b488fb6e85686ac6606806e3e21b9226161e3696a88436d402f571be37774f356d0405e21c6727aaf3252559de57649bc495a860f7c363a259bfaf11414d86a75f9e60bbcd54974a2abb3445026e7e1fb83e261a26ad9b16377e632928179365964fae146882d927263b3cda06429212304214d97ebf393408a6b6e8c5c188ef290c0bef339394b64123b409312d99be77dc465dd2ec044d176da1220cecddec7db7762584c33ead29d80e071004cc688b20c96d8ace8ca8a93a1192989a652da8e80d752762d417c5f79ee991ddb3d13930ce40c985bf6ddfff719c43a80eeb298875c5b78b4239583b20a02c614cb07ad9a299fd6a42b46e7838a71868f6598c83a379392dd94cec0a581538810f89acf659ebeefc9f2bed8c889154d1647d3ab9e37c874a804e832b9213dfa032671f08630b5779a6d04eeb187cab65e9c11346733ad7bac7f196c3b52a93c07ccfec933c544f234016f4101d982f8f3213bd830382d6ee4cca67ec37fa5718d97f3f07b73ff49b37976c1282466d109c1aeda18679a04d9a39a405a8e8c5614044fb11876f1095f45dc2bd163f3ae8dd8b37ff52dd57edf67b5588e69f11ea75aa3fe40e7282dc238512df5100ce0d8b7a6f6f5a33753581fd00a67431c7f6f9151f7e24f8a11f576c570e2a5924eff4cebbb93b9cc2ed4bbfcb15abdfd061f7736ef40efec0f7581d12951624b600f473c127249322ebf75fe67e667a19adb80a836caefd7c0f1809584e00145525a6867029a5186c982c18467a7c4ebddba0461d001d4c17b9a5c0ac55429021d50b8e56938ed533fb18fe94c367d1ff702e06e480ef48a8363f59e7238f5cfe83f99d6bb75d71ea30bc4703d65e38f78a1384cb928ab068bea25e46bb78b15a014a8043e26070a1d8dc71de931b3696a363e90f16ba570a040def697c315f8c81583a4d12fe2a358e4748ba3a3487da4185c16d18afcda29a8a2be60828ecd5eb196121e8ece5118ed8c48eace001e9c9a93938888c3dfa7a91b44e33a26f7ead7f67cbf23f54059613823ce156dc8b46004b2fb96a112bf9f43831fb943ee1ba89b3686a36d91d75500d8d43180b109ed475d39e320cd3bbbcc84127edac5d3f2f6fd33bd860e2cdb2f7c0ccab54d15f7db95f6117cb58a9db88edb18c8a9bd5ffe5b5e4a512627786729bc07c31536d27633cbb64a96c3b8b95b2606640145ffcae9695dde4eb1af7702ab2984d4768faa015763295b99209131c32600925d4f01f9cc3b0953fc5855c35dfafc9f403350c480217aaeb45e58f626d6f6dc68c91a4432ef17111c48aa7d7a24774c8efe7c4dfb0d4f33fe8d72677bae86985bfd65c821765b9661c85fcd766b473e6f453f38fce54cf5c4b2b29e58b407c243cb968ba566bce3303877e199b215f47317773892affef3da0d60aef55b34ce89ef21f596c0cae094cb0b60759d44fc2bf8812baef25735b5c61834a87c0ba938aba0dea598a3bd5f89cde11b812fc4676d8634133a7d1eb58313ebd775aaadf693896b339211e1e505563c3d2d4dc6f8f2ff2b9bb8ac2af1c1c53eb0d84b0651470fd5e20df2f5a22c210ad021ed26b8361e4c26209bdbc4a49d5804f057388a0bae14032a66b20149e5e87145a5ff3a6322370f3040f93c1ab189e398e9d9c5235688b545fc422c3798ca2653096b1e450226301a2b39f4f75adedb4ab6a2e2ee05f9bd24deff72751a98786ccd0f373570b6410275c19e32088be0748f8f912528e8d901e1b1b558f60199548398a3f8810356213a028cb2727fb25256cecf4eb5e8dcb8c3d9bc07f511fcc5b5bdbe8ab0c27ec68c3ae2b4b89f8b2734b8b9df17e4333cc854a24e4fe5a8e46d95dd35fb556c93d9f2167924dd33dbfd8de08e617d5b2226a369ffc804ea75d9c87b90cd7fe4ae85fcc062dc3212ea2b26af02569c9576eee749c218e74861b54d616745e5bc617a9c9235edf7c17e24c98f7423f4c61265441b169affc8fa121902b482c41c7f543f5db3745dfc0d2bf20296e17be8057180b5abc959a95d63aeed07896f2c96797c06d54694f340b5cd1add5af2b5a577b8a212b661647fc9e90500e619704ed5efe145893f62e6fba03bb29dec95e5790e8a44bc118d0647f0abd698863c57065721e43f947ae49f2bd1fc60e7d1479281ee38e5ac8ab5ac383284ca31336058edd0aa9fa773b76b1670aa01590d6138c7b519ed6d37e68e161b2e729e11dec989a3fff8ac7f999528836042c115fd18b1a4f85d14031b180dc3e9dc21295b04f17ade475e00d2c8d18b5b79c5f4dbb36f502a14c3b89e71e2447ae8ad86cd797bf9b6779e913b9ff131cfad4abbaaeb9d4160e039e00b911a88b57a66a3c9d89427019f9da2663e50384a5e0c17c6defee84180cc6002285a52a0f68d3d69abfd8a33ad44c2c7c714f9d7eec99e2853df43698ea74a5c4169f0b9b51e4dbcaf7b79118f347d4da5543159e4fd1017f51fc38ec461cb0bf620b122cfe402c0b14a035a712251f0d9dbe24abb03484fd161166d6dd411701da9a21dad9f01138836d7f280acd7bb9c2c55ea371d4822eaf822a4e5d52758fbebd7dbdb019164be0cd13eaacae00b753bc5f1ee19abf7d6959bbd228d27b8628e2350427b42e59319bc475b171fdd9532aa8cc48666bf1da64f1bcb7e9485587017d9090a59b2b74a8aff81e92e0680e5df0dfc77d9ebeea565e91765431d22816005d55cd857d4160ed14c24f9b102be7abe457d5c2b12b1f2480b5b36bce43079588df7ea3357b9320a2e8383c604c815351cc193d9cfcc3f738faedae031c66c6d8ce38eb1ffbc47b08e167915e28a2d434755388023231af9fd2064bf3fa17ecc5b0e94d7672b5fa2d1b299040d06703adab39f9cca275419e4cb85d7c01eb70f5ccf53a26aa285a0d68ca0ba7f321edb43f037860391d21b64409654dd74678fd6434de58ceefad77dae3ec9329d0b52f58fc216bff2b16bcf0184db31bbfc60c9faa4f90d0566c5fd209ae175c547b652b1df83896d7537ce64ee155f1a048111d424f2ec4b1b171a6a576d2e377eb90c674d980e3e29803aafbc9a3b8d12c38f7db30d72e8a140862a465bcfb35decbe191409a486031fc9ab5aee2ad696c12332e7df861559969ae231e339832c756cab5174bcf45ee7d7308e39cb8b5ca2945f935aac0caaffedb047ce09306b90372fef8a9c24b7378b2e13c1af849c494cfab4d74dcb7dd623e076277e1eb014d9e4f12aacc9df8bff6f5c913678f822d90e4688c8306c1c2efb6bbd3bc844960ed9bf81c4c81b73ad699d3dd3fcf6d1055152b2f67f3d928e6757e0bd0458078881dd475e363cdfef5c188c11345db3e26e24210378d1a52404655237f811059dc040888fdd0853a2dbd76d2dc6b3a715a750d06209ca0027c48c3af979af423eeed4d88afdedc955f73eeb232da866d056acf3bcc3c1ee7d11273fc6fae002c18eecb4bf7bb194058f442f2daec70f7e4f6ae44f55cac58b1f0240e4ef84e622b6eb46fc283aa12870930feb6f180de870fd5a05004cecf7fdbdc4f894dbd54b834611f6983169afc7c3ed5d02223c6e234334ea5d51fbce1e4b10222c406e99f93a82e7233c24e9912f44fda562792afe3b07a80bed786558cc8494e44a9de3ab6b6de443620170f51b1d25a616babdaec4069842a2724307116ee0a349684ffb816d653f411b4641a07d493ed43376c20872cac9fee33d672f18b8fd5680a93fe00e40d000ba2bde8b17da7647b6885d6cd9547381393cae997094d416a4079ef03566eef8cee9ee7f76800324a53460fc021b6e11cac379e68a58f6faae891edd99d742857fa36d82a9c73c96eed5efa53ffef81d171e803d8966315738e938d4e425522c90487a353d22fabf6d661ebc34aa298702dd8047caf7f79ba93970f5efe764420267757941b224516dab1a0a97022c1825143bbb6fd361f8b5a29f600f6de9d0217809f7e58150795c28466e45a72e415672bebe8dec2ea6f29ad98fcfb0729ecb22e7f436a41ea236cd0a7fc493d7d50d55c526a699ff49bb1149068ac1ca645cc9d99ba0e60fb82717d57f3ca02b137104caeeec6057bf6fa6de96a9f72c932532e81b2c8257261f256c81c2a7702208951670ca34e98bf81fefd5e32e6a03169967e84f4747a606f32da12d73c2d4be901f15cea035952104ae081dabe0124d4c46a9e0a07223eaf3760af11176100534d82180d33fab230dd2c8b78911529c1880b7ce569fa78732d68b95b8dd271a17e1796d1afbbf8814bb746333c99b43f9e256f9c7cd67dd7ebc07d0488e24e492b2f7390fd7ab34fff17c5fbd554eb3837a4d865a82d464c60019b8b781699f9ceb9a991d9c66dcb7a8f8a6207931ab90685697a89708aad0b2e9f41970444792bf7ae98b5e792c13d5b3bfa4cb667cad792eadd34b6fe73568d5b1ccd849ba4eac04fe223b81c3091e17732b87c206b67ea41b5dda44608f0bb26b707e23faf75997c1b98a1bb9cb288e950d5dbc07b9550f2bded1e5b567367f964782d51d2c4a6d2a788e71db4363d84b28a2f4e53329c62829c06711ae924b3a8af36922fd22de5fe27d57e6c6f942495fb18d087dc9037d8bb65bba19036d0e45d6f3b47c12585f163c0cea747a9531aca6124643c1677121b42ad5364c0fa0759bd7769ae2d91be3c0d4ed267cada753e1f58ab8892c17edcfb357e08253d46ffe34e9d66e752cf1c9b556df0b73e0bedc377578cea72d6513a825075b9758b595d522aea0e6b0e740f74c184da3c7b53d1f0b25b98fe149a6e2578678c7718c8b2113cc4a86a2c9a2391a42f25f1da1ea377afc15fc0070a7820e494dd5986745c188cb8f49fcd467a3d4e2d6193ea3685601525f82c278c4b5fb61b6ad9495c4966a58100c93b0253633a154b45f3c5a4e6bdbf279224f617d62258156259fa15c013d6096d2c192debc6baa640345c7c7a07dfabd07d3fe46febd4800d44e39b7a165ebc072240f186f599cdca63b0da6a475eff2c24c73d659d9188d005a20cdddc93ef910fa493aee54a99cd3a6752fba16ff66edb91772eb59f7750651344b3327f412bf594b8bceb1a45a9eb9d95f4a08e77a48510d839a3858712bde650e4035d07864d3489fe3dce07722e685dabb82d3acce1e2574c24ff65c9304a2e59ed343592393ba4d4363e1c9412acbc972f1e18e5334865a3b0adc6280b54030540f90fe4645ff4501ed0dc5fc139feef24b5034471ccae6d22268ff7ec98869e7dec5faadcec2b9a3b7d9ae9ec20babdfce95f472ecc2b811d79ed535666804a7e60b852e41aeefe684082bb173e9fd30c52150a9715658dd57e3eb887e23f8831491dcb8b963fc55207b11de39201f16154e55e8c709777e5567e9b65a54a6e147d55dfefe03c56fadbaa880a1ffa4492c58a741bd428419c067d39af4cf41ba56bfd2c20a194ac50b441b0c7dbd9ecf15cbe3e788fe47cb64dc034c66bc980957c0f50cc243478355dba80ab5a9167832d34e76f4f63d64f0104868e0b8d0b9b9e11a140326768c1f391399fc7c53ca303de223b1ee2bc6a9294e84e7d50217efde23fbe56c0aab992eeeca20ea24c11d10654d07420934fb3d5a5d1ba2a69f29af5401892628252e849a38428e7faa6d80db951435fd0869a7c7a3122abcaf9691ba651270f07154245f8135f2ff30763746f42c3ae7655d34fa8c34e7963d5d43f9b84c25d8e7dd749f925c77d9dfb1b5b8d2eb7d4d5f2e605fa8a7f81f1ce25759ef1cc0de1485ad2c28fc0a2db346e636d4408a1cf8f2a38d62c25408afca4b2de8d7fd44769a1486ca6a71d81fbc69ef0d3035b8639067c860b1f8facda023b7dc7f478c8ffed0e5b421bb57a53c8452a7881cb81514d96ca4e42e01546428193ccb7e26790ba33652b2167469d210fdd885731a5e9b32a8e4139b4f60da81c451c43e32d1856169c444475f8ef428debd0dfa730581575cfc02a060e6d058d893e06918b7d4e3e8c9900094dce966050db2adf3b2d841d1ec9b1633f87998e468b26ee572752fb4e15602f377e09c449b2b690378eece8a319d3cbf04f5073616b6361141439efc5d4888356dfad58f001f89e54abd6ed86531f3e85513005de15fd407683d278f37cb075a34a5d1f38f332d4901a60bc6f46448e47866240c81cb6ad2642751b71c46551b0cc579933c13287274f6566e0e21709218b81ce7dd75e03905c4ba9be3081168125d608a68383a802bc194b02fb3db6ff03b2135dee669791b289e1cf34c79091728d07449238448bb51c0e9772190625b70d37008af26b694e95c6620663f669aaa21b0ed937d1c13c3b39c3d9d0289c8a091511c8a76a567567fcd77546c49dd4c3fb0924ecc1afd5f6c9aebf074a621934f9119880a32ad4b6c9fa38e31adfa6ba343d09110381a0a7c797e3f1b4d36947e934ac0c41b4ee5898ffaa83f7fddd825419a1de3c2b2fcc0dcd7b3226fcce110306313b155192aa4c65e25b4be4aed28b2e32323018e8484a2ac0919fb405dd43fd7e69995a6e29cfe663bdad4a2678ad973f413707e1d8e05f9661147676780921c2671973227256133a57780fe4f6e5dc428d58133c53921343df357516420ad9e7e82c0528e5a65e3e1aa27bd56d81c07b772b697fb921ef7d8a372dd6438cc7bf1b93e0ae466906c6719742e08fc56853509b9b65d1f73111b714116a9cd553f12367ffb02a428ff6371d8f0babcfbb25f86cf18479b14fc51c702d45d23a1411b0852cc6daf8e00f1d85dcbcdf194181ce2caa712dd64ed7ac443413f427c1b018820b4c7b1510e0f56715ed3899cd01ae02858296ebf2efcea96401d78344e87e10903794a309d726aa41aa8e519b6592e63edd7550fd19f69a9570a763a2ba641d737d4b44b6efaafcfdc54b99f70593e92a2d1e43eb5793f2c1472a46700fd1fb5056601a42fe015f2dba508de838ef30b56bc679676dca1cfdb00ed2afe8f4d732410a36b032bfbc0e9f7304e6ece01e003127002fcd7e11d2ea521334e1ad4cda1e023a1072af667262bd11b3e6c35d87984e6fc942474fd4cdd9f501deb65a385d193e806ae457c9861f95fab5ca532d7144c3a4828d6d71ed48f456d94f75b68929c5ec5db76cba49518a660ce2f7b556ae12164af11186cce01be8c6c8d27eac0443583f6ae7216fb4ad013a756849f68936f9e8fb4353e38b3e081d5832c1b0a04f93c85ca76706de95fb2cb531f60855a85887c4c9b7cbca77afcabc1eb0c8b7a9bd53c8147cd9cdb98aafedb82f2e62994cfba030e18b2d05280c621fa891948510c73bb7b174136785f66b94076fbeb971387b2242aed8529b0c12a7a51def0b0b175e8eecc676ec79f4dba5ac1a3fc2cf8dfc226a79345a2cebff7fff20a98b9c11ce86d4532fcd421a03ac0f8ed76a6c705c99f6140fe311287f554bc8c92ba277f0140d36dc3a0d201544906bcce18d30d6e4027b1dd10e705ff7f6f777238f3dd524e6e1f1743185e825dcacb6dc7274f25a091e6272eb9d528afbb594029bea7dffcffda47fabff1314319b24da59af93e7d502d17939a54f183589d5c4897c13ce7515fc6efc5fef5f5a9dd9de78f6827e9705634aae948a875520e37d7295c08759e298d2ea7b2d3b9aec676d6de49ac3a2e6f65f9e061bc6ac3a18348d2a900a3f67939ed49bf1cd9655fef3d68c4fe006a0fc7297054513ea7ec41c26137e05a33a950263e70af40c67c2478d61b33e5a1a5d0d785cd4c31714668e8bee8314356c498c263f8bdee2e94094abd445631e36e7ba9f2b76098768c0a32963bd0c69e6e08fa855aeeb810ebfcaa796d0755359dcd3898cf2973a73199f68ff6adeee89f937a6cf792a1b3b9e7de4d9e03e89b3c37eb07a1150cb57056c4cb90b5b60571751e3729396c330185164ad9527acb7f6e742819795c2353f006c32fef907ecb4f26985d8bc08cda8ea334a759bb3f8dbfb0272ea428440a8f4b8074ea66963e9d7563188030d01b7b50a98c2e6c4f3778483e48e1f6e7a600080ccd04571e0315e930b215f7ff69ad3ba6163e05bd174f7cdf8ddf7d3c0a5aa42510d895f7686fcca83caa08f425e1b11b102f65339dd1ee26c7f2d0ceee5f6fee7301a49143d9ce228c94872d66cda0db6567d5c674f96a940ce22cd33671da2388a4cc973c9daacb79ea97d45ea5cf4e27ea1ad772e8cf3104ecbcdbe3e9bfdc939c117d8c05fa4e2e0225e0ed6f2ed944a641e7fe37bb011d121275aa699dea8d8970151b2c8ac21f12f5e61bd439f6e1ef7f4cfdef97b46d85c03b7851c565aaf4c8525a59718b7e9aaf2904caa60bdcef1e07c6dbf48656514164fa536e65aca190925e5682a96b7543a0ec148ed9dd4879d44142779de3280081dd5ab8de408793815b443de10787865bc7e479df7aeaf8ef8a1bc60d0b25be0d06e7a337dae5b4d909fd951afc8cec3699021bec10c150248dcad2c9064154698a3eb665dbd7559212327b0666e7ad5075cd19e7b9540e80cdce5a1b84706ed57a55ddadf71931ed15f5109dfb6a1d79c1e070c927b14f09e1cf098a4326bb299d7ddd3b3cdc87ab957567e6c96ba718996fd1c1377d69529165ceb8aea8e732bf3a86a55f7279e25c449101a986b87a312f8d84eb825a025e9f66aaa8b4278303ae67b349d5e05f76c6cfe4e0efb6c1120d953f5fd90a77bb23ebe5f0a47f611cdf71f83558a33a6a973770e0840e01356db2c36a1a06f2b1e00f8b7e6d44df08c6fdb1c1535faad069092c8b6c823126fc3b0bb0b2804f1e92479ed2b1df02ef2c2ed3966913a21d64e02a4f651386d7878585d8f97344fc879bd10bd47f20eca0576c576ddc4ea0e8a996ac79211be1cdb8bbef00b6e4beb3b86369253d219f0bed68ab761aa1464f0a91d52f5953b34087429fb6c09fd6c434a11b9946a0f88ae472299c4132c046429823a22b7b7db939e16338302175b5041e1095562ff4a9f304119e02ba1adc7c8f43aa171c8cb48b5f742563164a1874cb425969ecd8c942c58921af0be086103f1a0128e57d0e78d0a8ecc844bb752ad2d4f676c6a811c44eef2a7ef31ff2072c7927137f2890326edc3962417e36ea203f65b0e67e803ddecf765170d745e8e1ff2f5d3fe89ff004636a01efc4559556a491d7444946012d7446cc851fc44ad731a5f349a8cc6af37f06b3730aaa2e6a6bafca6436f453e244a68b6d3cd876a4a9d0a5ffd145afef53df84bf1968cc80f8f201479584772acdd20751066fc6eba90a718b7fb11d7b4702a7cec69cb6d62569c09576b52b07032782bd49115d1058a58449df515c6883970ffcd583b965e1b89adc66b740e6dad25205365f86371bd976e3a2281fd5f1f3bbd6a1c3445ad95f89d4d167e4315a6f3c109e15e34dd4d27f429c9bc899c34097680341e357189876722dcf4c1a5db4947f508935bdbcc2b8186b6f1756a83258db5ad26530e7454dfd643335c29e8ee639c11ca6aede4107bf8d92d937b0270dae0ca79b39cb1934f0057157eead51c06576d4b8cc677be81332a0a7ae503bef06ca7f680bc8a1090bdce869bd97147526dce1c89413b2d3bbe449336e96e42fec0bdbeb24de49fc1e3a037562610cee293ab4052e07741ef6a99a6e09a9b1562d45121192f408e2c306572fc153525e1c646886bf3c1cf7a60ed2303a43605332febbfb937b06a9e4d00ba40b87644e752e2dc106e61faa129478893bf2aa0d209b854c856fdff97a8ca72bae274a2c50a3a85d78b34f67acb31c4d46795c29438e4ac63cadc59e1ebc6fddf57b4cefdf28e0357457a4f23d1129cf76a7b4f8537f237920ecbc13cb2db2020e09ef1b9e0abf3155eab7f8ec9ac35cf0bce44d8467c2043576142b7df2299cd02b2c4013d88f40cd1098e9c6781d9d4b516f8d0fb2c28448d02e6c76906d9a432b3177508abb43e427f6d5606e513d4dc2f1229b14571117da97a3cbdc3369ef941cebadbbbb2628209dc1d87e36c83229c18e8670bfb7f1df0a87b6bbd39a5bc70cc5383e7ef5053dc660072228b388361033713b1f5d3060112c755cc0afde006ea59394b88e36f62a556389eeebbd85bb4d0b07f0438341d34696213166cf2ce43ab073e24442fbbd882f359e17bba42d0b520ca6dbc95c607ac8b69fe8e0c62f701e69342840925e19f5041e98a2e0edb430446487aac0db11786f02e65439b52c3799d4cbd5c0e695ff7c7ee7123d7cf2eac5eca0aa30a84ae8e346206720601a52670cefcc8f44639586e3bdbcb74a208d4dc05fda025800f30a31dd779dd97ddafcc2f56880f3111725c7810d7e52cc497b8a6e49bbf270ce4cef79847e573aebb38d6b1cdb7d5f6e55c029e995fff74eef5347bc58d3dbe28a96564dc45be8e17e6967afc2144ae8b187c72a78737e5807117ed0c832baeea4d0d50b8f7b9cff8f683b29a64efef8d57b772ef0d260e192d60fc61c07c3776e0e34d0c1e4db704f7ec695880086407f9fca229d83f68fef3b8f9858e1c77555ad7eef190ddfe04deb6a75368f44e6069cdd8f601f00d45576f368d78c1210355c050f93b5baf3b3c1eb50e17cb426a13930b4400a14fdb724e03e4935fde47ad1d93bf396784dd177fffe41ec2cfd92e8a33c6cc35bd413939542705b04963812a63bfaba0f29f06016654f52f760fba171b7446698beeb6ce3b1413989c9c9daa2c640979ae660bf17ba6f1a93bb081669950b7fb063a8d81a581f6c96accbb6cc0a13f745eea91c72c181d22e23fef9a6c307b829e7e0368190e598aa0cc24d5eaec70f12b9e792bcfef714e3105a06cc44ca3cb99f01e108ec4370021e95154191d44745bdbcaad1dc46489e0aaa5d15afee3be664106fc059c8e1d31ab63bae289e9c7ef030bb9018a50db5d3ff1638e50de6d23ca4849b26dcb16defd9c39812abe32a1d7fcee9380fde982edea1b97b8ad9045e176c8062b25538aea798998d05837a4f725b8786cad1c897ef158ce2151dfdd9e0c69e06953070ea26624e7e2297cc5b10d818188e5d915b95d73848d011259d8b2b5fffdaea0b35e53eff303f70748978524638aa4eaf086feb7525870630d671b40645b5f13ee1238382d68944fd67672ac8aadcdf5d85ca41e5114aff1602482fdc4e183f1296f63b047fe8ffa07438a0b58ecef9a0a273491c1da11cee3b5f30ea9cefb6ef3001f9d0a40e5f8ac87382d7bd522ece984e676ac37f0ce9566b81fff4f9db0f2655bdc7f7d326628e2050b07e250ed52fe3682a5468d317f540af6159db27f9ece5c489b4830a30064ed47a994979bff18df8fcd35f3110190f4a0ce61796689b3ab812f3455d2b843457172e72dc0ea9222ce39ac418d59d0f6eb12084b2c6261c672bd37ea77aeabe029094949a9dd289f93ee33cf5358f79aa81d6681f37c2b3eb6ca01db09b19eb4e963e1e8f77262d2e14eacb2f155336588a7a535c6898757f506b5895e3b03e2659e4324fa368d2340582218ba2d6c2560d61ea5325ed40ecc90621116ac03dc5fa4015dc3fa316e8cc8415e44f37db52917f0727e39990849707d07277e6f77b077eb2941975ae3d2b11c870815281ad952ab2f5b73a500460f08c6f13f6b0c353f00b4db703133ad0f4ba3e8193bef792fe1163b82bb9e2cfdce2ab4e3d8005e9e4dfe7bfedfde0898751d100d14a7c4de55fe4507278d62bc733106c45591347e41a5fc53eddf0ce690be90aff88fda08d5824668a61596fb2a1de5935468b17b1eeb57a41477b500d21bebb5a28bb2b2d13e93ebb5ffd15dfcee1824a3efe2d47b55eafec48dc65792a26c1e0e3a77060497a6b8a52bbde472d55cbf4305115165e824f413ac1aca14b0563558c727f4530713e15653a77e77f3f58edd764289e9c1fdade872c85cd9d227ad8ea1ee4d65ca044470c863f03d10e6c6ea17cbf54c12d413b78f38d89c78ccdb77e5b8044ead67f6545cd09d27eed0b26f6e4840c8ebb713f6523c9d7bdf4a9c12a5ad516300738bd3e2062f2a889b0c4fd8fc71659c70f5bb19ce1a6154e9d865ccb3dc3d0f72ca776ccb7cad45962ac4ebe774c0f00c88e093b2b6e5b0701cd84cc07087faa0defe3b6d0a1ef84e511f63d16c941461d5711fd2e17d74df9d159aa63e3832bea162f824533f98b412618e05af7e67ba9e30ec2c109f8c5aca5a9fc9f729a9d228bedd1d171d85e3df37c5b53af0875574cacb4cc4e9613e65768f0ae770e4ab49dc7978cc466e0ef29d7863598cff638499e1687048130ac6ae5bf9cefe8ec68765c5667f4e297df3e0564abe55d55d2294cc723d451f136ed5e6ee427a89bb4df0dd09a9f9cc04c3fa869c4b88b9fc5489a9e8a4d3f1ce7aebf564f873e2b65ef354fb8f64c2dd2d86e6d75d823c255837dae44a5a2501bdaad479ff0d1833cd3c753c67513b4b76675b6776d4a64aa76a49f57d5c49c9b0a916f40b9fbdc1b79d61d24d6f8a7fd8e3a48da0fa89730cd2c46a721d0316afa179e87da388a537f269f7f0879b5ed16e5caaee0164ba40bc64b62da5bf55fa25c52a36b2a50f55cb5d1e906e449f29cdc43b9fe9e47faaaaa746c54138e4c7109e88db9cfdeeed8fbcdfdbc0eb3eef4a8d4737da890495e5924bd2f45e307e736695e5f1f13a1587181dc8254a26923fb5e35f70ccc831872e9041583ca7b8fb871e452511689672fd8c5dd5ae35de419d8de900e69e104daf0439d4617d676c0c4ba88b1df4e23e0bf01f24b20b1202860e524c6b5b77061628d1e7db32dd68d0352900e6ea469d21d0256b133c565c108a9b17456380a03e8518de8519d9e01bb897695b4a75721653713366bad92490eaf22caaea514cb87d10239fda325249db6456218972cdf5bb8e5ea2aef4406827118c0bb7f7d382e9e8a4683fd846d348170207b5852f077fb1fd2485c4f7f66bd1c8f74390af2fa7ef82a93350c7182325fe7ff8d52078c7ccf616b96c59f1d570082ced267266b0e466e1909f90fb24e906a916bbedb941f11500b30684d6e32456fb07691fc32b7173cce2d27d26a8579d8102e352e4b7aa081c855a76de2557bf0d26c4d208fb82d2a0c9cc993635be060def4c96e52b842c34446886ceb1c976c6322755eb2730f2b7d014749ef770907b5baf1b7c0b83028af91448364b0368c3966d0e9c397d4a1709bb69ad8d0eafca005bc0527bce132d3f185e9bbf467bd7ea989291e439df018599f574197a6972d01122675e6cb9cf377c981392b5bd6d10deb196176d77fe0e48f987d83e0a5e9ac9144122007b5db08d3ffc7e82300bc238f938328459f72c36431f2be800c52acbe87b8671f70600316a6425f6ccfe1947c2a70a16da7d882d1a2cf8ae5cd9d2b8a70df5ccbbb70a142eb24b0c870184aa2f517aea41be4d0b8edfa8e925399303ae4eee60284cbdef53653e56f9871413e82ca8e8aaf83630a8478817043b66b370dc3d326629a9edcc5d51d8623529b3d373d71a70e6aa8336e75f5ddee17faeeccd6fa576441e9c02c237fdd17143f0449607bddc4d2bec0a798df2c00f62d2679f376709051206c8e2b6fb6a0ce4a8c6ac1781525cb2d6828cc90352d195cedcd48df407d39869956218628eefc75359a95b1712a63d2f16876aadac2f770ca84f1b8eff54c568ff05da3d1bdb8816032267336a12c23544f5dc47579a4aa1b2e48b6778a28edab7393055be512307c02fd97885bcdde8f50ed8a0932b30aefa1b043a273629f82f0cdcdd1c760bf1048a6e12fd5a48490d5987a1cc5e3adbc27aa388b7643710ff3be738a0feaf6fb6618c59d54148c2fde00b3b8da33afef5c0a9d597785be8ddc36a3c8fb4a4d0d496fad65c4c9f92dc456ae2bc6f9c43096bcc0882fea48d8d64842f9ef65c03e1ab0015f3fd7d9c1768911e82381156338472077d3a5c87658cafad1b5f9e59b9a9cf302370a91f3a91be90094f45316584aca4ca1379c621adb350eb61b83473a65b966b404796486fb7d81a871fa7b7353c1bf0b4e409b1643998d2b94b4ce509678b480fb05c6e752768711d3f292b3caa580bc12b08ddbe10a9a8a16d81c1da77e51deee02961f47076a2850739fae3399d5eac51219a6f8b46e9715b0475d10014fd0b34905ac4a1d185e496f0932429f6335fcdd5763431ad984353cc9bcbfca6ecd4bf8a8282da4af8e215b2e76aa7a4ec5c715f03c06d6fe006dc5f0666fb4cdd1eb563b727892ede65a0516a27efce2dd6f4cc4db47beaccdc46304c17073faa29ee22968c4e0bba5f874b7158b6440485e0bb56fbb05b7fc7499464996d04d2b4b0cc93a96037dea8325b279b2e72ae6b2e40848927206c1c0b3898c812c5f8124969d65fafb1f51f76bfae5aa560aa2181eec292b707bf281808150d29c9652ed6fb4941ab702a4387a7767d37d5943853f10ad6e669637d2516a91a63f3730cd8d5adf197a988db75b935a0e75b1689ab297c488f407403b96b3d864b7fcaed7a505f74530e6ae8e043548ad5b748110a7208876bfe4a9dce48a646147bf1d5086665fbd3996e5ee0e72ed1596fba5dce6eee037c411f445cf805258e544671e53c2d11c2d01ee800bd5592bbce6811d0594bb9de5374a4ad772eefea47a3e1d912f8c59fca12629a30ccb2ee2b98fa034dabd2333224f3bd6c28442bc14b73beb819d6ef1974e6b67115cbf23ead8c2e5a2f11df1b1af6bcbb967cacdd970f819b28de76141e2481d8ff360aac06c6b4effda00837887270db18586124d584183ba4a66fd28ce63e9fb2b1c9939591aa18baf0962c3945e5eb1b92473cd229ab5d91b3fdac2902961bfd8400b59c1adf7af5342ffcd7e70df055e8aa72f63e2f9f221c1551196ba712394553e448cd2d1a482da3b3e0b5efe7ba855549dfc86fb18c4246b0b446fde50152b6ef2445bb24e9034f60df42a0289cfa90e52a743983624b9694a42914b38c89771020423d853d1f38dfdd2cf9b168f4e8bd8d13b5416b1b7b13237e7dc8754cb95d8fb8ed955f66b8713eda983078cc78f9eb4a5d816f2c6f34a4b356d1aabfe88e27d3638da350ec0aa2297803d47c6fd65acbc5167fe5d4f5fda5f7c9937fe85a825f8e6ce9aa0b8fa7ea81b6f88b8a9e2c287da96f57538008ce51a89c0d6521164e4973578ed738862262d59d9d5a420b559131e538b23f31c6581ae777e843d048bfb382d6b5af5d08931d38830d1286f560bbe57456d135430e4886dd2065bb019aff3c87dad96131c911bd61c6167d38963c6d4ca9e2bcd5474661fd5f1e03df7b9047a7575b6070ebeed7ae5fc131e4632ae6c94fbd3c982ded01a694b22085592429a690693fb2c42c289702a08ea34a372142fa22c722befd56fff227ef18a22e6ddf932dadc5f46751de7eeb1d45619e2ff5d85580120d91174649e1d7e79db8aa2b623e4d725f8923dd30ccd66d0021ebb9630c4c769b0056bc9371d45e614b88c871a342e8d691d0a5be836d97376e16e743881a8ade7ad0284685249cde6df3d97169b81567b7ec07e65fc72c284c96b228548b1fa3bb382169c6ce3c949b275d7049d3b4dd0a02440a7d386fd74eb3ac840d6c614c10511531b1d446f23c93ff01ccc3077e6c95ba738a43a2f59bcfbb96af58594fcc765398d0025c2136a504bd51a4f7010b238fdfc90eaf15d567a9bf4b58d2a148010d832b4c3b003f827cc1082d3a9aeb3cf217d8dc1c321c1bca6269ddb7317c91053ea5fc18bee2e50bae49987b2510b9b2938354943e5c9e8aef9549a779319a5590134455655bb09e1ea09c0a69c38723b27f5f5de442dab447b4f12f48b5d3be91e06a1cbcac565e969ddc202531094303cfbc1e2cf721622afc77d8746365731d5f11edb7e442c31d5708ee83e5080024b38eafb3dab797172b6e134833159a7e8a4313ca5d396d61f5a8bdb2477689dc32ef3bb1333cfde58d7c143beaa0d44d34917089797a9e97a465d1930f83362b653a5fb665880cd344ce5ff0fb2a389d8da07c829aa157b68402e1aeac1b1b0fa6eb0cf096d1f2279b4a9a1d3663b9ba8b07a93f22ed2d294baa952f1ccb3225fc7e49cff53eed689f26aa8578ff9b6c821acaaffcef9425dde8a52d113aa445d0baf5fb252819c94da666a20656db822d1f83194108711f015a6acb7c1cd0c75d106f2b84d48f9112df85be2dde37d945de3b741b1518ac7620a22a7a6c0470989d8055c90c385672f0aa13e36c3b5da3a6776e8c0a7449e6f8c78833f9577a4dd1940b066a5d642d18ebf933331177f86c753eebf8b58fabc735e9d5e371c14f25d177836df319d213905df0f2561cfcaf6459416e76a248b360ffdfc8d801f0fa35aa136ee55876abd285af235f934b628a018a60ba3dc8bab9b2446a8faf0a40a3f8420251cbc877e941be3cf04d4955902750f542d1589bee6e5739a42ad1ba54e787cda2f9c502e459b14ee80ff306eac2ca2e9ce2b1b3f1cb53ac802dc3cc2c72052c5fceef06d0676ffb1d625878a114a444056b20f9fcc830c4e085278178a73355a60736cf5b36e44f2dfd638d6c766ebed641dced18042f347f8154d43c3fd88a83020aa5e7bc07645ce2e77448180cc58ec8151893a47f46317bafaafe169faab252b20bbaf40b0895b1468d0114816d4bbc79c18bb359cb04430bf97d6b253970b0cd3a739c34510afb04cb60f000bb1a04cff61a4cbd44a5a05672747689aaa420c467681067462154a42ed1365569ae728ac6cce2fb6c84ada25336eed68cd9a0453eb6dc0a0037c55ba31e7c6bb2af6249e8a96f237c8c63e0ec738a938e95888ae58c62bfada529646457bf44d4b3f8167e43f61bbe4e5043e1b19a1015d3dc371fbe8437c2ed0379b9aabfd792c451dbe865a2c77c54d6178112852fbfa8431f6fe3a825d5f904efea29242ba3c8778f01279f9de9cae177fc341c7b7fc496120d8ece05f0ff740f5a3979cf74d4ca5db8ef5a53166c3cab7deceb203bfbcaefe9973f67b991772a6f8966debcb7c46af6c100ad5a38e37286204b78bb046dbb8dac3121e938ed0c095371c75849d936b1d499d16069dc239f02ee23942951b527380a368a875ba9e826aaa852dd00633d9dfb718cae3d74a089870cdcbec99528f42c2e6a60966d210ae64b58fd5690f99b4d9f0e39cf64e0c2455fc1f9deda081f28048576832074cc64e7958e4478670c4d0a451c0eddf366c29a9feac11dea19c66b506f4934202f6988cc2dc0b0d2ed4a3dd2fca8b97a22294575e9a41d40b8590f1e7a496387f3cc351ee4635bed69cef28a6520001f79d4ea19f167833df776ecca2c357035c645bdc378cb579c412c066cf2229995731fd725206888d54c74e846684e5882612e29a2b273b5ca810452fff7dd9142932bdf773b7129d6597c6e9c521da0b917f5b7aafa1ad0fbba40c44429564fd869606769a6530b21f46b3147f9ef7101c3058423a09c2d59f02d8b1ec3ad6bdf1304a835deab162d1e930af64db701328b1124943223704290a3497d611f53e3585af309a2af3e02d2fa429ff674332ca7713a3df9b82ec1114d34ed61c58add83591c2a8cb3e349f4b2ce1981b96b5f8d7680b0ed7fc3663faeba34ace8cc105d7821654a5868d4893f367757607f471552ec8ba70c65d3dde864e22d447474d6ae67f8f187d55f2a602f8bfc3eafbd114d4708f90458838140c5215fb2156b82cac5448c5ccd69de0621ea0bca2392ad380f99b36be37184b5931d357a4188162813ddf1391dbb611f11815cb898af7ae43c41b62244a0c14ec2dc4e8ed19e7e6ece41ac91568714609c23127365950596771c8d0c3a763b83e7ba00660dd411aeb9990346effee672ff543b0e229fb8b565665b47a1fe1c5b32b258dc4c99f1b014483c9cf3dc717585839684433b35a7763d2150e861538d62be7b9b03b79df93ef18ff079dd44f46aa4ecd5faab433ab151f80b753757ce23c4e016c2e49435420a203649e639b70a1431bc3eb5bf4c3943534054c402e182777eba668d198cb07039914c953a5075d736f2ea928d48b04ba2a1d273a7235c9962f87f364c334aae9b425335ed722e0f56a5d0c6deb8e7bd9cbfd2883df8f8956ddf6df670df07e677efece0cac5eb036ed3cda0d7a8c0e4dd9a0d620d47213255c3cf982aace334c7587621a97b87a96955cb903478fcb0a6a1b7e35469c6a58ad4d62ef45cb89da4cb43bd6ab5ff9e586f39c58b2d65fc149eca94efd633be23845de1b6796ec2f3864f31ddb5b6ac3f31b818b27dc6fed3553d9444639c2fb6cee0792c11eb8a2d80e2e3e891ab861df9849726e98e5e12c0a770433c6892ee22fe437e989de47d535231ff074362fdaba65d8516cb71a73914b545da1a145c815fa8bfbd1366f09016bc6150e72769e2f1ffebd2e0fc58e555d5e6edf43f56d3841eb19936b14b8b97373c8866ae98ddf246aeb10181d803f6412017f880df23a94c646fa54a11ea2f9df6406940bb30f7abf82bd4b255fd7e5f3dcc734f5faece31709476d208d11e38a43809dce8ae998323096ca78941a497f6ed6a21299ff2df6034ebac1971ba33f199d7477c13fae4f4c30623d47e2f1e7cddba6782d1d462994369bc15f1a84c61f4e751ac97ff137071872498c62dca49056956f0ef854e42baa7dcfecf4c0d46ac478191a437bc2b4623cc54185784ff305dacb476a817ea53255ad67a63831c9a80181ccf04e3b9ffd107aa8ac77f51863096e9d5cb864f4dfee4d50f788b1a408af09683ea655db285cd2d0985aec13fd67c3697937f53df7169825a8d7d9523aa06b39ff1c0b9a6b380c4a370bd04741398120fc4c66cf1350696b1f0b97148b1dd120c153730cf088a07a8f7188abf2f60ebeb31ee699e910297c5a0674ef661fbc8204ba212e9d407f384b239cc3fc494139aa9185fcce199b00949543d77adc57a5e28c1f4f0df61fdd5b0233eba41dbace25a037f8aec7b5b4742de7a1c58592721b41cb3ce221eca77af3dd9fa527aa5f10aee9832d6255e3809adb1819b3b86c58cecdacd71e81c2bed87578ec69e964cfc473463232a85f633ca10366ca62aaad8077fde2f3df14cf5148e983679f3fca8d0fe78e1d1b354ce2d18a7101199cf0d39629ad53e1f18e1c6f69d4109645ea4e49c38f429c744575477821b1da9660848dac55b341c6a289ec00ad983bda9231a29b84208954c7f3c045f8241d4f2a70e3528695152b60ba8a377ce68c97293974144eb5d09da42e24d8d06e4983b0d0c564598da51747ff15143feb58c667add3fff66dfdc9eba0efda770785269e9475619d3e9cd82505bd983397f28587019126d7fe14d277a6e9ac62ef0e685c947ade3f67d185ae5ae23d3b2670af5a4f7b5c9ff1b56a5fc9290616a2b4546ba002cbfc4ed7f5769aa31e2fa770a8d09b986e805273b5c7eeff20195a88b8d3abcbe9c02f9bc4baedefc7c9e5cc0d09e0ba08f214fe87dd192439c3ad64f35258b4d8d4092a37dc9df988bdfe05f3a5556cb6ccfb61c500e58788960272e84de0a2bb3656eef52e296bf70ad56eb3a3881d64b67ab58a05c3f02b6987a05e7b34ebce3e010f41b2de7f54f887e8b819e4c60b568c22151edb749da78a862356f67ae3306b659b93b5ce47c1521288227ee86f2ca23b3178140d2ae245715494619e41a256769d43a660fc54d34837a3e5a87841d55ca7eb64e6f6612fbf7cc839546daed7b53ad9c307f339ba22fd3a2069928136d14f1e15ee654dd42b9a2db4a111b6da75a9960ae16729f6f1af39ef33187ca086541d70e60228c9d3d2b48f5a8efbb961a2ab83bccf3dbcdcc9eaee26fb38dfbcebc540930badb1ca6bdbf71201f452827ff0e64b8c0b03203f59078a116e8cac11b0015bd0c9f0a34320da84a891b253b19d9eada9c6e5aac4f0c1a321850a8c1df3b798b1b26ff0d6a7ccd3e0fb42c9b2ef38df50cd1ec05c7723eb4f367f34174203a4ad30c330c0efec070f90eb2b931d75fefec59783eb7f3a05b9814a5dfdfd385d56fce7e17bbc6b773f6c4359648c730c820db4f46c0fc7b72931f28feed6d65b113d4e056dd58dab233c839af38a1838f443cdd47ffb3c0b4a4285d74b1ca6370727cdc1bef62ad1567676d4edf825801e610f0e28f1bc3664acdf627cb57b6b0d11cafa379864a6432448c3aa54c71b2723e0e2c772d681616b6b0334b515964be58f2b313d890ebeb7fbac3a3aaecd33db64b1d87ca247331f285dea4c8c7adf21c180f2ff1b4d6205b8aae23e663b5e6e22c92e13d76c0e8f70c8138d151d4c08440de273ea709b235cf335dd14213f8e99f61a180f614651fc1f1578f2413a0fb5a7e1f9e257b4310acde4496828f6915778cd8f03a0aeec1b73f25cf434d4ec9eb0cf4400b50eb9603560f1664bf55f54b34ac0a7cb96a381b554f775fd3544b3fa89a4adbca15752de86d3164557780e62620f7e67aee60d90ffd62212d153b9561ee81caf220f7c429ee6ec5e40ed28b25293419573039e105b1b134e00386c2091f4244eda4fb37b071e3d3a037cc3138e0004f32efe1ba2e84c5711d3612976ffc1ffe49ae486818c5751b79f93bbc1db3d81aada4a07f3fe3f82c313a42d85459a9a5c927c01f9aa6e31331b8c4b07171bd065e152ba90ea587905b4b48e44bf50d80438f52e65e2d21cdeea88be53eeed6acd2b51b5b1c16d9c8f1922718d1dfe84b380c7adba825a26954cd4dee3ec811a9c6cebb7b9c7f06c5e4bd81722dc184098526f83508e13ed93153ea2eb3c9bfd645c5e3f65cf1e4f7515990fa75aad009f2e36c6176d5b6cb14f1be7ce685e2c7c41257cf0ea167f912b2d8ff7d47b12db6a8f2868b4916e0b66cbf45f0c7be8565725d6744073b254f7f095542517f5fd840bfec2cfb05ab28811bdaa9d099cacabe89e7e62fae1fdcc6f1fd7712d57f9bbab64d9ac7eca4bb6c8d232d2759c479d545050fec5684eeaa58c9faadfc691df4974d86d324b5b5ada665a5cb64e68ab12a2e7572adac7feb1529f72a717c62f6ebd1e03c6a9943e80366a005a1e7f3d173613e3702173135e3e304194cf2b0d77649d4c1bc1a64479cd40bbeeda8c774ad8419409fede06d18604a5fe4fb19351f9176ca556318f45d9876f6de6557c1944560651c8b897aa8ee55520e3e0e4a080144153dae2931e7d1c792da9e0edb2508108d261d829193c002c47a25a69f779098f0cce7e5e67720c8c009a756a810a42ae8ae062ff24ce5b85844a225d933e0b93da1bc9d0326b952432d127c96b5957b9b753121c1f9fa2bb90aa64938bdfd4371dbf1a3aeb1cde87721d3d598e87852eacb5323c29ba39f67a74543d3d1e49f51b292b21851d796188ceeadf55881b7515ae22ccfd3175d9caeb6d2ba11702ececafdd36ec85023e3b2f6ffd09bb05bbd48bda32157956fdfdb94933749491cb781d3babbcb5ca934dbd710118ebc4e052f8e21c03929ca73b48b104c952991538af884665fea9d9d408c9ca87a50c4e7456768ca424bae882fa4f0077684b772f0bd7005030d940e60ed92bff205a17f8b1cb179d22ccd47ddabc09a114c1c9397cb3f59fe51d0b7c419c7aee65970f4af4730f83431f9d3df45623ec96b4f065081561e9355964c9eb058d992860ab867da6fb55a8c566aab6070a9010d56018b1e6ce421c1ec4389b081e836bd34ff5daee6db8824df9e4afbab42fb57ec4142da038e6acc4b010970ae6b1a50876c093ce9df3fda5f4011e3b739dbad78faad7e4093277d0278df6dd13d186cbb7acc098bb84d8f9c5f29e9c39b0402cd776309c16f95d4854dfb03f2779889d676e9d75dd548135dbe5a4cf3ee9c60acff01f8e43b829dd0f721d866901274cef129366553877cda19709a253ee0779df351409b60df01e1f2ee649b8eb6598e9edefd4f7354356ad4711b9e7bd76ec9ce4587d61d5891154253f71805cafe8407fed47506ec497daa57343dc152d751ea5d0d2ea551dc3d0abf5c2052aad2cae56b54916b46172d8da4e60fb4e5af88deed95aded34b862a5b0f84acfc2b5f07d89ae5ec85f39b18a589c9da152b8f684a6b986afaaa072e80d4eda8b5108242acb869bae027e730daa4bf6472eaa028412a74c5501dcab6b1335762aad22cc2b36f09d394219189a3adec26ed88a00f9752c1683ce01e26ef99c31888a30311c0e6b8186765f2a0ffb533731a5b97f0a245357bb05674f29657c1f7846b8b0c8b4837f49028186a1ef9e668fab674bbef4e8af0c666151950b13a183fa94366fa2b426f049a2ceb53b64ef4db2f98207b53989240871f3e9aa80ed294fe761c5f8c9f2d56c651dea0367a28b5343444b13520a1da24144349f2e314cd9d002ce7cf8bfca4980291c7114b3647d0efd5565017415ca6c67e74f1091bf9a315d922986bd0951be14a4a5c604471fe4c0c27c0a3ea6ad45c0d69baffda0761ab7d18c85750aecd0d9fcd14915315843e1a496350e03e8236d641eed45e1516612bb44a168b3fd9d526a8c2f37d628720e3228587e56617ec47fd999c5341883e27c54c69eeded5c4ee5ddeb1acf6d741cce62a2f231475f7e764b1c360cfc0b81a5c344e937767d74b44dd6b944f81248ce60a931de6a9313ff55739c92ccac954c558d7e82e03525e014d3e14fe0382937acab7f110b56377b8a3d2d542514d51b395ebf67417f9027eda7421da782ab2a79cb3a4353669f25852bca3aa1000138bb94d07f285c1f80b2a7e4f3a62d849f510c39b1da96a12d4660448b30f68ab8814ae5276c3a548204e6cde58816f7bea4dd66374ab8235729106893fcef2a00a0ababa5b8834b12fc7435c7d1521c49c27fd2d3832cf96c8ce00202bf89bbd98a433bd13fd1cce01df65b8b382cf50b6d971e25fd83f69b41bcef5d888e25be56ffd06bf27c6cdf86c08c826b4cc9ecf0db61966fe185c486ccdad02bf0fa261143f6e963de10ce20227bfec4ba8e727356366f6977b30c1f4ec800f458c3aaa8045373451d201a83b09a1308460d9a903c49a220803f0befe6e840afd56d3ddc2638603a270e8bd0bde91bc7556e6feca128724bdca17e7fdac916a115a531e9ee1e0b201869cc1a556850b25d4ba38e2ffc213dc65e697af6ae7b09f0a10a31fb2cd64008db767d05fee2d720b0496990dd0345d519669c265e827b74939845b785ad5306d38199b4a26f063e85ea0cb80cded34cd492bfe8b48264ddfa151847c9bd13564f83d8b223a01370800502ba387e43ee13b76216d031f5f373c5f781f049a8f2d4cb206e4cf3f93012aa0a849c18bac2ac7a6b54aa2d87abe9077d2448ec7bacdf52724895fb0da75d1ec8ba4c2b02cb6091aba44d6f1b72615908fa7ea85163a914e31af9837f9c0f95b9d27fb44731cab24b8c567b74330f80ac3c81b38ab4fd84ac121b87295faedec299926bd26405e391c9b419f64d47780c193ab804d4153b146e243f7142bd4821b31a437bb96903bedaf7a0ec6ddf0f12789c2b47c5fbb483f7cd56a3f85aabb058b5c6a238e28d87f641015c7390ef23f8a2a91ae0158110e8f12a3753c434298b72a4cc49c7776d53766dd961e9ecbc7e1e1e1ba34624fe4a9d2214f803ace7527f5e9a24e9a934fb7f24f63d57fc0ee57c16227330b7840405deacd06ae784035509c0031b897151d5001daa864652d77db806d6983faf74a8f657378ed198ec4e42d6c3c371bfcfb09be799ca61f8dbf23e5534fe827615c21c8a69ea1a3dc7647ec47b17e6efc32f63a0b8f1f2ca09896fee8478f2d86c8f8ab98c59d0685e26e584cba5be820e2d45a9b24369c8732e6841072a57a05382c43d49fa19f87d99b489334f6d451c3504ef1a811956482fe40e29c9f96421f0f9c0ab31de3198e60d649cc0eedc0fd79015ee113d4811fd111fc0b032c4f89599374244b457a7bb8726188c341df63a70ca6cb9c0f8eb4baa8bba767fff92d961110e6cdd57a54356e325539580dd84fdcae79754ef338fdecde4130d42d80e5d2c3886db7976f2f3ed6e05575ce6fb5734413c35febe1a0fb8f6ea89beea5200fb40cc77bfd1b72021e6ca3256bdb8351d1d301a48e201099701c9bb8ef208185f6a0c7cea28bdb50337bc6fede3075581c1a2889a74c1b9db72e3f566e45e27e4c695437f7afea55a555bb618c7d2ebfd7df8678f804fe798663a2d77b95f10d9a3562664c65f67fa566b2fe1502617a05de748d3ef8b989f6d2e7d93835136f0b34c0004ce4b50495c5df83536f1881f74166f8d38b6ca43c984c93de5d5d8dcdd5f68e94c7533bb7efa9150743927df50ca6aae68706cf8896ac933271595c55a6dbaad1d8e2e53e2c646e453b1b8c6a90e2c8c9f7a835c1c2f53a536b4452ab99f061e6bd37cd853533bb81e4389b03a44caccfe7c4f8f97e71baaa8456f7e6623ed095a3a28de19d0ccc35340d57b5f74fcfb90aad398c0968397f182b2fa5763c53b71e4f35082c2354db75100a7439442cbb17d5d8a69d8ca0ae6092fa96fd5a21844bc52083e9889d375e9ef5170feb290c7764444df326cf51f5e01600d248b310220a1f1a1f6ee7e425ec6c2e74ab2012d900bd30730c157bc0a52cbb0a1e59778c42e09858aaa9aaa37bd280d62a03e030bdb7362328ff9592b86d1be095a21747b9bc6d2c9d731b1f32e3beb3aee06edf3b0be9f60eff038ca19018873b90cab806aa174ef84c50be3532c8c0b535fc5c940d42c210a099d81c9b5bb5b298f455ab822af0cf1ebd73e233344870ed2e9fbe97b7564eaa654a6f455de17ea1201b87b1a653508f07efd07f7d6776b5be7845dceaf4948c306bbd4ef39c8b2eee4def4ba9d462d5595530c7fce55849d25fe31d713b9bfb252cfcfe22714dab3ccf55cfced9068632f0e6ca40a0f8defa98b3e3782b77e7fad8c67ce4fdfe10a2514c1a2c2ebcd5c390d04ef5819a1d90b0664bc301a36faab782ac044b87ab711d7afbd25f579d7c27f6375f2f078905ca18ef0877933a38e715922fab90de5e1802abe4064f8afb2f942bc9d72c4405524fa535ce61ca860ccc40723ce1e197187dcd5dd614322597794aad45a3f04cea2944405401fc28997029d2d1880185552f3d53e0cd75d919eaeae6604912605d45bbc64f049f47420e47b307dfa43ed3ad26146454093c262e9bdff3c3286d4b41c5cccb2b0479f6350ed5a95b312ea75ca7c60fce2543839f35dffd21ed408a30944ed313ca603fb0986f501ad0d21341468dc4ee7ea78a467f01926c83e46070a800568f306cb47d996cbafc735079274182d51421fb98a58039bc1ab5708eea3fd754b20d3746dfcf5d1948edf44c0a2bc832ad32825c777b5114b20a71653fa1f70e74f8855779f354bfb96cdef5a661b5b21eafb31f2738a1f23c4c1bb1015db2de1d04acdfe0aeddc7a2ffd546389567ae8157d137f996323e7af74c3e64211c3f971de24f4c725c8ae058ecf696a0703a23503a18df6466d20b0e203995d936326df7dd4e152d227bb969c71348d8ee184641f7cbd1817d7602c62ed27f0d3644a27278416d6d186211917c501dff1afbe4765bdb95a29e532204b70ccc6910705c84eca01d19c05760a685c4642aca8c37525e4bf168e90e3865e6cdc4f78acf1f9c74575d37013d52aef3b146a8f642fa46b6cd5d2221036e5ecb1cccc74480fd1bc622bfd3754e76830b26abe573bd59322cf4ab0344047a17913954593fc035cd876e3e561c2862de84a03627ee57701ad535ada3105e1c29b5716e56fc0fd5e1d126e2a59037c9287f08ee0cdbfa5426d9ad9e47fd634501249919f87511e71fd67cc1b837a3b34fa6af0609f7d21bd335fb467a5c74ae027d8963a5c9309c3d82d9d369ae5fd1b1708210b3cc943625df6f063ebbfebef4ceb64b7ca8a6564780c876719f809a0817f13160137f81b98a5e5283c516c0e1f435117f64ec98ecb89548907221e25b66bdec1057efda78a088b93de7d49a3fbd44f450a4b88e4a3137b83a0e00d339cc105acadc669a1bee801685bfd18fc1759825098a5ef40ab4cf26deff03892154b570a83edebae3c955e86532a5ee6afda294663759d8cd9e75f15d60ff23de366f832876933ae6ca4544a0a04dafade26a5c36a549a1be06bbe51a543c24b23903f859bd1b5c08a95f7534234380e7b288c045f399cd8f9c45cc15d9997bd23d2b9bfe24fe36877b7557014b58addebf498d01fee56d3f73327845ed94a0a34fc184324d60814218380d0b7a9be757ad32f446f70cebb0f7974eda49ca83262492ffe815f04eebf690fde74131a60dbad173d74ca0ed203d4c89943efbdfe3e9860297a28286ecd56e1745a75ea0cff84009a08bc7b400856f19ad1df58424e8bab4cfa41385e3c5de3eb9ad53b7ee78b735c6b170ab6827f597136e89a2b7434bca58da9cbb139f7c84c5108be6de79403d7c7da0906dda07b2c9b6aa19b1a6bb6f68c051a1f7d5727ec94537a33f7b19ac87c59fc4358f0978b8ebea06061e62998bb388dfaa5dea434d1e6327b5203057a0919be9f3915f80871c6d820965356d7cfffa0b884c761d935ec69247f7e4f7fe5e23bb1d0af527e74e5001d2c2203f963a8ae425ff6d57076c7fad3ad4b07fe29ccc8bd4a3e23441fa13a9e7bf136168ce28deecfe85bf480c334ee34cdab7743ba3ba10558cce9d0bf8b35c2fc6c714c4cc7beab81b8c4e26edd27819d3e3beb3263e0534341ce362499173d9999e4f75b30d42aba58d277d162e969513e668984752241955990583be0dff8a25dad1ef21e11458370e644c5e31eff301478b752cd3578b52d3e7bc5f4512e93e469d6b9799420adfa8de9cc4a4b965a8a0dc90fa4adbad1794f99e3f641592700bc08b7493d20aceeb979139ba97e7bf0b17310a8624ce95b35aefa5afceb9c863bd23168bba55146f4bb54cfb61a82f2afde11c83bae60a9a98ac5cf4c894d9d7adf26d1d78414249f0f5cd8c4d0254f5c8f4e04204012568b7aa6eec80f11d725854c013d77d512c7799b32fdfc04641c059e274ca4989e3b4aa3a711c6fb1c6de2783975ba2f338b752efd0e16fa8e2b65c5e59873ebbfe74ab878bcd2ade3638f58dc7c9c096b3c6dd3da0bf1116909dbcca0dab50fc23787c37147ef9c0b11e15729baba0250b1e8474b47f0476d015ef93aa1ea7e2e4bd59385230d7454227690ec8f9784990e89d544ed8e598ff0b1e30c960e9f27ce798cb30ee9fbc32328ab4ed4826c9095e443503a63df5127c28c438a66d30d6c16b8ecc3472516a8b231eaa814b2a29fc6197d1a103c12b037db8f93374f861013d034e6b51285cca6e7f51b1370f8e407fe24d4ca59e37a12386d5d466af4448e292c6809c08243de49d4e6281e60e952e12b7525c989c181e92fb13d68c470608de609d337f85b3357e93378f189512b3696ebaf391de4c9f5550fd0ae03721c080be8d11164f23c8a57cc20041ed48b4fc15864de0f29a61f368fe1c25dcd58c9375bd1b8bba8a5ede53090c760369ce23ea2f471ce829002db8079a9f38e7764517f70635ca546c0ad81c32e4c515bfccbf83f3aacb9e9c43c9b349197444fe4430f340986ca373eb6e5e603856fa9a4bf3fa0086ffa17ce7293ca0300fff678e7f9690dc635d9e66729f918cb5c85ad4e4fa46b58eed8203e3bc18c15a518e50c9ad8b77a826831171ca2701d9eaed220b412e625bb8d587c46dc2b74a6145556379dd3e86d30c5693b37f7cc22dd2594c86879c8a2f0ca22fb866031f1e3cdb2858a0017276d1ba262a6654d9826b77a22c8d9c2092852bfd09964d4621d5f0b9294430fa7435cf9cc2f51d50fb02e31b9368cfa608c1430ddfef7857e2cc16a05b0c03911e8d19398d123c21640544b41e540d0639c992b5bab03367fd38f8c9ca1ef0bf51ab51ad272e1bb9ae8d1ac1afa32c147e274f5f6245b6d69d4f525ce63a7efc4debee06899bc63b8638fef42625965c7ee183be09889f185a33223c3990cceb611a5e86c0c50f65625d2e6a2a454ba854df58890303b30d5089e37c8769e6f047f1074002539a6d15f88fc32fa494dec54487b63e27342e6035afa756f430897bd2c539ce60907d003d4535505dee79abf26280c1a682983dfa9ff5763a7afc23f3ef5d3e34314abad4217ba37bd95228401be4a8bbb5641e4a60e336aa793483b78bc893a13f44dc63333bce997128e5fac2780b4b33b5ac387c79045c97b22dfd3ee5106eb584c986e28243cf4dab7da221319dac6117fef7c8431d39e5774caa09231d90b0aa97527f1f30be54a680f1da032fd41d4424874a7cbd7a51198424d6e719cd1d09a4bc76c0ce9dedc5797526114fcbd8f22032c2f966eb244a61c00c3162703657d429acc96831163ae0c675cd1166c45cdfd4d55e0dd465907c4e1ba21829aed5878df86487aad7205321f5d1422354bc9d8f205b25c6a168b7f5ef14b72f5b34e29db64d95c8e4bb93384e78cacb0ba81a27a6e202bb7c77e50f25a36294cacc924b63d187ad06d649550e899359114220bc7ead7d974d083c7156132785bba55433ab60d4f14d11aca2da17825991e8e81cb9460ed18ae760047a99defc718cbbea92a832894531532b23e267ff2a5ea8c8da68f69dddf22a66c8fe336a54489a8bf8def3437a7a4d539e19a944912de78fa44431ac6fdd8a2f938e61afff3b12fe99739c6cdc5e0a599e7b48056ce2ba9411df8fc346929c7481dcdcb0c722992512b84cad8ea41fb292a51ccce0d3696b9329e72c58a157bbaf0c4edf003ebee18b748942bc73873b16b724e3fa77e74441c079073fa2c36c054f1d1b0c1f0acdbab6068c30c3401a2c458de61fe084cc386f69112cd5c5a72db1700a4110af919595e5ba0b2266a429c6929ef0bc2eb74147de3ab8e987f7082e0545fedb0b4b1285e8ff09ba4890e8f74240935a1bc3fb42284c7296ba5d9f433391bf6c2bd8b8d8af7e0d987d876f6d84502dc30110619b68216b9d7e0a4d0d318cfb64b326a2fc4725f778ea4be784f22e3e06f41bf620e9c40528bfc406900a14d9128b9ac8738cc1df2b066f21a1b84f0fe48066e9dd056b3700a5549e1eb7c88b454541ec6cf0cc1d8611d7b2c4e8198a7c9bbdaacaa77e6c66e88a6cc1249c45657c2f781f82e06381981f14776067a68b282cefe23c0d6ae15dde34aaf7963df8d651629a2db3c42097569735b2d8536c1ec97b8e1d6aaf596d2e1bf47beb14e22fca1afcb4654ca4fec6d5ed47efd96832f6e44068848abe9940ae1ee7f232bdc376b75b89bef6ba94c08ec2873adb1055feab6cb942edbe453e9158bd4287c738c2b17f3e87375e321cab963b5064bd4c56cb13d37af80033adeb9509a92164c02f8f84ca781f489398e92e93c9a5a95def76b0f3d2befc1edd7675d536410564d0b43511f0772b963af03badfeadcb33382b519e43b92740b10a876ec8e7277f0f510d5ef966a725b593f6d89c55b337149bc500ae336ed0753b63d300ceb2deebd2983ec15619498d40684eec6e8d8517a12a7075a0fa5b7f199cd3c1587eea1257d21f9723c1a24d1d6c5c3b9c846c4bd57d59adaa522dd95e5a00874deed55770474fadde8188e61b237bfdcf6c849435b48d10287e2ee09eca66c81c53e2c5d7ba74ee2d7ce91129e189ed4538520fddbb2a32d34194aca9d2b60249374953f3e8225992c032287444f45a6656c7c4ddc103a747520f4da5afa508250ce6b88be01213b568ecb1b4e9bedd852761f914aca39140789aaa595ed8e4f0c9fd0ff135af604184a88f28595630d9122af6781b33e87d3fcee80d4ae3c5dcfb67ab957c41869d51da022d5bdcde363b467f77ca7694c658d385206075eb985bc32f00f3fd5521b1ba61ef62bf9f43201c55e5e8e463b923d0e58d93fdd722360eaaf48b036366266695e894851683364a7cf85e274b21d0c5007e02773f57adb2172c8e2f8504891a412c869ae34bfbce41107fa1da138a365f32256b1d79919cb41cfb6ba3219b0a2ddf5e47c1cc78e2216accbce1b8e839f49922d6bf71d4722ca76db2f1e96bac88f9981cf75974b4488f86bc3bdde046720c2e6171871e68904c5669835be67447bde8d21a91a6e3f3b82dc080a272cfebc4e298b8904eef0601e27f54a2a87dfc4fde66381fc842fcc22db0fa1cba89ea98ba0248c1f2b497a42003638fbfc4ff6f5414eff9267bdfdf93668deb750813bb2c06d4e99c6135333e5586227f1cd6de4d174568557ce70b272a01a67c5f338f70b4e1c1a5610edf47a5577165c2c015e158d2e472cf33c40432f64a960a938f5ff27bae40a55a8eb185d8dfc9df6b5dd2153b352071e6f612211080a18a3094e0f099a108e8af479aebb9d263e71c4bf5a436b77e3682c43a0e54ed46c39014836dce344ddebc8a0189a8b30af15e1b2f40dde13b044ef840c567b68fd2a2227f57ff7fd3804cdaf1d1312cd4f401885c990e12e6509e60445b29c9997f45a4139c75d63a6dc0716faeaae7dcabc153b3caa0cba0f94e93999700344cc99f294ae3691d19e796ebd2fc14ca9e0023033f4f275113897ef3c2287105ceb8aec6f53879b5379c8e3bf9f82d56e87616823620a593837fdc9d916b78fdae3a83ed6a9a8224be2ea81703222d4b52be76aca34f42ca34ace44ee1f14f92c5b135caff7620f17abd52243ec546347e02a7eb6a6657eb5e6f55c93f499ced0db382bf9ae0500fe5e6f2e425f4cd03e359be1c7691aa6ac03044ed79d03a0e0c271eeeebb9eb85685f0b97054ab2be33418223625b116e97eb63e3b1b75d0c1b872042c65084d3dabd02c612bfd2ca7493fc96092372c562b93a36bf8f41c997a791ffce07553dd858a91b6c40871d11aa1b3ae9dcf9edd961c82a9640ee0d253d45350ca8416fcf5ba8d96043e05c96008282e35d10a919c2dd003733734b907f630cff09bea33e34e792ba03a520110a6aadeb94d47a9489022524f895aa5c8e04111e209ec62c81391605ca924452af55024853dc16dc567ec473b3160a8b63c32c028ddb9d8f4e4e3308b1ed92c83c2eb86a15ae506710eb5c6e1f171f5e296b2b61fa2683478419082ba8c5f397a7bb1bc8f0ffaa09c40cc0685fa1f9cdd17e5eb74271d0c6e765a8868228c06c634e673c9b3ce492d97a68caec4ce354a9c664320860e370ed97bb01f3686b8d9442a5668fac49ef1a3cf43201ead6cbcc6994729028ff3d52a26c1ecf73f6e0dc80fb453431ce9b24977b7cc7700d9e66fd25357c208222203db9a01bafc1be377b2abcd2306868cc029abed5b05ff93d023ed5201fb74267b3050fb91ad661caf778979e07572c20dd99f011e75e5e29cb79566f07e900844e1a7e22a9c23ca9bd564b814bdeed30bc7f8b04cb1f5477c6d82ad5f4b1644f6942d3df41ce1bdb3f5990514a9af71160c657890a125c4d0a5657c7c93826509b93de98c3d2360093e903baf03380b1808e2f13ca17f7450fd1f64f766b3b007c7485f79e24299a89db0f60800722b75436fe62d66c727dae84f282853e8a3f674779a94911a43572c276aa804efd22be904a0f7df0b1c83785318a736ddb816fb0d87ce614f0b137c1ea73e03690ba61606bfbcec87687dfb10abacf5fd4ffba7df0cc149f63553e3ef13b5fa10947bf528613fb89f85f60ae2a5016975b572fbc815f884f0bfc766fbfc4024e57d1c8147ac758976c645ff8f56a78796faca9edc20085341474cf6cfd8c64ce86a680a1d9f73a09e03c4457811072e11ab33280b2c6a2ae9cc504b13e102f4b31931cf52531f076e5b8a64455820815942c19fe50d69cc9e97c23cad6e7303e91039e72153c1820a4e62d3c5091e33e247c78aa193269668842ec8a5913f4d2f9330b1993fbde6d843108f255bb7824528c63db657e6064c9d97bb6579fb55c72ac47c89135ab68f8a55d95ac00fa1e7578cc502be2468593d1c146bb699b742ac8efca80ce76ca433888661bb7f2831aad1a7a92c0623225accb64d27354ffbe24dcf948548357240f09c08e34d5e8dcef28bb986bb8e3db6f104836adc14823277933bbe289b3b69af9c76932b48c803f568b0cbca8a37dad10cf71ea204ca4d1385663bc7c9cfd750f739e7535a7e2a538f38b31d4618556a31983b75f60a8486d4e12646bf19ae8ec16ea5f5e6ed3dabcbdbcc7f5988a00a7ac7b2748bb51407136964fd4e3736946fd7d3e1b19b74a5a910676bda4016e31b92b4327332d71277b3f7681259d2536f51599f33c464ea9b47f25b583a1155a3771fa1cd4228fff6a013154192a9933746983bbc1778f02ed57cae9fdba505f0e1889a5753a15815f6ed8d1d6ca11309517d68c3085319013597321b18c4e141cc38fb9c7ddd5de4e4a32e786d0fea541819d412e7a76a32865ac3c5b361e4ed80ad4d318f0f9ee73ced1bf1043eadbf4a21573efa0dfc2fb8c9db9cc43d0b38bbc9077db178914ca0005bb890d412a29170a6b29f7b6158f2c86d633cb5e2a091757759b3d9122cbb9274a6ce328fabcaf87744edf91eb5fae4bb238f6c37a08a2bab17b67424e582e44b930b9bda50015c3a478c4ffe40370ec2316b07e457f4a42e349dbab1c01193dd6cbdcd6553c4ad0f4e8024214d9c9e4b43bdc6e423d0612cb9d027e59f2119a3aae66587b377585eca2790f3b1397b8205db98944c0a599d790a3f8a74fe02fdd1fdf91ca109408bdce7b0026211e13df53dc701edab7e52b5e49585d1b9121f262bcd92b2abb5e6fd0c7351f9e52e0c0fb9c881a373a091ef932413f5a806ad0affab69735e5782b089e152f776a56875d36bbd7bf1c336cb04c99ef611f62f4e49cddae706d6d1015c57519434fe9564d4dad2a7e6fa619cf0653f864ec90c298934ed7ceb86219b9381150a8f93eacb509be0fb1269761bf33907dddaa385107ee1f9a3bd5df6432ca38b8024490e6b5f066bf56804477c3dd11b192b180abbf283734fcbc0d5300614310daf1c3faab9da53c3d55fa88f3be7969a56c4f807f3f3b4e687c407d76f17ab7989cfe5cb1ed0e13a28965b139c0660ff0a8ba0223f8b8579fb54c53c3b5913ff8fa079288f656e10e41976edbd416342dd10bbb80c0adfbbf56ef7870942ead6867de42821d15a8b556d57ea12b949f6c9bd23db918dd9280f1b3ef0b2d780c5163f1ca3bb3999f1b731bc2623d0a131832df4a844d8fbac55f422cb45bff67838fb532b59f71f8851037052c52c47248a170b36f7a28a716ee8f2b4ca9a0085a9762a0edcd0c11fc5260a015c3871f0e0efe72b395ba9bfe19f4b332bcc234a90c2ff1c7315791e5a7a23c4e1c51a3fe675e0f3d398e5e6689591fccab118f393d568c0bae136283ee7e25c2952bb12af48f0f6097e0dd070d183e5d4540d394d2352b5ab430adda47a9775cf39f3523a284136f4f1be9edc67c3098b83a1efaad712d69bf21e9e69b09b2db9451e6768c5352d71b2fa5df6d209caca9129d0a7322c09c0380cf3bbf487cad0e5bcd156244e84ae6147538650d1e47c04d80536bade7ad8db176a8885545f3ec275af94f62bb5e09eeef30caade1d3e375a8e656850daf33fd4d3e77ec73aab638860e0513ccaa47a87ac79e55d42e170caddb6d42648d5d511aec767e9d0f0b9fc28e42f155c581cd0da2ee0d054e36ff2a3042124403b7d2ed83acb382b9c3f049c9e25a8b1f4b8fefcdc9e348cd271c3f2e02c45d6a14cbefa6ee9dab72027e4977faf152d98fbad27eb645033429d4dbf26aa42e160c219edb9c518c2e20edaed9390ae0bc26f17fc4efca2753f16aaa1973ff3756611800a6741b6e5b96bee0eaa1078c6cfd165720150e606e3ef4c885a59f8833b97d5568eadf60020a1a005a8f6378f98c836f0e119e23b7dc9a75370add2a2e693747c9bfaa01f1292222828763c38d8f99c10e9a3c3aa2f3bf32ae5624747fa57eff61ea83c1768be8000852c05bc52d73e3253af129eaf9587a84585e6d1d285e05803419dc58b382397274e85ec00f944a771f0c80325129bc8435f03b8955d5789f6a59bc28f507c98cd58e4ee66920a946a317438d0420a423603a0f4743d03c7c97489caf17bb182ce8a1801eb102bb26842d7aadd86bf80041a925a8903cc3f1ec1c06974db1f28241008f8259ead663a142bdd3fe188f75df57cbd6abccdb3e1cd9fa948bd6fc410e7382767cf4ea1416abe5649a5c3a7b21107f8cfa5334fd30d842a2b3b7e4e984d77ed5cd94595732f1eff7c677290f2efc46303ed7415502eaa9fd6115228bc9d61ee0229a1d74562a51f88310696003b0165ea2855ab6a9b880b2a19a993a9f6677012b32075b27625127c5d3c9c295b84d93f97fc92a5eef1b996028d3ca8eb6eabb335e567bffd222e1d0233d81ec10fcd87f747ad089724b126b9c7f909e4fe0db4e6bd89716c9a8b1fc637f0b9bd6ec3bea7c0bc104b18b9c85382ad58669c0349c82883d18328b8a724c64c2bde49a7a0d44b0599df44e7277b17d85fe83799d118b4a5fb611b722fe4f79f8c1849bdec4c74db716bdbaba1a801a92c277ca3b063fa260cfea7bee2c7d0c54a5f32e871cc0bc4e87a1321307f0259bc92dabf3a433c31670680ae156b3221671253ed5a3ad85faa524027db4a8749060b1ea3d17b1c5bebc520286aa44bae13302a136724eee2b69ec766854a0f703a4c1d6e0c21080fea8d7370cfd3c774114d9286b6ce38b90cd7888ce2a6b198b9c557ede3e174cc9f19ba3c1a52533d40acd5b2817b5ee74fb13c5f74b93a9993961e8073fc451a0e4bd329afea60b473fe8e437c0b48ac89d659874adbc1ec6e75424e3100c407e079527f3588511c13add4bb012a59c828f1a4f1aa1a5ffa1077567c81424470844263223aa73e10b5b3f31fab0082c49042909e4e46be47df11e1fb9c5a35dffae295da2947d033bda8cc58a74cfff7ad63ca88102dd80d5a2a50dfc4af97ce049d01967b567405797ba7daea0474b73cb8bf2ea9c8b646d1fa7b88b32d0c0e5c6d14654b2248fd0e7e71e51add12ef55e09f8f456e4886e8220fbbce7c5b118e1b2d258d59d45f2e1a253fc6227ef60ba3ff43c7433e43220191f2ee143ee8d843a6060070de65d32cb956ea09d6500ea21b9cc55bcd25c6146e2bea19f3fa2917c812343acd3686d2048ad275eca74b5881466c74f311c8951f0c009d3617c9c46e14bf0ec599734a847a9bbe18443f4f0ff639d50a78bfaf8ec9d33410a81291ae11a8c2fe4918268e60a70fa79f9cbd9d318e98ac8b9d3ebdda424c816ce67bc0e1ed098d8a43df6c9b8e0bac3360401b61acfe68604db5d1e684317034b9d2677dff3c482280abcd6b9459204a4ee5176aeb8791c9b1d7845594a4c1ce721a69be5af7f2612f80c4617b9141c571c4466537a7a25c6c0fce838652ca3c0a3f682537a83e01f116deb09a83799381c83a66169f1012aed40c9ba2d15b2ab045617b2a84a6c514f1c7fe588c6eb65bc0956e4c41a048b9fea22a581b4ec63f4c769d31c2749294df3e0568cc34c61a289251aa69b9bae45b2dfd17a5b3ef27ac4106cd8bd83299f249a5d000b8536f57918a5aeff23f56ed7587a6bd86f76c62b4a8ddcd4e3ab87aebed96bfe1026ee5d38cd6fdf7ad8ca3105d778ee8ed32bf812775f31c5c73f2b2d25d485ed587329b87cbdc0d3a58d386b1cb52cc775ff0e55991db488dcc2e32e67ec87f3fb2cf66fedd4ee560b9ce6539fa64471bf014a575f487ef45273294e39c8c6f11c2e1309cfbce929b04e086055ab415e38ab0438cd83ca14dce7ff440dd1e62419e72635408e73defe44362eea8419597f9b30f45056835a67d52f8ee177fb930f8e2a61aa81c9f486f4ffad456244ee4f716287e1632574742a0eb31650aa3f25bcac768af0fb836c273da43bf66fec1c5a78b0c9d254d8383244905724f4bcd540646f0e87fd4be4a7baf1c0c1ef21bd69b92db60f2126b623df5d314d43031f10bb1276caf389ab1a0c858be77808fa192d2b10d1fbbb8d6a84d87574d36ddfed55ec1358d1e02e9316941c3b3b46ea29fe8ae8c627aef54b70ed23505f1aa7700d32b8b5c67ba8a0a354da67cf9b463dc939de1529a294ccf67f2e273123e55a8a736595f4eefb61f076629eaae18bfac333c408c4a3fcfce49265b9c6578a0e73aba86b0a7ae2440e2913083c820fb05479fb311d38fb45349a352a2333237ddcaa363f0167d73bf390c2298b5467bc046d0051cc82661d956254c38c10646298fb97f41e222fe95f41a366922134eeeb8269b38f1503d59cae01244e48dd4909f04b1641abca34c3711a81bbae3283e6cb2dcc9e594748ae97ce1ea5444b5baf05ce19e7447dd08e9832fc71bac86781e6474264b67e3ca6a368ddb4962aef0bde2ec805ff7bcb7748c4a41b3b32dc8c619d34b4a97fcd70a96f65c50c3eeff06881fb41ced8397b4bc40d34394d630dbee05d7ddbe92182aed0cb3f2b43d1c8ca0305b8a422b4f227c120661e83f5e6d518589e47ff6003a84dd906a6cc1e60b8dd05556c589a166d0ea29a474c78b88bd3d2308a07c1fa44be8cb515082c18db9a6fa202a053d8355010ceed43b829e4901dbadc81e7b7d3729ffed5a9b2f0fe85b144ba5e07e6949ee8a78cb81662f4742e7bd914044bfda6275e12bd99e7312b79d2fe7870d926386925a4f75024e8962ec4b6bc10e1751703465613622522075632a7b2e030d06ddcfdfcd5fa9eb4e21b382389406d55e24565be0e88d14ce4b1c7f45ec1390c9b0428076f5b69d0fd3ff17c929e8a344ab23a676a91a5beaa51344923cb48c004e6fd6468a5ec91134524db2eed91c9c92801b41511b20f7cceeb356ec5e2a3b8633e06b62311afe718ee23d5658b0e95f929f744cf26cdc9d98b97ac9c38554213f017fa3609c14a3812d6d45b8621bd6b1ea66ec9d5e7b226a4f2509516a9cd45077388e41df8cb521d0010dde73d41d2b34cc926702b09643208d30edf51c3726005c77a466d634793f8fc2fec0996aa019bd2788cac6a10060cdfa28c155591d05b5c769eaa24221eb28f480d1b74c91c49425f526c5f08d8602f76d125fd9647653caf43f060b011338c6331d2e5b8f30197bbcabc547dd39a06e0fcf8ec873716e412acca7c98b9ffd519576b74f9ae0999fb9d25427be76496f93b8783287776abe04776d21ef8a3c162f98ef055d8673124780ba988b4175aeb5c6dfb1a8a5455da20e2315c214083ac2398ff3bb5f8da520d8f3b47acca7d1f42924855b3bddcf99b2062ce4b07923d6d67fb96aa2d15c10fb963f5f6b69d8b1f489ee855ede19bc35c8ef817ed88dbaf259b6e0385c8cbbb5715e142556b848521d84d0075e78a39edb8ec73ba867eaf05fed8b5b9500a2592c81af946a9ec33f8b382ee16d004300023482a9e1b02eca71c930d3f2ce100d1e7feff53e8cf45b9daa2a86acf07dddf8a6ffbace9a2801b21f27248caba79f2893d6f1bf593bc143e5442a9f1016dac1e128f36b035722882463a1c7509335a0bfbadaace75b3dd693cdce2a100f757d92bbcce9000d9970843053790f97b8806f9cb56a6eaa94583a809a6971cee13a9cafb9ec05cbba7d4b69ef48eab1a5670fefac16c80fbe85347a550fc02d63385b7e0bfcde4f980446cf7632630fb881b4e0250d41bcf498c03962d3eb822ecddc2c98614884f6babe0f32c0cee7264b70154cb83b20588fb417065b2def934a829f8768407228718a0d2e3b151093c08fa0da2f25345dd15f12c1369a0ac5069926a8a83277e8ffdbcecdf18c76e3a72182b9e07a650b5ffef9a5aa582fcbf3f48751f1621653b5acb531c98ace1252d48087dd39497bbbf1956f3514e7639fb722cf5b8672fbbf99a6eba0ad5c09f679f1a86f4773c0c559612cb29db27d532a5bb5b26d3df1e97de3480f5a735edf02f1e459ca589e52e9b8aa7f0cd7d19304a73f3e109fbb01563d52fd85d2cfd7213d20184c62cf6d38e0e922aad281e7996488b3adaf187b064a257deca5bc68b98e71bb06cfdc4d2fccb6e5f2225260c246d5971c2af7c1f081c2056282e30c9ac2a5955e1b244576f66bde09bec2f6d7adce18e11f4a3570fa885457b4fabae55bf9f7539c8196b409cffdf972c07da6f87830d15893f10f38edb7adb6e0ab24fdfcbd3cc840552b63f76016b63edce84bde91b54c6c5e1a1cd27f984eefe71536982b24ae18d9c46b99ab73b03e6cf36525ee26d327b5e0f84b268d70a4f349e8eeca875f82a33ab18dde2ae781ed3f42cacc129ef7ba0d5f2dded05bf4907c50667432406ff57245e16ae445970d4b04e59b49c018ec6533b95fe848a324013b5cfacb5dc6baf5329c6b2cea8a08711735a48020ca813d4beb10730e4d8ff249ee15aafcad82e65dd683a947b7637ed79468569dd8bf073168e38d5f5dca17e3213b3eb3547ca3f6a12200bbbc3ade6dc2a63f4758631bf015c7da54398c28f3276a6d0431e6846f0eebe90c9b39f98948c1892352f97b55ac7d05c999bbee84e7d34d0160b22bedcc4c04ca0bcb431e54bbc1bcf265beb9b9bf8001ada988ef7a7683711337702323edd44f5a9740ccf00a70d50311855fa8ca5dec770cf56b98bf6d3fdbe1f84920c0da7a2392be045223538477dcb8ab16846c85c38b8dd2e17094bf830cb22b4c0313230fb84c70a4b61b8b09477333a1c9a9b13aecdc5b027d81fdbf822ef81a4cce3a941a5d316baeb0f22bc9bfe586e11cadb1f9078c224f47b8076d40daff2e6842f1881d1f380fad7ba19f143081284f8fb287eedbb4011ace93c5db012b8fd9dc267663fe438d4e2a8e8ca965a70b01222edbcb5ce608245828de6eff2ffce572fa2ed293dd321cb14df3e18ba00c256e252611559162745ee045558db386cd45194b62f5e81e4dc6c04ed6be84eef5adadec2e2c827b1f2c53d7b6c2306eb5fc83929bec6d9b06766b18adea6aae00206bd70fce8dd05738ce09eb8bbcccd1fa705f996eb538eea0594866667059fd9d400c51af0b37946f9f1737704991f450ee8378edf71ace0cabd45007b6a4b073f90621dcc671355859ee01df8efa55b1a72c106fbbdc08bdef547230fb40cf225e45cbe97f01d1ac959c9cebf31dcecf66fa1c15a42b54003e0b26251f7e5f8c343854a0a29253931fc18d4af3f70a0ab8100155a4e315fac55b14f7b82120759174a900c7b7c580084e4bb6810f431d6ef03c4f082ca420b16c1d16a6b771aa59672b58c1c77e9416f49b28df7eea366c3732aa99b5df1328288bf9ce258feb61e0f4889ed767f1a5098000dd743f2299122968571f6f09da83f7fda58b7b852b244cdb031ba1d9e4d52cbd17b6b26b1c1db9004c53109e0e49a94261123581c7b03875995d815ce6785e4cb35ae3388e5b8a3aa517f99982ef1c95efebcdae1bb6abc18e6390cfe8bb81d3b6a00f62de1dcf612780d67999fd2216cf1da0246195b3d4b659c9a7f6f663426d1e9103d15f24012437a60ec035379e0df5a9532ed35681d3e8a166c53a1d1a4d404f736cc4753a0e88a2fb2e14f6fc4cc513ae0d00800fe3f65d781bdce2d20d310c00e87e677738fd7cff6f4886dc4ac2fe2b7fffc49f1a6a785c34831a14f2c600dac3c8dd738cef2f2d8b8bdb8190673b99c4027b2d0a6eec999549e8d06e7d7383af1e43abb0d836ff83e487a341c8825dcb75ef4a898437a589a5ea3fb2bf24c3196914c4edf1ff74db5e68af992c932f43793efd25b094f1c3e42f4c237b75a2d41ab0a695f93a5138329ce7f5237526eed54b25b4874fdc394979ff391f146ce0f00677e68561b590d1b5687625407409326aae9055455d0acfe768eed8898f442b3a57144bfa494a8c42a029b4c6fd719de901917d0f3c0c61f448f556f6693f80b1eeaef3d4982a79431595bbe74b8ccf323319369d1bcfc7497f7ec7c1b3cd56e01293ad245902c12eb5c25ec95582bfae6441f97b12c263ab871d95523e653fad0ebd6ee3a3ab3ee2bef761536d19ad25ed5bc40a1aabb689861314411e3e2a5e37b508f246889705ccbe9f5bc94232fda6608619770408d7ca1f9ca8372f329b06dc058057d0c6e180a2bbdfe033ca0c15d549717029e3958555f980d77ee2f47ca88ca3cbcdde4496777c906d9e95167797a0e14ec4080ad1d1aea9e77e3a860a2c41ccb8c2787b33c40109b7b1f254c2f1f04b38ab22058aa51e0d4e011a72191b81e1ae2a9266b2d49244aae89c1207a039731b03cb4cb8589203e6c6d42ea40db2b2440719edafddf79393387c980687f23698143cc59ed72e9d91fb7a05c470cba51a624286aead9970b05632779f3ee4e741c9632fdad14d176b74fe35d0d2dcc08ff3948375269ebdb5ae0a9a187a71d5c7c976b026e0f521feb414bf7d4ee2fa320836d338d95d40076bb52a69dc20b1e0cc86585ce0b4f6ccb6f97d9f1346a3ba6f0d1b06b689c54e12e8a398ea72f116c243f2e4d19d768e05a232eecd12c81bd2753ce033255ea41b943d0c7a3d6acec5014cf5f8fe41bdeb847184b87409ad76630a983dd62599b46044fe88874ef1de99f961154e71b736177957b8b1d5c1b3cbe18f70a1176299e71a35eeedb92a68a7ad5331b3de7a54db88e29d20a40dadc2b0e3382c342406148229f095f4b83c13d8f5e9fe7449223dcd98ebf0cebf847c4714374e20d7badcf255aa2d6b6dfda8c0a5a3c63e5a6116a0a008444ec6fe3210bd0d123873b66a798788c129fc6b0b27a43cbf4ff749aeed419ce798e61a2c14da216ccac35375706ec4b2e118bd34ae34f199c6695dadef1b7988651d3888ce7a0ccd5a73b240544a145199b4db82a1d5bea6d490622d5181363e25159ffc2f21c385333ace1152c115418d9c2340af00d9b628865c26f315d54205a70848cafa3c6381d84ecb9379fcbb2f39fbc29c617a8dbe1be731a355566c79c5871a1f5b141313e41cfc18390dad71e0f7acd48a051227c23b4d881100bc837f6ac34e4bf742d86c94ab9546ada57c603633c5e46a69562ec915928c9fb42aeb861305d6c2f3b1051629b6b6876ac5f46482a389c137a3e2feab7bfb1b1f085e8fc0bfb379e1b187348f7d856dc699be0d82560bf93e1b24860fd581a73b0240101317d3c2cf2b36ddb14fa3d4c738f1bbe40e8a699c04268c4b967e6fb1600a300cfb816f798f02effb3bbd0f60ee62b2aae836868cec63bd3f9f53e0763f06849dd32f72a077ec2732a162bf79fd18b9fb3c57c58e19d0e1116deb6bb903a052664fca69367929c920b0680da1f54969b3049f460db17143736c4e4a7fe852ca11bb8614dfafb27ba95ad617c88f7607812b98fd1220e9c14c20466afcce637e0088c5002831e454625621211687ae719944d3b1f4980ec57b83f44fff2e31f5330804aa6a7a4cc61db5acd4429a88e6bd2f999a39df1fe35288c28de15ef4d0c97d6712e9f2bc0d4945aee2ac360d4ee9d8d36afb27ceb640bb0d5a0eb710fe93005c335d52f2a1e2f4078100be9a84bd333b75cec1a9a57da40671c04085dda19cb46fe3b2c330f754c0598e68ab5b5931909490828e6debbaa5ed440aa43752ed5f7aca84de61372d6701143d6650ed68afc1b2470d4896270cd201d664cfaaf9fb46521f6cd3507ee9bc5129a566ae27fcadd8e92679bb9bf00ecebc62f0ab35d79273b40f53d93f66b45cfdc8cb29f5d2b74d3be031dca103aea8ddc069cec6ef74faba22fdcf8aca497221aa538ed6de62c2786a4507515bade164845a3b5d839163e62f7fa94437efcfdfe0ff1bc405991e1df65957e597a52be969a9605123962d10a6e2c867862c4854fa09e200f224fc4a76832afc25251b7c0329a95fb5261359c6c7b118a95b7b10512545c71f455174389ec0b263892297318d140856f7e14b41f7004202f36cec8f4974df89acfecb01e84afff663af9830029d3ce5c283bd37609bcf10689c6d82a190cb3ba77bf3b25424000f863488aecc9a86dce9c4d308ac0bc9f0f441d135409c21429d34432026bfe9a34361387f95d02ee81df8b0d0278fc67c6931be6ecd612d40d809ebb07fab600324eaf77595eedddb5086f0cae90603373e3b24f975587561b54d1afad811b25160899583e1de0f9f951c69715253d73a63b7fcb825445cc0ad3e52fe5e6110c3618a84b9110e9ab6cbd3d02e57b7c13d9d81295a5d98cc5151a8e0b4f2023b56178906e48975f589f14c22644b306c59c57d6f9504b10343b6be6c02839e162ed6198bb7ef3f8626413784a317eaba866f4f193358c0215f3bf25d5a0ae4edf14cba08ccb62a1a33478e62b5211f61fb60f58ea580ac1012b5999c4ccaabd58131008e974fb60fe9ff4df62d22744ac82fb9afa46ab3b480a5b34c840b49adb447b37a3accff5ad266e31c9ad14261a3829a3a945539cc45f057482b88f6eced05f7629e4c496a97214e9a7576518bea303bd3fcb3517dc63a40660a1a887d06943f59f71e7ca0c4d4ab9184f148583f39fe459566d29ec9da1c19659de8b8fa602c4d1f2f51b09822c10a38c97565b749c892a98fa4f109ba25b47c807748091bead0c68088fc12bd65a8f560fcb447745d51652881a947c9285751fb4501d4cb0b505cf74a3f13f2de8ef747c1f9960dec1f0f0c34027ea20c80ad341ad67225278eb462df0557108c5f10a0612f148b766f4f81534a897cd0b83339e603403ca5aae8683535a2f0cc7749c5887bd0bb5b6fb893af49eaeccce522710a27a3d11c8b4f2190cc5fc06a0fc62272e0492f24432dc93dc0273f6f9ea5217d23048f04933bb0528fd2fd5f7a89191cbdada7b4792bc9eb9b1abf1f7d6970fc24317583dcdb0c4910d70538746c5bf2174a7657078103c8c971a1e0fe00b2f79f7ef20cf48ffa81dfa81462e742d8ddd8ba26dbd242195723eed740111f2272af2516ceed5de883ad085f15ccfee6ce3a0ebf31d7a50cf4fac7587a75147bb8ac01377a0753ce7857221fbbe5e76f006aca1c7cefe7f21077cc4fde5982bc0fdfec0f21b2650dd08e0a57211a7262744fad35089d2db76e184bc75b471bc0264881758ed86decc75ccdb01b74d676ceca969cff3e3dd6ae3c39582c5d9f8f5181eb780d31e90bb49e39644c6b4a449a85a1604289492b13fc540a2ad6b14de783a25822caaa171e6e0e8d38f1626683f6396ee63e4a02ed4a3c3527f040f59798b315c425e8833b8dd23b819c1513b76038bacb3abb3d555881c57d63119d31d17b8e504d8ec203ceccb361421b4e815cf70eb15fb961686fc6d04f1313e0d0fb8722f364bf60a10d5ec2ad24938eb33cc640506ce2dbce849b9ef97c63e979ca2462b1e917c35ae12ec4f4b07dd490878e0a965447648ece070a5e2ff76d5cc1b5fd9d3dba670cee158603de1b3c17d6ab55bdd816d74fc82c6239ef9cd7c57a24dca9cb22263be0e1880c81a5f371cc974524aa3bc19420beb715d164d285e7e1c231030d5fdfed46768997b7bc60adaf1090201ffbcb05ded0966ffe47e1d43004a217b361f904639c8b293045c0c1a6da571c488310ff5e63546b2419647849faf67ff25ad996c6184bdc46a7a776657e4bcb765d8fb845e812d5ef5b82373cfc8b295067d0c105d2476ab80c6e81a42e4a5802fcf01929ccf39c30c9b8288c49cdc3a765c5f2a7a765eb7ebde8e00a4f9a02449cd3d56266b12136e5385b218a4ac2480ebcc4007c2ce725f49a36e1403f5ae61ecc989ae46b48c068ff7256d1d683757f50a6ac6b1d1bdcc513abb60c88bb9c2fea38c79e3469125393a49bfa96c64d9a81edcc02b5c9c12d9f9f033e90aafe9be0e30423e1398114181c63fccaab9708b1a1891877cce35e76a5c7893df5e213f672dab479447ff6e69450c81bef669ee7ae1373d6b091ccdd742d1ea74682ad9a3c51c8f820e692243d142a19bf5ba977a6c121db28ee4a1502f23b2d84df3d9502fbf249cfe9ce40aaebd91998f65daeeb95250728628e125d47d5c56ee5bc7ad469449da1e759762be5938d5c86f05d49adc0c595be4a077983defce0cd441bb1b0c265448919ab07fb6efab9df09ed1bdc3440e171bf55f0a06f732e14ac9bb2fc1dd923d7dcf979e1c650145ad3d602c0dad09fd22819092a626ef82aa616f6c5d374eeffa9f3803458b3b70194081aabf6f9a0e978c30a2a4c7a8f0d764c4428d2af88d84962d98911fb438f9a501edc4ee63006dcb2eb3270248823eeabc290d61e394181042b60ed7ab53061bbe829e5f5305bd918529d2b0117830a4614afd6e4e84cf14c140066903e060497c43836e4918f152511e64471f8d05993eb06d88aae7de8fdad9454d3b85277c0acbe492fcc5d4b759754e9c9c693af8458ff965240962b55811cf98cdafa9c52da3b6f54e7fbd1167479171ec2cd8a38e71068cf4f3f2abcd21db2ffa5269ac876a96b8e8ee6305de247b6912ad1913823f948c49cfd34b7137125e010b0e354411dba1206a1718918d89922ca3f5fa97ddb5f7ab193f62af1e20ea9b5adf0dfe0e178ca3109387c1f525e75801984ebbc8264503f3c9b29840eb006b23f9a18eb5dc6e6d15815a95df36eb7e8e625282af488f5018de2caad6ae02fbff95f366a22f21acdd7100f9a60d37acf85d25a23a47d784f161b921df1a33fe6538c11e1ceff63a77c92bf1fc907a0a231e5efec37a3faef44ba620a90b83ef92cbe858f32854eb900dc94c00bb3c12d10535ed8e8f23418bd489dc18951f4d205ed1deffa8bdbfd20410d15b411ab3967cb21ba31f4b40ead28f9b04dc0fc0b205ce62a0a09842f7b92d0c84ba1ef52893b07cde7cd6e1aaf89cb5a75d3b184b6d8c09093d3f23b9fad62887f3692e54fc4e49c9137b4096de5c0c9e2cbfb581126cbc4d6726d074ddc0d3ff351418b515716d9951f1b9a868923a9d8198247ed12dcada0a083561d2995b59438df6861bab15bfd3be5f24bce54de8b25c2dde3dccbf1f2f1bf7dec5836ad026619accc0db81f8b0539d4d55502c9eea0c09bf3085a9a00d75e7ce8d779f047ab73e52f322e5c057b47c57ec564c8bc87bec4bbf455f423b9a9bfd628b9e5d9a9ecf5751e89a1da4675d211924eded9d3161c6e86981eb747a6ae2882e5520b42574f004682c4547f013d7fd5186f6a3e0457f81c333a9eba89b7dbad00ed496d4b85b42f380c50cadabb79624ce8695fcdc26c89c4eff0fa844f67a83228966d53b0449ce5e90b21b094944fa68329b5e472bc312fa5278f03e85f02c1807308ed3ca517cbb9fb7e9201a454acb0130a8a84368f14a953d0d7fd5fa4529c31ed689da348aeb407f09b66f0aad4d5f4f9b92c6dc9d485ae798ffdd83740cf083bcd51f98204e2030fa8d4b3fb97a6f235525c265cc90aa34d0330a27aec0c5be0262a154cef221fc6dc1564985eb4dadfde1a41752d72a0d6cbdcd94495cf700d583efef81230c401603ac960524d549d0a48a40b3ceb4e286e2cc47d63636970e91c144afffc9fde81024ef7f3447c9656210294d3c4c083fdd429c9a2587f46e9b4b9469919ddda6482412328d3f28131b720c635ab30f63f3691d10e697b4285e3895c1b2271c960f52c0c6cfd45dc3942b9e6f6db74c731cbb26dc97ecd15a3c165324e7db8153a1e36847c78ccf7913f5b3e183a9348e982e6ce64f5eb41c64de89cafaf03a86d9b6c24c89d67275c665848125e4c23a7b29de5bef67dac7d528391ebe27df2f818218ca0c5168d2b098cee3d251b137d1d311e3ecaa0d30f9a82df2511dc1ba23419ba5c81fceda477970145e22ba2ad3380bd516dc86bd37ad8113965ddc8350256f9d8542c58f8e176db6a37cf5c3e2e2b82d9a45c1d4985d1330091c64e22023d3a47eafa8965ebcce3a78de7468d585a9e5fcd29e8bc868fdaef6f24515c684add5cde65628fe762e006f5966f473e995ef5ce9495c08699919a79ef40af5eb8136d2d304ff2fb759d818ea4d5b982ff383cab142043451571ff91d4cc940c7be68f57ee3a81730d50deb776a0fbcdbe5dbacf85e9cb111166ca8b6ffbfd4585bfa5baa727b9da3bfecfd88c10113dd7f24c143bfd217e5818ff47bd8aec491b23b8919e1776a8f8841fdef63e5eca9e7e00e4352c3fb05661796dbdabed1cc04d37133dc71e310bcee0b92767e374c40c347d166a85348d37de35a088ef7b7fb01e467ce17aec3a797d2e340617070b09a8410adbff7053d94458087a1e9cbf8a96b90a64c92f60ca0fe6c500445851aad9ea81437f0a2dd920a10f441b5d4b8d4563ff79441e6721b18dc92f44990eeb3a340bcd5dfcfc8427b75eb6275bbeac948e100398b22d9984362c53cfd0f4346f9ab6126f426872a4ce6b96f8bc2faeebd10f3afe74e73712f792016423c5341d550e7fa3efd5cdc0dfd19068ed64c72caac72adf1340eaf54a6c79408cf30a73360a6c3b8dac3697abc177d3ea00fc1014a228fca26565384caa023a7aa8de027b39d2fdd78a14e2adc8ace665c7c19bca0f3d3543437d66342cf0fb84ed7f7e5c1505d0e76c1ce1e6c97ee6ad587f84cab9e2121fa5e04d667fd30632e0ec875cb03a2e88ba8174ded04c5b24c4b1c7792b3a113a22e3fc0d31fd3b8439f5e1f5b4e416af0a3ab2f0bfbc49eaee65d8d85861ba62799d46720a0bf1f6f15ad5d72953afdbf6dadeefa96cd656c97d0122b774d28d371b8e8d151c07f04c0200be1ee3b829edf19200f4d29d4673c56e657fb48b438f68b6544172050e3eeb8850a198e2be9fdbd5a290e3b71c13863d7e57b942e3d5ecfa6b747539c84b70dfc4a46bf99caf636779d6646dc77cc6792d7a289f702608e4f6e829701925751a235f314b7a8af746705091dd7b688c803d7399aa2305d44e71c3924d4067c42fec6f0db56cd2101c7bb8b889ce0050f5aefa37a9e618857de8c2edf130354b6014d295953016164bf7407e8031687dd4078f7152eacfce98b5cae4ddb19866bae5a08e220d8b6551a52abf90095542d0f1cf1e1acb9843a549803e2ea272d21fa60d46200519c03f51088622d91bd32c10e3b94c65d1c7192ad600414b96e28e2d050485f82e85dcf4ee4adfea3310eb543cee20761ac2188bf0e855ed1cb6863f3fecf724ce9e95e07be9498f221077b602a317450f22265a8f126fb2306da59400fe376e06dfe16708ee7727b0b0443f7bbf1c534874d773ff9428fafc165da8daa7e2c21376c7f52e45b3c06aeecf56260e591e554633361b7ac3a190b0bb6b4b7841e2d99064b22bf64cc1f8d3c52e61e51e0f0babe280b1d97101900b3758fa5a710f48e4ac09374a1309c537ff8edb62f64658e84a247f22ff239b1a5ade3b6ffcd431a5c789ed55c94aa849ec5c8140f4866455a3d21656813bc333c8f8526be957b309a23b32b0252eb4b3f3df979de96712629c16c84d21c527f2b54f381a1ee2ea7302b18ca5c7fa075448f65ce4d42960b75a25353f2db7067e8308684f040410db34bc1a9ae195dbb2f84db162dd8f3440fda48e3542fbd2c3f42a65101e01adf3cd3e1994d7b1b1cb4767dbf3a6ddb39ec0356368cb2a9eeedfb9b3070e8acf03318b7d6aed805a075a86aa736d8c091026dc6a0103799b3b52b1e84b3e77086c987844597961a111c402aebe3098db0416695e92bdb8a0add8178939d9b326e8e1ebed2fe6d9a123c63bfb7b2086e2ed1727edc134dc9c60a325c492282488f003c3d4a59ce9fe3321b8538a9663d13fe07a06a1ad21c79f7d562b65086a85b2177235b9b3b71246cc19c40817d4d3624d8b0b36b36e77ea10f403a7ae8c5d15f715667753a5498ab79a4c38c6cdb2361c0c34b072534671ff9d2917c1d8883d29ce9f8b3236763c69ad5686e1a21dbb9047c5461b8e9daa556622a8d4d543fd6a1691f0f26de3393bb10dc03c2813043d065e7841eb4a45b0ea2847928ac31072021dcc2c1e5eb50ad9b7fa55e958523d312ebffa2042b5d4c53650aa3e03b1599ab1a7f771a9b4878dbfbc58c01b00b42b0887795b5bad7b541b2e6c16c61105653529d27da77966da0d1d78054c7e5af3c4e5f81bf1f2c3bc3570bcbc53f08864e8a193543e8191d24a415e74be135f5fe9ffe70fc7ed229a0cb9188423d115a9a741599a88ed8b5afef3529af2324f518be808d6094a63b6109e93a65689ddd44a75c0123fdbcda204981ed45545c73afe1edbb11c90b366eb655e7dac859e23984c5363b1af9aec7c18622fe10b9d619862014e02c7f6cc279404b8807f9a6b9357d85730894a011220f75bb5a6699ca3aea0bc482ed57bc4fe8b740738829eb4cbd482c760a29c0d5ec43a06d3185d6f24f4b3cd68e5e8c2b805d34525dfc333ea938837c212db51ca36c31d20f23a4accc3554d2d52f3d1e27400ce774c163539b88bbc19bead959b39d4ae4cf913542443be08f47cd220270012318e30573e899e992ac88549b201af8f88e33e72ac1604edcd4d2b164cf328db6b103777df190bfb799745f45b4603dcdf5d1f57c430fca5d27567422e2c2013647274eeb22f98ba39247cd675f1fbf4d1646e9f5e0866af27cbb1364263d0c9cddea68b9061d3c6bad6267ed04a0678e4cb96f2ac72781480a0a22b5ec392924cbf9464ca3eda6d1a26c32b4fa15bb9036ec2274bc332a63ee978cbc310cbd0bb35ac991256dfe133481cfe3324d0cddad2f33f6a871ff36fe537107693737df54719228e4bf2b539f5a2aef8798f794421ef35269ef4eb9ab579177075461d640f16005bc9471926a0f546b21dbd7c8ef4b5fe06dfca9103f26628e62f65544d2338fe2b50b189ee7d470409432c4970db3677f8e2fc7a53a4759ab42229c7d120f8485681d7622cf2ae171ee8b42b5b84237390346d026d68d89b0929195e343249355f69d2e3bbc4e72a0ff32d144532d941f47e1701e4106372639b904ac24ab8e51f93120a3f29f20ede0a83a22aa93af9fc97521309d1b329e5776f907226416c16c31a16ffdad38bd29f81f0918c046a673bba3b357cc06aa9390de9b3c493d70896823b62c43ee27d529866c14f0aa6fadbb4b7ff1b9dc820b67ff4f73f439184f77f014f4c157f5b07dbf3093e88c14501330af979f637b4f7fcc0a9ccc7038b05c548cb491f27b40951e36f82738047fafe13a8b3d593516ca2db3d67ee7701b8769858735a2d099a6a64f272c317f73631f6eebddb4550ce10410181c82e061c7cbe07cf5b30ba35886503dc7ad9e3b3564cee4b82e991edff053485605e7590687beed8da91925a64da6e81b3297ba03ac2521cefa218af8662a8f6b40973dbe2426304b661b90ecc965b1ec22eaa3edd2983894d7c21f0f19771a03a6f3dead13cbc11bc9e09e59d17bd157b5a84b73d2ed9c3df83803535736a59dabeafead3c7873c2c375bf556a838edb2c6d8743e6debaa1763a17d057fc5e9dec9928c2ae6107d633460e6f80be490251ae9ec419dbc1e3ad1baa52067e033e1547cd494157352b6aa362b2393c419693921ef266ccdb16a0ab12132ca17f478ff1508d00d46608ee3314040336e956ca2e7d1810c7b7421de5446ba438359a3994be8097ec86b152ebfbe35f1933faf9e01a9739029431ea7851cc39c7cf0a16407536002cf782ebac817bfcc82e360c35e600092fe0b55591a1eb749b3de3c85ed5a90209432d760965cf2a27e4522ace84c391acd9ce0e71e9d1f0f3bb9a52d97548b0d4bb1bd9ab9f8dcb2523a087c788b8278920b495a28a718ae186b0c7f16443932605ed871dcbe26d29428217fd8c86cef2448e87bb5b6506474ce9fd1604dbaadeef0ffd5b381419f44bbca343e5d15c88875908a0939a9bb485964a3a9bcdc7f9908ad53749497833b3bfca000c86b9d76715ea6d719f28d6414a16d081fa378f98db25a950f239a495c8c69f318dae8b36945a68e044ca1a95482bef1f063b11f672372bad3f798166c877ceac18ec2724387c5dc52e9e461089945a70bd0c89465f54f87f4a962a2628c3b2df28195e9cea0245f4b522b7837a50dff598ca72f6d320aad1418c517ca562e9416dd8ba2b1ef761af697ce76fd97d0d2083bfe7d0c52a4ef4cc406ce6a5c64323b58687b7aff565bc5cedb5124f5b7949448f24ee02b54f985f1a33213ad7b2a4d37e60d32b458e1250e4dfe523c62761c9f4cc3b6c474571a3dca2a017f17b0170a01daa20d1098492f160ab88ae5a476e4a9d379b933d85e3a216ecb3735ef506abcb9b23c475d002bfb4d47dfe315bab4f289c6aa3d94a7046eb941aec1fc0b10022be1a22615d188d30aaf5601bf92475ec2db4b3d98fe692c3218be13a4b1cb2ccfc8d7b09d353247e002df8a9f006b4bea7841338fd7f9a9eb252e7587242091c5b0f88a320e0960364f2e4ce28535b389d856bd649fa2989b084393931abebd9c5f2870f282c5f30ab42999ba858769f504dc7fa9e9d806837d23824a56d57e65a624f79e65196595b4a23e2803d9f287b01ad51872eacf1a3bb36e7d53e333113dadb6e39eb6277fdb8b15e37b85d7609a8d9105e71d5ebc33635ee9c9ece21c3047596e5f76281769596a77f17e45f6d8d34edbb312222294768dc37cbfa73c8c634e5c6c1bcf6a3c2d04abf22a3fbef5e2908fe62f1d9cd11e03c3be6105b33d3c57161b7c571058bd5413b16811ee5be0acbddc1c4096cddc4aae98c081f5d49e76b52d964268c72db3446ebd196c2a5739897701d4bf29253e2c96201205a0e1f6dbbabd53d0212daff21f63d7abeecf207922052937cf55678cc9793cadba8532d2cc300a9bbdc8d453dcd07370b810745fe2732b0d9e32b159e9ffa8fb306f002b11b58daf16f0e0a0559930bd647b47e9633e558541cfeb609d92706db53f8d2341555cb3b7265cd5c5b206e7c99aef827f589de74c43b6f890f8d894e00f96132d61827e95010effb1877f5724f0fe9eef1fa059a364af1db0cfda71540566118bdbf469a3136a901c9883b4bd165db2069ab5d918ea5e6a34394c1ffb4b8744944819f8fcadf28911df51db72f605fc8331f2794a1f519f066b70f07216af0e81f37f554be7592ed3fbbf2a80bee84db87d86c7056a898980becd7405ddb52a05e8db37f54e880bc24b1968a5f9a0f716610ebe6368c67e3f9aa42a96c01218def1184891307334d0250ade65f10b42b474056c18127457bd1badbe5b4befe1314c11cf8a66b5ffe8aff8e633a06e153bc622f74bbb8112d7528dd2ad3465678c480f436bbf71d6b10145a3409a91014e4067cea87acdfabe9b2defd715c365e12243b0ebc85edaa5aaf87573ee870b5da008cff007bfe51931ef0d6efd3e164a34fad6e0fabe9662021e3acfd0842724ed63878f1574118690a3a00233b528d5f688b973dfae4eb5bb5b3d712c85bb796a99c9fe3d965b5148d13109eab480547b484255f70fd3cecf88578fb9f75a3fbbaf92fbe5a8d656cfdd744aa0059d63abe9a6051f741d72bfcf0c1b26c2cd3d30fdb6a329158eda7ef465603e2db5919dbf6fdcf56ea1d8cf1d6d3ee01cded85558a59f2cb882a49b834d82a803a8effe5b9c6d02df7603cb644900be5792776d8853506d65c36e107d7d4df841a478dd166ab664ae4337acb40b349c1070813a47f332474308cb2c4242b926bff0f4ecbd806f78efc4c78b9a60ab81e6391ba640724a4756af7b4f15513053757ee4b1f915b23344164096c48e99afc26d6cbb75539fe72f01ea082b3531c3390eee4b655748d990418ecf8cc6c79104b9446cfedf3a5874eb69e3df292bf6a92a678c19288319fc10874e9b8c14f81fbb75ba8ac537bd1f80b814a16cdea3d80084016680e103f6c9aac8cc116db2da876b9ebc30f08b99e65c6e69fa444713b5d82f74d5354819676df528d1f49ae249ce243d72602901de90a2b3d6b26f6294b263a0ce189a76707d04962fe034a14c6e953086c9b83c0d684f1292fa05ebbd6eb6a8a58ced5c97cc6e9d182d1a8384d89f3785f0107c2d2bc8aad4935795f2ee63e744d9fe9881003f1b4081b156d5571464b4de82e97bde785b82c51d1ba3326d27f66800f9ad3d89285ac512383b04525acae8f0214cd1ee229ff9fd700aeb1d0d957e47bf0d34972268cff7c821b086157be13c7ca436b00e69bab0deeb4541229300d4a30596a868e51f4ff0057b99a19820e3f66929a0d2d20c7c14615126001e8a28e2c2cd8c9c91493abb63b9143b7c44cac8fbb6afc0bf4b2b6e74502a8024cf1113a1ab9982decbf4878ad1e0983c9e82898dcc608dada20299705da07a49431fa3a000b8e92858dd7dd952e4f18eb79ad0b3d171e432da87d0da0b653ee429d2390ec13b9c94c68e9f45a2c9229a5f0b49ff22606c6187a7b4d9fb4fb9a8ad31b7422dd7ebed9e1f79d17087fb2893902c56357915704a86bd47b334a8598c595642ab05c662d8ac161693b4654a23755f75f10f2c28d14813ca4d1652f56d5d58675ad2c1fa5b1d1715090c1763e16c02190dae27a2b66b3aacfc18d40f8c1200f98f0d07a579975296338d4af1a82250128aa1569336503c180cf3314b12ab5ffdb7c9e534146053744addd262ef856836be51dd8502a90b89e49be4e3b7e75f23745df3310a8fa60b2718d9073a5d06a397d488a0190d686a75811467ff8654db71cea5fb476cf4002fb5bd31873cbf308814ba4c4725f4a39a870aaacb67111644500c62f9854ffb0f2030d5f515454987cd4c394618d31bfb9268d49780d37f16092f8366d4366067749f35c15ed1031e98d04fb25a623e70773c74aa75809d10805d851217e65bc0e759d1ca4a8e999ef1a823ec4aef58bfa01c2ae6e50809d59fc082e3547a6a68fe24f21d795c2450e2f6ce94e90b4e0baa1bb144ed667a5db2fe5368be6c6a0d467b20dc90625e6c4349761d3948a55cb44f5f7a70dff4167f4e0b86acd14a30cb7c3b8f8b9c503ad264053c45390cc344bf67a4bed663dc36b5c4533238664a0c2f8aefd3adabf4478209bda3acce2c3e89e60b065aaa112c8851b85a856fbedf5902a802488fcb4db1172286e3a190a4b73f9d0d7a12e04f300dfd7201c733eabbf9f75d26dd6b51157e0ce558bc8d02bf40517806004f54aa955fd97caaf6aafde70d154bbed08480b04c67f70bd7552e80cb87d3bfc35b2b16a1a248b34b11692acf7c2fd80c7b6b23fad1bb1ae08b1ee97a00bb105571340e477c29010b8efafc6ab033b753232d1ef00b59e2479c175cfa12a0dce4af92fb24ceb6dc4fa111cd29284c6f36ff8551e3c0a9948152e1ee8b47bce647da7cce85031a9412a694c1c474807493293ade9c6443c38ecd48e560204b423d1c7098625e8a49f55ebddd8ba16be8085b02d983392bdb1d3631077112ef5f84d71898f0b2809a952ccb4cd27cd014f1c971565636d000f574f0f0a8c6fb55ba632015099fdd9d2a31d23b4ca65f51e713325d7ddaa66084686813d2374ef607ec640233a7c8b6503816de60976b98474e6842c5f1c943ebaafa88498a532fa8db1e4779acb13a587c73639f112c2b4556d70cacc3b392ecdfbac79f39bc827b7d652dc4e86831f00c3a3e72d7f08d9b5490a944c0196c6161b5f4d65dd893ddb0d823500cf0dff90a50421f3cf66dda8a021e7a9ec3151f8f7185495d7b9701d1edcc715598bef92926433049b60de2c99298944788390ce5da2dabc62a7d860db5c970ec83babfae6a9366a12720831f924c5fdc5483a2e8f87b5cab8900aacd72421088de7923ffa2a72226b389c1b1368da7d86c75bbcf0ed37640769de49b1e80952981eaf9db3a556a5419a193551a641358838c23265fa1de083e06b14bb1891349e023cff708678bf67ab3d0694bd8d0ffdf141c685d6247be1cd95b9f9452133feb0cd2c1e538a74131bd83179dc3f0af736b1118b363e56acf77d3ec14b79dacb7ec930adc5a2480bedb3005144e86d2c2ae3706279725d201aec60ba3eec773cfc13d315c23170e672ff1f3b06382620fbbac47a17bea022a546f935117d46547bddd346d8a0fa42f3738b2f36882c2a4795b34fd564efa583f59379b6df80ac7846a41342a8a0cc899a85b3fc1b53f214865a0b386eb4755fe38b68612058708711e02e7ce847e774260e2ee38dcb535c3cc53673681ea8baed14caa486ae18b2be82b6453b72d34d094eb81fe94618e8ec1508da58566652cdc79aa8bae2c14a01505407726c938f5764f5caa9d38b3a7207536137a28c689999babdb679722b3e85066cdecfb122ba7307737fd23f117c5fc9fb77826465e8565407401f322701b1cd0329443b9dca469d7a71fc329b96cc6d86309bc3efc4143aec4f398a5bd4bfb0db4eeab99f00d59ff894a66002d39e4064fd2cbbdebe164f5421264d6bf6540231c2ee4e38af5d1a2485ab927a172367d06a14b2ccadac071048a1265cdbb05341ff370dd8fc626e609b4a08a35a5eb51e1517add34b3e7b5181a35a8b390b77d71a01de8c787e7cf4272195a9af6cda8649d8612e298cb21552e68e1c7ad81fa859f0aa9abd99191fd5cfefb0912bdb777cf33fb9456f5d0d296a67ca3087206985a98f3951e48fe7ab6b41e4abb47b358576ce8ca1c9793e8715be478d5c957abd0e5c6c4521381448320f8b271040480a836396565719f8d10c83c13205097e64b319924318f18243f4e25d24756bce61f916842cc7693717c9fecc3e3e5085b5da6f34c0ee8d4cd425ab9638dcd562c5f0d5a61bd8480fe0797ecd99bb500db834b9cfea1e7ac78eafc3b4c440442155328f9287dcc5af5fa7a65b33e3897da095711c0a80b0b2ec20e4399e168ef280eb8dfd978b82214ebac4d3092324bc3983fceb642e4abe71ac58ec624f618efe4d93bb556b36a62c6532d48b276e44600d60143719f5aad0316f6b08042aed0a92ecec9a6c18cdc98a6443080107da3d6d56dd48f7263b8ed34d82cb9af3bd60de8312d6f9b975028d7b17c1e75edeccbde9786968cb2e1ff9ee9ccad0e49e0cf9e73ba8da42fd6b45b7ad1969115e1aec57ce7379d54fffd43a4f099762e6c07760888f02352e44510acf90a97203ad4b7a66b0ba7bb62674615772c603738db31761553b621f4770178b563912760ebd48c6b66abbeeddc98e493465a7e240d87d31546a43b94d427b576f8f746ecf171454025318169968b2ecd3a291dc6c48e00d7da6749ca3ee06c052a65bbe987088ef05b16e4b2fc49ae91d5d7fde76b2e1df206e0964fbb56bd492d428e76cf1f3072abfa92b1d4876a4cd2ff00c8ca88d39c010c450331ab6248900e3745f571d95aa23b882ce35315bc0e8254c183cba4336fd944b9d5469db4a946ba90759a634bb6655e27cfa3389c6f3ef8c416705f9bc354d7fb267e488371d96cdc74c8e258b65ddb5dc854f4d737cef9daf6cf9e60aa0ec821167cedb2eb432440eff974c8c355394a2d12b7498eecf5165a0ac51a41c96d1fc1aa34c1718a24561e04230341ec6bf8fe0fca3536021260b9df4b33331561f5fcefcb9498553dd2f6464907922aa9b32e957e02a9f70d50afc11119bd13e9ac6143f1392ed79f3189b61cf8e464d0e2372be395f2597ade59cd22fd028896e723597cf9cfc4b1bccc40c6caf46fe8beebd785602fb6487294bce7026ef3e85c6d14e1796895ef83a6c0358fe22b34e8af8348255e5950bba60316dbaadf7a16bd79975a6e437c78a6ca908d04e91c491c3df686f7ff22f5f26b97254eb319e703df5a85eddfc89a3e79ce6142fe15e8ed7d1466cf9f4dabcc6107ab603d89820f4dedc0149f0af893207fe719bfdf6f5091ee000be2b02fcb46aad52b28ba01ac82c116d18bd7477e7ae9f358813e3b60f974efe1b9915f4abce44677424bf831d9e0d4c82b8a9ebc6906e762431ffaba91cbeddf444618b38bb2a104316868fa69b62fa919c276ec0378bfb57ddb9eb963ff25c27368df6f7c7edf503094b0e3d162ef8acba6001af1fd4b58314faa34534d5bef6eac0e6cf1c9e6ff0f6a682848ca0f0c534e7f47343d80047dced12ec0e9c8a9f532d595525c759847025823641cc17bb67d5fe86909ef4cddeb32e5966e98c18fca573a2726123b78ac88641ed04b72ba7e9328198c26a12c8e3e72dbc0ad3c87efc738a767e221ff1cdb7a845b90097c3f0e55286d2919fcbb22fc41be6831472e88c54ad6ac714fc716baf56321ce1151b24a00bb00f7e1f12661e23b7f7506db2e77ddf3f0a3bc5a95c3f2d9656c2b78ff9db477605a6ce27bcb5a7c3a546b398bf4e42e70593dc2d23d5f22e99aa33b917d56f399e64146205373a661bcf9849be95b84f893eeb0456cd2eb5550f680b9e3d3273f1444080583d50af89c6ae15da1b1cbfacd5af16acba538b6465e0dfcdcb82ec25f58449a123db9b7f7a567c3b6bbd8dddc36a6f9871682a762f06b5dadb1b8c131a8a7d9ce4583620fa324d3ff807ab50848f316d623638cda3f6f0a70219dd30da9ccc868bb048920bd5a55e48f1bb9f6c9536f55b9c779470c338393fefa1cf22177372a3bc59b4c3d13c411398948a996549033fed3475467f15a952861ba655af062d41a8617ad7d8c2afd16db4c671132174d44781ae447a23cd21b55320936a4338726b9797e592fd69f311040e64b77f05a6aa0045df8b239a2f04c648819eb70f93b62edc1f58adaca5039570f4da0f6de74c9d221cca63c69ad166de0837bf8a9e988efb804047a85665c51e4042de2738ab3afee18251ea596ee8931b239c5839d9ed498d92c9b4060211c8bd660dfce4dc7e9989e61635d04442a0b6394531983d805199270b54827c78eca8c7d889ba8d5786e1d0d9739bafc3879df96bed3c89eef36f66f3477958cf87809996d264245515809bca1b8bca2c8e13743d998fbf7fda9de62702c3b56d45ae30eb0777da4cc808a8a70990b505967305f03f9fb79ed61ac5427e5225c258808537ee5e0595d1bc18e4659efe465ab910455cc28c6b7780603a86c8b66d9c0001b5b4f9a4b7ff55635ec09e27eacc3b3c30cd5f4aeb0c0f60367b12662512c1d7da5c9d20b73c1491bd41dc21ace91c036aa80572dcf9e5fce7634e2ce5512d63edad6b31b306e9a1ec73488b62267381e8a9c62839d7b0b85c53c113743db632703f45fac2e94a78269b78a81224e10aa683d6ca42b8ee7915f894d4dd6bacfb87d7ea9ae45cc9ea6b4ce8d7bebf7041fb5d5965b669bbcb5a4006fbc354f31b651cad22bfa14dd17bb436068236605028799bfe0b20813b12be3324eb594ee2cbdb353d45e46b54acf833957525232fd0a8b46dd1708a0567d80ac5f835cc7c27ab20b7a122c501d15c8d4344406ea44f004f489f2e2970f836958a6eb5309e4ffb425ad665d95f77e994e374f958c16f030cd39fe4edbf185d735e60f6a8401fa29b9ba7180cc05ee767a46df0ea3aebd3043c0845b84c639c97b1a5a2ebf1611febb6a9a6dce9963a2327c4d203452ae6224659c983382d2d8dac134edee959424721704d517f2f24d889f7f162c71dcae93d841ddab991c310b1733f9e6fde02c2718a306b1e2b4b2eb9ddedc1e100ebb8567df06338e305bdc73ac37c7ba7fef2041f04fced960ddd9d257094c5659834e13b9ceb5c3e7eede47c3861dc659e1275ec72c2d231f850781d40d66b4e8af9f980339535c0559c494a8493659b385859f62420d0e088681b9d547f6fa286827f7de58d42ab742bc6707068a84ab14d2fa9be6792cfd6f89a62621e462545cb02011dc547c2c5dc4cacf193fc7282107c2761b7b23d6c316342fdb7cf2493cba7bb84c99ff17af19fea984f6885d05525a196cfa338fcdcbc4eaf6f46088964412adcb11867299cddd34962ea1161d78e66174ab33fc69ac943b93b9814b9c617249aafc931108692aea537895ba544e2598c6006970b05e7cef50c0f387597e6a105e5365cdc7a0d48272844e7a123f2b430af632b42d8a428d1beae23fd1f11dcd94504e92df482bf7920edc80125b3eb41876bc384467d71161fe9b881dd9282b6c348bf38aaf1351119abd0b9c91d85daf27385fba3884f27603d1109c87f8ae8ff6eb29348cee2b5be64e49128cafa37d6f3095f7fc4d72ac8b6a535bdaf1d65652cc10a5bc022ea496bdb2a0e5ff959b0c1326ba10ddbba662a5f893ca32470c0242acc9de903ef58cd0aefc411f0f6deea43203ccd58949d8e6400c7b815654f008427e4e3a35528c7930ae069512b1964b24e460c715426c1595de8e935cbf105dcaa1babc7db6409e2d53d567f75217ce5b51bfd629572a2d0b0958c9096a719464b631c563148fd54ac985e3ee66d4a62578fbe6494c46e0df4dcc6a4b742cf9435d800fc2ed928df930818fba1055f47d94187a71963d6d15713f602f3af52e7ed48e80b333291b09f47665dc6b3e296c70b28eb1ed877d21b60a76d9528d0e58eeb73a7b303a45533716f15e56dfaa7b65dba71dc144862e2f4671a09790eec3a215ca2800738d26964574bb5fe47eee41a0c5e8351526847f15d3acfa6ca26ff58da566108656f55c07711fe6ec514bbc38deed37ee77fffd73d9075ed5d2a6ac70a27a2c065f83a90de8fd2b0f40329c7baf8e60dfbd621fcbe8030c33715c3db51760d2eee20de0dc0468580f090e244eaa0080599959af7a910d8f16b6ee811fc338c60884f119a0e79500b44d63045531d17f89137c2fe7ce7ddd50cf9d4b7db8bda88e03d44310ae4946bb946dd16a5c9aeafc2c2b6686b8c34d3f0e71cf6ec861d249a8d5de69e0b7732098a258c8c00bddea3502671cdd4edaa857675461d68249fe7648a82d3f0a0c2844df257df94ec48d75dd646ca86e98d28920aee38e72a08c48d8860d49f512b8e4a8d9c77c3807291e1a48c9ca662e06fc1b722230ea4f6ed1113117be90040556dbfac21d1bccb97f7251de0f9b14604f8ae0332067fa5f0180bccf0600bdef5a8c989a317a763000d8b9dab96242cff4aba73a9d90ebff19224e77e8d58536e4decc6f88af22dc2bd005a12d42ffe6ffa80a915fd958692797381083bee3ec940e7dac99785683c873d496bb39371610c7ea6f102f53ba82468994207810c76a2a9dbff0bcc276c55a12d145dc6b96e6e6e9809df612a05c3c98855dc820f8e34e0401e57515c3a3ae08c452709002df1877a393b163ba721deb05c1d66cd491d18568e442c89daa384974c7555577f666b46e00854bde2f4020f791633eb19fd16054a26ac76db7830209ff9ded1104287e22fe83a78526c4397d735e3414661311d3919e3eeaa8164f1abfcc48881ee2019583a40dce61864fd754b68963ffd18de0eb26d01d63d25cd8cc11b657e87768ad0827cd4124b34e10bcae9ddb88883857550b109ad1a4eb67588135e5b019c3be1e9313022717f94fd9a7ea78a6d0093fb370d99a3b5a538b3a4ca3086ff7242daa2625143c08ccc2265900c8488ea4b49e6352163452979023f9c70602c12ffc50b6852a2cdeaf73348ba03cf7649b0965c773489f5373b4b6f837fbe257c81cc2e35151e919b24519eac336cb222d08a5b961dd97dd31fdff4fb62ca31eb71d8732e861ab6fb982b32065c713c0f36dcba87f4a5669bfb4280e7e0337da1a03c18541bd9b00cc44b8af7674757f8128ecc490894b32e714702a0b1276c12773f8d09c686e79897f6cddf0594a8749a4c3a69c4cf5410a3af7bcbbfa18bf99b3cda545e9a0b1b46139444c60b1be141479e6bc967e0f1b65dd8ed26e1ec417af65cf23f25309df34e643270390dcbbcff70eed2acaaecd4d8b51a232da76f809ab8e748e5e3e781f56326227bd008bb9e06bf17a4b9916a3cc2f010ba4783c3c6b634f34098a371db4de00b4d27249c8505eeef059cbd43dd7d182b5c50fd6af4bd28a9c5bd4e1c443ee06f9e23181d6657074acc4d9fd2d77273c00fa43081c558e46e0c531113e765e7b21fe2c7d47478135485cbc9224070e926eee269558cc1a3556031fea7d4ab400fdd605cca6ad61143fcfcb16401abcff9b6a1688e8231237e8304ea17331351c2e2ed917d6cf1efbbb6b46029877179835db529e3f1732936ea55099e1a9bf532a8a5811e2ba709573cde292192c2b2bc4a89e21cd374be628b0f6973504db7be4b7d54f1fae0aea319fc9999f543fa977b340d099b2588560ca990de436e5927b1b81969824d577c4836d2fb03f18c6c81ea09ffeb918515461b7ace2d6af5ac5fbe962cefd18bf0b09d86f8e921bbdeb6b6eb0b10af6bcb1180ea9f497ea50cdad34b342eb37a6ed472076b96a667b1b34eb65a175ef297096b2722fef400e4fdc535547f177dd68388cc47efeff571d5284adeb8a9e6fbdf0d3ffcf7705456a92e6f429ed37d13cc9731195fef74de5ae6d5280336d5f85d02f962294e8759e64deb3d73216d94e321bbb52fcea1e067a9e561f73d3368590e57dad4af97eef54b9d4d1e67676678cb8393906db04dd9f36591f19905f62611fdda9603b970ca687caa1e5b9fca1a36bb0c3f3025adca1ae15949ef9418bdf8f051590aa3000da67bcda375a81d6c11e4c85ab22e9fe84d42843f30eb830849a3eb4b4f3258439dba74d067733cf7618c844f813276e324996804ea0648a649a31fd89887682d08830cf41b22890facafa4cad5440fdcbcda6c2b43093ec810f847c8f8d7ecc2741f1e07197685c74e52a19df734bc45f8f570093884b1979d040be65bcf04f28c4d855a1ac63940ab760c42da7308c3a3b9a2ac671a6a8af118643fe4e8214259d37dbb0d2189d1ec045a40ba5712f3cd28e2a0fed624952b3aac8401e7ea504d79b0a36b4810e459bafe59d1ede79691aace881bfa9da0318290c829fd38f7b90c609416c28ddd86344cf4f8a1ff8d872bdb94fe5f9c7b759218f482e4d332452b8145e19a2ff56296db231f38a47dcb1eddab8d6571a59f2f7779609f3b0367525a89748e265984327baa438a8894605c292f117746d00526ac0287d86351b3c2ed3b3fd6b01125d1e1b512e530cf00b3833ca9dee5d1d6b77bd93cf71faacd60e262f3edc1f3d46f6948d54c5fa48b33f74701aad78b11057d5b56dc1b46f0f96fc6f4e4e8cb93d4e118e8412c38453c848858d29c80eac76158598f95c77f2b31cb795c68648a183532f529458529de0eeb0208e857c98705ff6eff0741f057941d3fa5ad56ceefce632179bf6d0a8168b68c29efd8b9b69df2d30500a60b6778e6d05691b0c084db50e33c05dcf8fa9ce1c2e6aacbcd1d48b3deef4ac67cd295839ccb7f23e3d6723c6ad77a7e2f98c52564d6f1d197c99f7559cfd66f464f2aa695919af2aa3c78d1be62ff050b94bdab803e0ddfcb6d60805ff2d3b13a6f6ec358d54b0f8a6a280a8997a66be124491644d2bf65b9d4be0323efa3adc530416bd0dd5e31b5cffb9e7df8da232ec2fb65da20987cc7040e0028c64ce8bca476c38aab0a5e1407464e2a3ca8700713bfb584923641fb7b59b85200962f825137edd6ff30be868bbfa289703be3ba5f8a76f4d0dba03ba623f2f3db18c4334b22213566c73bc019b52433dcc3d05425a4a99621e8835364c247467db271db3f244d15ab98a5b1609686660e2ecabfe3662a3d06e0406cc49cf8f14dfb93e059f28baac47ef3a1703caad91e904afd5b6bbca080daf275897bb6f43529d0599226e6308e4087834265999c85e6fd9284a0ea6a98e0ed7d05bf750eea26ae5403093f3acdee249c59eb98a0bea2e244f5024a455e3540bd3cadf2059084f71b127b629d750a8b70e3dc5849326e1908ef9ce15a3d4d4642ea8f0c5ed1d5339914609be0dd21be5d46037ca751dd9389175d918e488aaa8bf4fa0598b6031d716f99601d47ad822a27d12f0373908785ac6cb27bc70a77ea53cdbe06b31d5b0f51c93dc7969e47bfed32f0c461dc6777da8d12b92d0d59afdcb20f8f06a14ae099adfef149efd6f4b04c0b9ccfc6aca9c5e5b7fa523b2bdca3c28896882b90045eb73e741a4e93c7c83d7bf966a3a0873e2107b38d60c655480b13f109dd92b2f920596a82189ea167338deab17b588c32c4c6ca91b4e930af55671d0cd8eaef3c3504396187d4801de3322db523b2079c1d2bc86c6acc08279aae85ddc63b018fde19ed513d21d5cb71a99dd4053a16cf313431a6704030be6bfa3a772abf3b5df61485509dfbb65f94c0e983d022a8562575fa0483f890298a84c08a3309d137988cb9788a56e25ce7e2c6479061b8294666dbdd5853d1676ccce3feb945a06eef3baba8e3e2c99ebf00a2e2a10dc0f422b3a0957b159ced195dacb3aec68b0673583c93d05057bde508b49141e2144d98a3e354b4317b288b704db48a6b8a6366cc2ccf6bf391029bf9e782e7c27108f5d3c8b04f1180ccb541a07ed1e9bb5a3d8b001a8a5eb72464f34df73a42a82ede58afce520b2eacf898b1e443bf9d757961ed09c944cab4a8304de12dc9edd5910c1c6a335d78677eaeb27edadf6de214e476d8c0cb2127bb04e5045cac71d7820047f80a5468e6f98341853a382920d06b37807645d21624cdccf92e5455d5a129328d73df2ba5f3fe1104a3147f5c4bf39f4cc48c3d8adc262fc64d105a5ff73c4f8f6f2fe24939a91901e8f53bf43ff91c5e141ee9233dd85f53de1ab4cc9c2a97d1bb0878d2764edf8a25d3d54066cdcf014b543bd56f243ffb6ce1b05625c396f91efa150106a3d535f634d5b45e15d50693a4d467e95878ac48b1cd40677abf45fbf43221fcb98ac853ab4e56d38327426774f1fdfbadf104c215f19fd0b25bb3e7beb58a39af9842e2de6ffc7b13453d7d6970b28befa55eedafe584a8606d1e1728bee88c40b40697d41ab4d7c6ffa3459be02c97114890f70425f2d6517d24cc334c049e68b9526a4e3f45d59157ade31cb757706c446961346a5f672131d0616693ead304d1cef4d7c44d2a40350f5ff138398f7d79811d5df960d1bbeafc5ec6b8ea18787b55008e03ae0ed989cbab8b20dc6085a4d791b3fb0e40f27ef460473c8ae91057cc54d6e0421d467d53cd86757e270456183d93d3ceb3be259acfc0e0f625bcce9400dfcffc2e04f736e2e447479fdb23b32a04106d8c2128228e2894e9c4e6f20c77211a7ba2e26c6f646f17b55c867291b462dc4d0ff7e84c3944c28363ec96659ff4efb1a64707c9777256c74b125801c59b1790a5c9278607325d238f411191cf27f1526d1f67e1f2b25010b3d40c1f7eec72042cba1e5cfb020d9d6d4aaf4301a3018d5c6301aa228908018f0bd24856291cb5b468cf809954a77241160af21aae945b22c400d64648f3f8f1dd671633b2afe219273f8b80ba6cc41c51d14272e7375761efa79a530e1252213d57c3601cae9fc0b1e81d4b086c5526377b3212a0f04b35a84bfbf6aeb32a3725ed6dabc8ace6263df96fbe207b0c02c9d2b846a9b66bd5044b4e6e42fae5aab4cf53d4ab835adc7fcb6a6d3087bb7761193b5c34711a3d9505809796234160a4c3b301bb1074cc2112f11708df1d73f9719d4917fa07d7dc04a2fd68f2e278c6c8c7d3680ffd9aaeb4aec725466f70b72282775784eb9901bcc2006681653e906d8f16bb85654ef93fdbcba50afe69350f245c671d3285637808b0535e339b63f372ca8728806c7fecb2c42a8afb00a9fe24e8e27f7f7aa16ee6f5f8a370d949de94450580cc0680184681d147b2dfd45c155352ab14e6cf80cf4e8e31a6faf9d11816b28252c9cab7ed2c3609eca85dca2df6d46263db59501f6513e74c2d932afcac4b74625bcd72fcd1d2ebf776de1005d137f9d6a317e08d43f7bb99b59bd6a83c3e6a6cf0e9db5c68425db209dbaf1635bd27e78a613857e3995e45780fec570ef1edea879d6325ea16a057a607b628a05fa3690966fbd79946f5fda41b75dfad2ffce4155169e3f562f99e5531b6402f61be9f5f66413826ad36b48e9a213b8e6750d203afdd9d48e6162467be003165d274aa363efe743b29995eb00a3c516d64331adbfe7fcc213a0cbedcca5d1d040825bf9389b22d5b0a7c763092b4214ceb8b6de3e362302a0be24b81b7d499d736a2fea465acb5134e6dc6af0910116ac75aef1aba70d356df04262fa4d098c0516172c764f9adf838f89babf1b1a4daa47bd9026e93440dd23be4875229fd1f81272c3205c070380ec5dac54b22bbaa2884f788c330c0c1faa3d499bb786373ccc18bca4a8a44107d795c29cecc6a3c8dd35df16d175fca25c152f6a0449d8e3ce054c2259f939de766160433e042c445a68883dec85d64919be4069836a7a3689ddec14f826c5fe99fcdd98c83fbd2246b673cf6021f905c5e2bdbacaaa695c89c98bcfe43436ef8357c5383294f6be8d3b6c12090526c5b0fc16d153bd897d806bc16ae872d2863b6046791094829edb442c6661b2a26448e53631974b1bb7e03b6529513a8f6448875e5f14a2cab2ace49454d45b4c9ea0ec15b728079eb2dfb0ac5fbc598222b935c140694d6cce570fad4c98771f53b1ad20506eacef71750ed2832ba11b6fd2250c03b12f50c9b20da1b5e1e32d305bcebe80c4043b2dbe8a8c10ff115ec01eb1e3c2a819dd5e6e20f7e3a5a775bed3c7e11c5cc0352b06752915cd2712e2f2ae6583113c9d29ea32e12ba05b881d6b34e9c21b0effb80742e10492cb93cf7cbc961ad9598bc5bca1dc2457c710c53aabc4e1eab978d94bc2a1cc1283dc1eb34a63c1f4b11870b15fdd6ee39a2dc66aa23b0e783aec46cc40bf4bd26a7b9c5b0e68a09543189e9200dffeef82469aee26ff300d104b48c27baa4f77d01ca97d68c3d6be05f2b2a2d04af8ea7346cf8b40bdb4091408978b863708644ec91031481bf08be080cfd5be9de58c880cd64c99bb8bf09023ef173d866cbb3fc5c0adedd4d997e038dc64843df4939223c433a3f7088331534f97339333f306119c45894fbc9e897274653719895c595a3b9109332e0f661a400b443db033b23409b2b4b5c2c46936f491df6d7d4200126daca6a965961b072b5cf5caf5d4d53dc5363926c7fa0e93583ae210cbc0793f5436dd8ae5a21af54471bffc6b45e10763c1a2c5d747ad8c12a205db5de5b035a14708d51f69f01dea41ff2cc32fb23f3d77161d2dd0723de4cecfceec297ce100b789ce3a42da5959f8e8f252f0a3bbb762f5b6347bb93032dc85e581cf60dde1db2b8283c6273c612abbc1ea5e6563e0acb47078d639a9ea9f193ac26f561e25565be37ea19dd0ffc694d14ad43a23a210e25d2cf0ce9c31d9bb9687fae8bf849fcda8069ec070f92d58995eb5c4b54f642e983359210201424cbaa85b3c01dcdb53358373a058310937f954bf09720f81f768195b915a64ea0bd827f5896ddb97aea15104f984ae7d867d0eef153343fd1513bc6681ab882adae9de6ca7369bfddeb8dcad482bfa162f3eae7719c38cc43ba3ddfc726461b22f9c3ae38181df6e4150ec4ddcca6ff60a05987c3ceaa7a5befadf7c69c0d0f1e5851555c75f023d3f7147fce988ae8fb4cade9f9b2b26d4f9d119ce85c6d298e28985bb28b424a7000d3e842d724e2e212a19f650895710492c472870b37dc03be3db9977e25bfc08aa2a5fa7fd9814cf9367383448b055833b3a2334e69431b039713fa9bb5ac5db730f524224e1e8657cedf71ba5bdc80f479b8a74ac47cef491427fcf1650a226a987a618a5cba27599c863d95f46b87bee909d7076162c0c0a529777bb340daa61de1061a21b8501af1052afffd858dd965f892cd6d296094a18a6717d80f39217cf622860f8ebf4700c37d7b09c9c559ad8f0abc0d5bab3124018e1a1165d407065b3f7eb3d53ab13a1c0ddd2b87bb1c6c3be601842ffd27aeb1a17531aa97586b8c7eba06c7e53e5de66c0fba108ede63ff945a6e38c33e08575afb8c9c4c09e7cd3a00577d65e1a45fe9c528def1cca52d4cf016ea76b4ae6c445ce9622eec19b7925212192c25f9ea034d574a54db386093bf2adcc78775aa965dacf3af45080ec4a951be288aafe2a3031161e846158fcd68fb1674c86ba5cf65386596d6cb80381e1ecdd5e74ead2bcfe10a5390999c529312912869a142e9f5923e0509e4724921962456595d98db7f2644db30f7b8f94daf2fbe2417a2a6105b18d4cc6b87a68ea8915fadf7aaed905d46917c0ba93b65eaad0928eaf06856f0dd8e3185f4b6d9dc824d8bbf0c9d3c76345b9b8e1bc30058fc78fc2626480ec23ae4c1221a32ef7040d5e98a8f0586f5f88bf78774e3fecae6aa1fba1f774d1a641e4c885ddaea2dafeeac444b402052d14eff1665b91a74a495ae8471b720f33bc7586e796a992421bd58285c6be07c59a86015a3a2260da6c48ff506629f242caa5c61216cd201c370852ae8520172fd5d1785bf987aa536b89325cda62a3e7314f9315905ebfcb56bfde4a9e9d53faae92b602fab56bfc208bbdc822f4a1b8d867fcd962131178ca26193946033cbbc096a2e1703e38bd18087449441888d7634170be4924934451498ae0e3513e1ced8123202bbd16f6e81037ed239ad234e97efe7d7cd9531a98aef30a8fed9d6143d9cf3385391a622bfe5d356885c9f9dbd8e68b40599f29a8671c06eabcfab616a081b4d4efea9b03ac3da2a63eac78b7af4032ea4752ece16752502e2e608ad9ea7c7492d1e26eed249fda6ae36a236bd383c9236fa244891bf2364a53d0ea7e6ec51d138c985722207b7ed0672197655d4011337fd794ceef9d88d65d9602be81eef2af55bc4a8526142ce559f81e5b7caca6c4b868f6182ed7848f2d0ae4a6a4973294d3db80a2a51b2e60ca48145f568d3aec384eb006115e51e0eecefb60f135b2fb3e48281e221690fd711edc09cd31522a17418d2ec0f688f91a4d6e7d8833a776b3c5462eeef48ca870aaf58a06786bd840667fe7a7a12dd4c27542b2eece8f2b9ffb95fa400c24a5cf6f8da7e5e9f119f969473a6db38fa78628bc70f0519c23872185cd87e577895b09e894117ca39a8c94575a67fa3ff80564746109096cc0c9971f7dd23178478f62fe3e35a9ac0fc66ec641ba0e95e34ce457e58ea02830ee900a995fb3e619540990383db09346df46d493fbb682f27c3fdce9b90651f6b79154a48c9168d6d3f553d5669fe4a23a3c0bc30bd5c396e142115b3610c1f4244fb934e2c00a8527c19b9f5c7b178726ba01b4bd67941b56cc234e3bd3fea31d3737ee45d699e9ee110e5c50505515f05f6adef64d6800388cc414a4b3126f32a694d7938dcdea996330708061813033b8b284daa60fec6faccf2be952b599aadd8dd078df4964c91cb9898e769ab3b53455399f259fdeadc7ef268a7ef42a30f42bb605ee6eb890fb056c07705dd33563dffbbe72e1c87836a9bef3451a797659b082db0e21b45a799caab33debb8ce211f497c1acd6156d0c7d3cd7b3681a9a05b1382f7ff79a0efe4d82d1327c59ce84893c010e0fd0a84032004eeab2ebca218acf051f2fa8f560daa8dfdb09d9eaf18852c0203ffc809f8241c9957e71c220eb464ff499f38a9424f4ec81a212caf7a24cee604e2ede29b50f71d342a84587dc349461523f5da05a7e7cf7f7c2632c8b8fd933093ebccaa2860b996d0ef7e44c20e0ab7a7109275f08d1351abea4638941b6ab2684eff4fc7e3bbd0774f84557201af15798b20ee1200beafabbf5b6d18421776a3dc29131e9d91a942f50fb09e5af1136dc5e0ee7a4d86b44700a26b05cd4605216a2a4cfadebf361b088645e78494fd4809c6f19048829e725a9c5a72626a87666eede755998b77287821ce01e7fc7aef6843d56d5912346a0f18f4c356343bde6d4ee9845f3a123388977ed2cf0960ca9ce5de60e49e12beb9cffcc8fa29423df2ded1cd84fb9be181aa7a02fd5fb6499e45d3c123b56292b85f0c9979ac702de1421e6ba1c72b164e5f2f18c89c722c0bf638288938f733ad47e80ce8ddcbc3e2cf9a5c26ec08a1691c18c9fee8794b35a0d7e2c231a6a94d1a32605de0ac240f286b7a1ef3cc042c64b7762a6a08fb1a7529209b5d218274923ca8065ec34ae4281eda578c877ae96d67c3b0cdc701c636a95972b959b89437e04ee29595526b8ba738447f770cdfbac6efad786b62b8fc2c6de7e4cffb2929a954c016af4cfb447b38cc3bb135239dfb459770353bef492ecad87ee141852cf25dcea0110756376de72dae63daec196b7e917d789ac3e5d068b5ae7abf56bda20ec888e75d8bd15777d1240637c6c6b6f9ff5516508b254605f1be6b5453336b6d28c6670b419f3005f02a0e033e772c82f6701330e6e7d3a46ea09b6d585aba8d70252aae15fcc6fe2d534eb86ca6d538905a560c4c510132b38444951a673b8797d797c42e17ed91b99e0e19de38c1d6a71ddf327ccdaee824b725f167d0eb91b76e61dbc210ea19e69b78547bbe74549d19d4c3ded092893bc52378a25785b930673c1657106b3f30bbc440a652a6bdb86b5b69404ae7f5b5ff283af834017f1ed4b382d66bde30d4d64e71b78889976e0d0535cd991b65cdc2b723c4f198f6790b3b99b4b4bece3ee948ad87a04978603e0b87583af049649d1cd98df79bd421549226d0397c84e8ca5f3ec096a30cc3118ccc861aeba969615fc88303db0273fe4a476eb8c7c3271b90e968d1033470845876e0cf5b8a8b1b7422724b3d51b20a1ea686bdb765d01c1eeff1e4f6f88ef635c672bda231e6171e9492d92f2afeb5eba847435ac574e8bec6e3d435a02c64e9787a29e7ca86a7f6c0f1f354fed8fd0d111e91a56c71bea0e035b6721ac9871410174af3bd3a30ee633945fd066d5ffc269a3eb7eaa8cedeaae85cc80749f28745e6445ee0f2639673b5f4fae5e4a882ff7581d6328581b991301c05799e559b7b4ac2cad323dcecc84c1bb4b1c13b449760baaf1714e18db6f55c594ad283c875a1412475ae5e1162f4cfcf5086efac09c917a4d3e9d06059f4647c8311acad3c08ef85f50287b7052fbab735951af5ad2b113045c323e1a1d419a2cb04234f639c49908782c77c4ee9c0089d013f696b3162884936861deaf0e1233c04fa9a6cf9ef295ba8f45398869207d0b2167c730d679fb48da9b71cfced5b4b691cd2c7cb1304f94162edcc693cb5080af2f8ac58f4a9e1f72e9bda8d30b71f41b168b85882bc87a89cc5b9437acdfbb69ec772518c3c68a72044b2ef5b838e0844c37ebd2262bbe58939925ca4b2b7849860b0e522a4545414b1548d125ea3400c62540fffc0ef8324b984c0284b8a6d2e7975b266c3aeb7d340bd220b10aafda9227db5d7ab5cab0274741afbe224759a42698f8e46ad27be44c2a770e6423cd49760206df628f836639161a72e536059a1a0b26c0e3a585946d657379d10e31a3acf2463e781df97a65d2165e5d5ead48ab16df7edf2ec0f33472919950055218933440aa9de592dabc02fde824a9cb1cb77444c8bb2df19f1b5ee9e6430caaffddc081e9542c3fc91a89143111e1f83158363e4ab776c641d0c1da0ca73a1b96673f52da61517ba1602495dffe6d521743b0c67022cb92c874ab657ba44e10a251c327a0d4021b81bdb70ed992b66c655bf3716038a1bd7ae3965798bdc46985f4f3d20e7324ad944d9d1d2b5c40b9243eaa6c3565b309d5cebda4f2d752dea0314549d9719a05001efcc319dcc66406f85132d75d4ac39a77d2eca80e913dc8baeab62f4930f9a6726d044b464ad933ee1480be53b08b440224382efa85801bbf63fcb3fa2f07d720f92d0c2212869a749a8fe1a6ff8f287eea73ca7f4091181340013203c36727ddf8ab1caf492260c3fe3fc1fd297c18f041562a308d4fe5145e9dab1ecef47e05b8d88c30ffcc40f0084aa328a9d07eba2fdbc46016d915eb14fc65c64abbfba212f245b581989392c61990e062300b6e307c02ec0d5bb83d6be292145063b5dc664734f307f1c0849b94b0965f760e61342f0f2271324e2ea89591e2766b3cb56204d9285711a0e841a2a6ed9b7bb197a6facdc43d32c64ac657370f3e6f99287edd54b29097d045ded94aa4b6a9264a2be7b58a79760c8fa2fd5e5b7a669d7d38bb11ac3ba290e99a6973faae6e3d7f5d475db7cda9fecd9c499869018923761fdf0e6f91d8ce5f26d26b9f67f327a577a85f99a8fb40201b6f30e22b842ceb316ee446cfec4db5c20a32c14c5544d2e3192e4c36e5def4f3c132c64b108ce28415d89351bee905d177f11151da82f736b33ffb349bae9ef490606667d3677f3f6fb6c68a5b6a0e6656f83aa6646967d0186e0ca809b3c4c650bf18dcd639c458d03c88ead84ea3352aef26700b424f3d6f8cd70683160246cb5c65ecbed339c2ec34d8b7e8b857d756cc54a8fd3ee70f64928566d35d9528873d6cd60826f54168d10f5d1b1a709b0f0bc961e04e4a9e045e23b6e2e6bc8b7b108d9a33d7861084a4b73dd32d6ea629c70380e80d15ad03cceb0094f5feec0d09c36f22b3daecd2c767887d208eb58e6c02bac5d419fb5407bc167c2958dd7d231253865a0edc06502c84183e83aaa8cad307c683e3472c0da80e5e08aa149c16f87301c92e6162cf58b8ca3a22dae4c4cf701958ce30b7a2658d4de733765fd2b8baa091af99a74e1a208ef25bb6ac400ff7c1f71c1ac287fdaf6537744b9f74f42f94da7040bb4aa19d2659623ef1f81df4c31c4227a6600ea4efeeb1101253dfe8fb463535e1cc53edf9280f438bd59068d813e103e20f84fd3b0886ab08734373e8a98b8bcd2475bc65386d536cc7e18452068c222b56e236275cf563650c7b49656ed605411527a6ec225695d78c69be4b1308c708f310040a6c134848e7552fdbf06603defdb7f01533811ba9af80f96f0109931005e9f28bf4cf19dddf178ff8a2ef5d73da12ee60db81797fad9115f4ca1b77b972c34564d0688c1f934c278c83bd5a54e8f89e824c1440c785f0d4e55320c5d9da26852b28918e9c5530a448d2e8db92c0b8e3561074150a0fca14d6be362f852afb3c354e2737595fb35c9763350c0a4c6d0b25141aba46ae8a732dccc993a2c17011b5c715c1db47a8878d86c1c60002da055ee8627971af1c291d5a7b7fa8b5e2560957dbcffdf205cb6cab91495d2df87980f832e54292fccdd851ccb336ebf09d0edfda22582f03164384dbfeccc806e9976446a8811e7b23123ea9196ff5118236b312d50f6a84c1457a1ef6a256d175d7212e2f305713998a8380da46c3711301554582d27e512310eb653b1713721797f30e7832d69c54d9db91d5e3b38907723d479657043e5670e761946e9e56742b3ff12e737d46868feb07b5e1e5fb22c6208950b777d3de53876c9edb4e34efadeda96995db95e2c9d84d37936b0bacc89c3865bd9d3a2172e65f66e4077e7adcd97397fc609a777f945971573c64d2c1e7602c39ec8ca704cc2f5f2b964bf45d8e0ebdf2c701f23b81e7f63b4a14fd2e806061c01781b52da6493364c4aa1275da2285f18d4dbe40b8bcf0f82eca79c4960bad409141739f6aa4b96dc9fa9e13ea669e044cdf8713e0d2a8b2be203245df9b41ac6dea37d3eb17150cf53f02ab0ef6e6a01f9c5c320feab5f276060b168e83d38f3faa74cd1e1624b4ae7ae05a93f59d856040af9c77c049a4cf557ed0afff292e3f37379c67f2a03c587928192edb7e1fd1128b6c29b049cf06fac2008a7084238fa71610c5831a9d871c2436bb7e69aacca652043d2ba051660f3b93cb8dac1a53b3f9f9763d7e570fa7002efe26503d8b5bad0d6a68fd152d76fedfe7f6b5c8d3dde5bb39035e2d2e913aa14c92e090c6f45b35c7e814748fcebd2239d3c13061d8a0662180de2a002b5c7c22183048ffe03ea09f81e7bd6727f8e8e896d660b6a2e8a9cc9237324dea618ae797f2f31d35ffaa868fb317fac23b808535720024994ca8a395aa4eec19234cfcea532e8f027c1474e92fc67be68dca3858e2b7a1ffe409faade48e994d0f82f5f6be4aae5777bd171c1738bea43b91b4b3470f02cc76e3fb8fb1793a8343b078c88842563ed71e140c875cf662b604490aa9ca4b36aee3c4e831733f17a8af5327284f4ea76da310c04051185b6de1680bac950c5c9780d6b8219e968b51cfbb7cc6881b04a70f289279b9f879dc0ea6c69570e95ea6451e7a0fb6f73ed55694caf0abda5a51120bfe2fc8577b06f9824808925767a802cd6723a26ee7f12543a9e5f14823306427f9ecf700822133b107a4c145d3b9725bc93901d668fdbd55440a20da61dcd68bd237883c16ba64594a620679aa9f1a6c0be22258913b6c23aacd6cb48106a6b82b6dcec58a27c088a2bc70867cc2d4c5330ec273f8fb834f2a030fcd5375878d6eafd8e0164866c335a7b029ee39145c8b85d5d8673f095289aab5f86d1a8c8a2b6bfa9280e799ff79d399768d87f587ec9fec56482b9871c0c8d6be4232f49c3db785772e5b21e614348ebce0f0ed99b06d694770d2aa7126225d279957e34fd321d719b9e574ed4ace02e414e9573f302ad518b40187395246aa74a734654bba11ce768552f7bed38377f935b33b83463012c7703d486faca93c0391828c58a72dabe371a5ec1d9dfd58d43d4aa0bd850e1246c010495fdb4dd1c9bf960d7bed18af88dd547384520ff00aac0c38af9ac33fe4647c6c28d2b09c5ec102fd3a8aa67de59030d8d324143c34593a2aa11734ab547f143f3e6829454d9e2eb245a7cf5749da29951c4e47dc98f39e8193af2e6f4652c9a86913a064a36a78e2435757776de2c356eba15602b1639fb622841fcd45497f9b6af71533eff908e1be570a0264ef601a46f3ac36fbd7bff0da0f6ea8f213990b1cc01b7e90226d53a609a508aea42e81b4f13837a64c46901a5267cd3a2cc3f5100f9ce79f7b17944dc451dfc087bf95df956bc030ef8e6559ae0625e98dfa6fc2176c17342663ade6a38ca98ea7b2edc7899e93e2d7665d596af120d8d0944c5530fdeb4e4ed4d2c1ce3c2da73de8c33e3606c4b7f348b17548f0c61fd8a71eef5cd424d2dae8b546ec1bce972dff51e9e8ebbe96b317d442444909e938da0a55fa81246f1f5f2ec36bb0a7689b43c55e3e0a8eff8144737590f5c379be760f0ac75c19535d20fbba976e3aecd7f848e6e8ac1f93e174f0544d07762c8015a9dbaf3a4a2f2fbfe1773282f8c5244e416821333bf1aa8bd10379d245030287a0e5b184162080467cfc6a2124a1249a82c25b211d859c012f2838a9accfaaf4eb600ec6595207714d95e74344b994d634c1ff72f02da0cc182ec62304278e467a2ca8489a874195160ae456e50d1df0ff4930be003da220d2810c950c8fcf58b4679ff760585c1e0b467c8e8433d5facda6a4ae0d944f1a9193f80a6a837564ec2b9f06c4a15ff1445a22528142c53d3e582d1e54bb6ec529155b7128614cdff1f7bc40e594a966dd49fc7f6c19dd303c3df02656ce8e9bf91ab4ee4ccd5edc84365c390bd8b75697843e73023679991dbd0def1acb7818f41170fdad4f3d5fa375994c112175c7cad48993dbe3d8dbc01dfbe4d897cfc0a170173ccf3b140e842fc54ba042a042e7d3f885ccaf564232a6fa76461d437b8c2e1f5f815637027e4c1ffca5f9081c144512f36ea4054ebd7d62622a0a5ec3b35502466ada2cc607b3bf371133fc3164d10e848bdd4f2b61a9afd02ed13f1f9ee728dc74d3b3a6fc3112a06aba6dde60459ecf4017fc7891a8ae774330abce1d1ad5e10c319d0838c72c447ccb61c03a001c9c4819fd923075c1b2c1b9e5348b0b64b5fdd867cb911c591ee2897575c828c8a969dcb6dc95eccbfd8bb866ded730b1914bcad51a6047ff9a430c39939bf4b658af40adfababa446469300cc65470746b34940c658b3e124519bd39c30c2705e708ba0d23abe4db422ce681d0c856a5c4e6e91416018fd1203f1ec985da13ba788c675b2d2de99644bbbf4b5713fd5e786e1d84baa9f014fcd15739cf6b1436421e4c8f57185c67e2ac330eef58827e61657c46953232637ecebb0cad54e48dec5d305964d9a84c6fb30b29f3b63c03763b943ede95320b2626f0e06a9c01f0796e1c0542c55c01079c49c0248ca021477f06954dde907f906ac661c6f9b7654a1311636091870c59a57ef37e2c30865ece12681e7c423ed10b6192ceb1b2632b404d44997e39462f0ae02efbd78eb05cc4625bb000d9dfd565df3615004eb4842994fb838bb86ff1d610b251581bc7f61bc29f5cc7dce03e505653f7749344dc0b9fbe9c0d187649eddfdd14bcd1ed3e9470ad72162d7e806670b9470bb638e3a3d5f8717159ad4601e6e7506ea322690b6eb7bd142828e79f75e71d7d147863ecc41fa0ce14b35e92adad68ce7ad7cc8cb6472fa4b6ef3df9ce25c29ceb5b96e3358267aad420ca0358afe2cf8143d359736cadffb69e2c290d6c8e5e78d979ab876cb9051f7ac8e08e3ca8e36e4932c2925fea3f2b44f4eae9dca719fb5633626dbce2a296fa4ba0b12e91c0b26acf16c9afac99a1e6abe15e245a4a51c49c89c0481b53e4689a207bf70a7b0a52094c2863876cf882c8f153c3cb88455ca34dca074e8213b12556cecd820aeea86d31dba5db2935b8897132519a9332aa107ab380153edfeaa137925211ae0ddf88cd0751798c592023b2c6044317bb6ce71070992bd84d93f95f23aa7c3cc508e57521acb19374b18a924a737c5a7ec2b9d98dbf38da616257a82b84f5c9edd57dd8967afa90c9178cfaba09f11d7d455d4b46a6645a4077eef0ff7fe67b78dfede0cb73500cb77bf600f445c6fdea639fdb9d407be36f511d5e6a92fbcfb12643de70f48f1f8418e09dd7144a68b71a8ef3399ed02d81dbef46</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 私密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反思 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 感情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>家规</title>
      <link href="2019/08/31/%E5%AE%B6%E8%A7%84/"/>
      <url>2019/08/31/%E5%AE%B6%E8%A7%84/</url>
      
        <content type="html"><![CDATA[<p>古语有云：国有国法、家有家规。没有规矩、不成方圆。<br>兹武晨光、刘明宇、武气气(小名)及后续家庭成员于2019年7月17日在浙江省杭州市西湖区莲花街道荷花苑29楼501订下家规如下：</p><ol><li>工作/学习需端坐在书桌/课桌前，不允许在床上工作/学习。临时工作/学习应限于10分钟之内。</li><li>吃饭的时候不允许玩手机。临时紧急工作消息或电话应在10分钟内处理完毕。</li><li>条件允许的情况下，必须前往餐桌就餐。</li><li>原则上不允许浪费，但应在肠胃允许条件下。</li><li>情绪低落时亦应准时准量吃饭。零食不计入吃饭范畴。</li><li>吃完饭收拾并清洗自己餐具。鉴于刘明宇皮肤较为敏感，不列入清洗餐具人员名单。</li><li>交流沟通时不允许无视对方，不允许用“嗯”，“哦”，“好的”，“等会儿”之类的回应。确实有事在忙的话，应说明多久之后回应。</li><li>空调温度应设定在26℃以上。<br>以上条款及未来附加或修正条款即可生效。</li></ol><p>2019/7/17<br>武晨光、刘明宇<br>9.    双方玩游戏时，若有一方要求停止，需立即停止。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>root --notebook方式启动时加载配置文件</title>
      <link href="2019/08/31/root-notebook%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8%E6%97%B6%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>2019/08/31/root-notebook%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8%E6%97%B6%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>jupyter-notebook方式启动notebook时，会调用<code>~/.jupyter/jupyter_notebook_config.py</code>. 但通过<code>root --notebook</code>启动notebook时，则不会自动找到该路径。需要把配置文件拷到当前目录，随后执行<code>root --notebook</code>命令。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> jupyter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh端口转发/隧道代理</title>
      <link href="2019/08/18/ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91-%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86/"/>
      <url>2019/08/18/ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91-%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="ssh-端口转发-隧道代理"><a href="#ssh-端口转发-隧道代理" class="headerlink" title="ssh 端口转发/隧道代理"></a>ssh 端口转发/隧道代理</h2><p>隧道是一种把一种网络协议封装进另外一种网络协议进行传输的技术。这里我们研究ssh隧道，所以所有的网络通讯都是加密的。又被称作端口转发，因为ssh隧道通常会绑定一个本地端口，所有发向这个端口端口的数据包，都会被加密并透明地传输到远端系统。</p><h3 id="SSH隧道的类型"><a href="#SSH隧道的类型" class="headerlink" title="SSH隧道的类型"></a>SSH隧道的类型</h3><h4 id="ssh隧道有3种类型："><a href="#ssh隧道有3种类型：" class="headerlink" title="ssh隧道有3种类型："></a>ssh隧道有3种类型：</h4><ul><li>动态端口转发（Socks 代理）</li><li>本地端口转发</li><li>远端端口转发</li><li>动态端口转发<br>动态端口允许通过配置一个本地端口，把通过隧道到数据转发到远端的所有地址。本地的应用程序需要使用Socks协议与本地端口通讯。此时SSH充当Socks代理服务器的角色。<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><code>ssh -D [bind_address:]port</code><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4></li><li>bind_address 指定绑定的IP地址，默认情况会绑定在本地的回环地址（即127.0.0.1），如果空值或者为*会绑定本地所有的IP地址，如果希望绑定的端口仅供本机使用，可以指定为localhost。<br>port 指定本地绑定的端口 <h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4>假设X网络（192.168.18.0/24）有主机A（192.168.18.100）,Y网络（192.168.2.0/24）有主机B（192.168.2.100）和主机C（192.168.2.101），已知主机A可以连接主机B，但无法连接主机C。 在主机A执行<br><code>ssh -D localhost:8080 root@192.168.2.100</code><br>然后主机A上的应用程序就可以通过<br><code>SOCKS5 localhost:8080</code><br>访问主机C上的服务。<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4>配置一个代理服务就可以访问远端机器和与其所在子网络的所有服务 <h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4>应用程序需要额外配置SOCKS代理，若应用程序不支持代理配置则无法使用<h3 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a>本地端口转发</h3>通过SSH隧道，将一个远端机器能够访问到的地址和端口，映射为一个本地的端口。<br>命令格式<br><code>ssh -L [bind_address:]port:host:hostport </code><h4 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h4></li><li>bind_address 指定绑定的IP地址，默认情况会绑定在本地的回环地址（即127.0.0.1），如果空值或者为*会绑定本地所有的IP地址，如果希望绑定的端口仅供本机使用，可以指定为localhost。 </li><li>port 指定本地绑定的端口 </li><li>host 指定数据包转发目标地址的IP，如果目标主机和ssh server是同一台主机时该参数指定为localhost </li><li>host_port 指定数据包转发目标端口 <h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4>假设X网络（192.168.18.0/24）有主机A（192.168.18.100）,Y网络（192.168.2.0/24）有主机B（192.168.2.100）和主机C（192.168.2.101），已知主机A可以连接主机B，但无法连接主机C。A主机需要访问C主机的VNC服务（5900端口）<br>在A主机上建立本地转发端口5901<br><code>ssh -L 5901:192.168.2.101:5900 root@192.168.2.100 </code><br>然后本地vnc客户端通过5901端口打开c主机的vnc服务<br><code>open vnc://localhost:5901</code><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4>无需设置代理<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4>每个服务都需要配置不同的端口转发<h3 id="远端端口转发"><a href="#远端端口转发" class="headerlink" title="远端端口转发"></a>远端端口转发</h3>远程端口转发用于某些单向阻隔的内网环境，比如说NAT，网络防火墙。在NAT设备之后的内网主机可以直接访问公网主机，但外网主机却无法访问内网主机的服务。如果内网主机向外网主机建立一个远程转发端口，就可以让外网主机通过该端口访问该内网主机的服务。可以把这个内网主机理解为“内应”和“开门者”。<h4 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h4><code>ssh -R [bind_address:]port:host:hostport</code><h4 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h4></li><li>bind_address 指定绑定的IP地址，默认情况会绑定在本地的回环地址（即127.0.0.1），如果空值或者为*会绑定本地所有的IP地址，如果希望绑定的端口仅供本机使用，可以指定为localhost。 </li><li>port 指定本地绑定的端口 </li><li>host 指定数据包转发源地址的IP，如果源主机和ssh server是同一台主机时该参数指定为localhost </li><li>host_port 指定数据包转发源端口<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4>假设X网络（192.168.18.0/24）有主机A（192.168.18.100）,Y网络（192.168.2.0/24）有主机B（192.168.2.100）和主机C（192.168.2.101），已知主机A可以通过SSH访问登录B主机，但反向直接连接被禁止，主机B和主机C可以相互访问。若主机C想访问主机A的VNC服务（5900端口）。<br><code>ssh -R 5900:192.168.2.100:5901 root@192.168.2.100</code><br>然后主机C连接主机B的5901端口<br><code>open vnc://192.168.2.100:5901</code><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4>可以穿越防火墙和NAT设备<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4>每个服务都需要配置不同的端口转发<h3 id="如何禁止端口转发"><a href="#如何禁止端口转发" class="headerlink" title="如何禁止端口转发"></a>如何禁止端口转发</h3>设置ssh服务配置文件<code>/etc/ssh/sshd_config </code><br><code>AllowTcpForwarding no</code><h2 id="ssh-代理访问内网服务器"><a href="#ssh-代理访问内网服务器" class="headerlink" title="ssh 代理访问内网服务器"></a>ssh 代理访问内网服务器</h2>hostA 为本机、hostB 为代理机、hostC为目标机。<br>portA 为本机代理ssh端口、portB为跳板机ssh服务端口、portC为目标机ssh服务端口。<br>userB 为hostB的账户、userC为目标机的账户。</li></ul><ol><li>修改本机(hostA)<code>/etc/ssh/sshd_config</code>文件 <code>AllowTcpForwarding no</code> -&gt; <code>AllowTcpForwarding yes</code>，并重启ssh服务。</li><li>在本机(hostA)执行(一次) <code>ssh -fNg -L [portA]:[hostC]:[portC] -p [portB][userB]@[hostB] </code></li><li>在本机运行<code>ssh -Y -p [portA] userC@localhost</code><br>既可以通过hostA来访问hostC，且支持x11.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> 端口转发 </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多端编辑Hexo博客</title>
      <link href="2019/08/18/%E5%A4%9A%E7%AB%AF%E7%BC%96%E8%BE%91Hexo%E5%8D%9A%E5%AE%A2/"/>
      <url>2019/08/18/%E5%A4%9A%E7%AB%AF%E7%BC%96%E8%BE%91Hexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/a0824fe2e066">参考博客</a></p><ul><li>克隆Hexo项目<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:mission-young/Hexo.git<br></code></pre></td></tr></table></figure></li><li>安装hexo<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo -g<br></code></pre></td></tr></table></figure></li><li>安装node模块<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> Hexo<br>npm install<br>npm audit fix<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 多端同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS更改sshd服务器端口</title>
      <link href="2019/08/18/macOS%E6%9B%B4%E6%94%B9sshd%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3/"/>
      <url>2019/08/18/macOS%E6%9B%B4%E6%94%B9sshd%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>macOS ssh server默认端口为22，而学校网络政策一天三变，突然间无法在校外连通ssh。因而需要更改macOS默认端口。<br>macOS更改sshd服务端口的方式不同于linux更改<code>/etc/ssh/sshd_config</code>的方式。需要更改<code>/System/Library/LaunchDaemons/ssh.plist</code>文件。<br>其中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>SockServiceName<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>ssh<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ssh代表的就是默认的22端口，将ssh修改为合适的端口就可以了。<br>比如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>SockServiceName<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>67<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在设置界面重新关闭和开启ssh服务即可。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sshd </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通话登记考试相关信息整理</title>
      <link href="2019/08/07/%E6%99%AE%E9%80%9A%E8%AF%9D%E7%99%BB%E8%AE%B0%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E6%95%B4%E7%90%86/"/>
      <url>2019/08/07/%E6%99%AE%E9%80%9A%E8%AF%9D%E7%99%BB%E8%AE%B0%E8%80%83%E8%AF%95%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://bjbm.cltt.org/pscweb/index.html">普通话水平测试在线报名系统</a></li><li>报名时间: 九月初，具体日期查看上面官网公布信息</li><li>报名携带材料<ul><li>本人身份证原件</li><li>近期电子版照片<ul><li>390*567像素</li><li>相片文件命名为考生身份证编号</li><li>照片格式jpg或jpeg</li><li>相片背景色为蓝色</li></ul></li></ul></li><li>官方App: 畅言普通话<h2 id="试题组成"><a href="#试题组成" class="headerlink" title="试题组成"></a>试题组成</h2>普通话水平测试试卷由四个测试项构成，总分为100分。</li></ul><ol><li>读单音节字词100个，限时3分30秒，占10分。目的考查应试人普通话声母、韵母和声调的发音。</li><li>读双音节词语50个，限时2分30秒，占20分。目的是除了考查应试人声、韵、调的发音外 ，还要考查上声变调、儿化韵和轻声的读音。</li><li>400字短文朗读，限时4分钟，占30分。目的是考查应试人使用普通话朗读书面材料的能力，重点考查语音、语流音变、语调等。</li><li>说话，时间3分钟，占40分。目的是考查应试人在无文字凭借的情况下说普通话所达到的规范程度。<h3 id="读单音节字词100个"><a href="#读单音节字词100个" class="headerlink" title="读单音节字词100个"></a>读单音节字词100个</h3>排除轻声、儿化音节</li></ol><ul><li>目的：考察应试人声母、韵母、声调的发音。</li><li>要求：100个音节里，每个声母出现一般不少于3次，方言里缺少的或容易混淆的酌量增加1-2次；每个韵母的出现一般不少于2次，方言里缺少的或容易混淆的韵母酌量增加1-2次。字音声母或韵母相同的要隔开排列。不使相邻的音节出现双声或叠韵的情况。<br>评分：此项成绩占总分的10%，即10分。读错一个字的声母、韵母或声调扣0.1分。读音有缺陷每个字扣0.05分。一个字允许读两遍，即应试人发觉第一次读音有口误时可以改读，按第二次读音评判。</li><li>限时：3分钟。超时扣分（3-4分钟扣0.5分，4分钟以上扣0.8分）。<br>&emsp;&emsp;读音有缺陷指读1单音节字词和2读双音节词语两项记评。读音有缺陷在1项内主要是指声母的发音部位不准确，但还不是把普通话里的某一类声母读成另一类声母，比如舌面前音j、q、x读得太接近z、c、s；或者是把普通话里的某一类声母的正确发音部位用较接近的部位代替，比如把舌面前音j、q、x读成舌叶音；或者读翘舌音声母时舌尖接触或接近上腭的位置过于靠后或靠前，但还没有完全错读为舌尖前音等；韵母读音的缺陷多表现为合口呼、撮口呼的韵母圆唇度明显不够，语感差；或者开口呼的韵母开口度明显不够，听感性质明显不符；或者复韵母舌位动程明显不够等；声调调形、调势基本正确，但调值明显偏低或偏高，特别是四声的相对高点或低点明显不一致的，判为声调读音缺陷；这类缺陷一般是成系统的，每个声调按5个单音错误扣分。1和2两项里都有同样问题的，两项分别都扣分。<h3 id="读双音节词语50个"><a href="#读双音节词语50个" class="headerlink" title="读双音节词语50个"></a>读双音节词语50个</h3></li><li>目的：除考察应试人声母、韵母和声调的发音外，还要考察上声变调、儿化韵和轻声的读音。</li><li>要求：50个双音节可视为100个单音节，声母、韵母的出现次数大体与单音节字词相同。此外，上声和上声相连的词语不少于2次，上声和其他声调相连不少于4次；轻声不少于3次；儿化韵不少于4次（arurierüer），词语的排列要避免同一测试项的集中出现。<br>评分：此项成绩占总分的20%，即20分。读错一个音节的声母、韵母或声调扣0.2分。读音有明显缺陷每次扣0.1分。</li><li>限时：3分钟。超时扣分（3-4分钟扣1分，4分钟以上扣1.6分）。<br>&emsp;&emsp;读音有缺陷所指的除跟1项内所述相同的以外，儿化韵读音明显不合要求的应列入。<br>1和2两项测试，其中有一项或两项分别失分在10%的，即1题失分1分，或2题失分2分即判定应试人的普通话水平不能进入一级。<br>应试人有较为明显的语音缺陷的，即使总分达到一级甲等也要降等，评定为一级乙等。<h3 id="朗读"><a href="#朗读" class="headerlink" title="朗读"></a>朗读</h3>朗读从《测试大纲》第五部分朗读材料（1-60号）中任选。</li><li>目的：考察应试人用普通话朗读书面材料的水平，重点考察语音、连读音变（上声、“一”、“不”），语调（语气）等项目。</li><li>计分：此项成绩占总分的30%。即30分。对每篇材料的前400字（不包括标点）做累积计算，每次语音错误扣0.1分，漏读一个字扣0.1分，不同程度地存在方言语调一次性扣分（问题突出扣3分；比较明显，扣2分；略有反映，扣1.5分。停顿、断句不当每次扣1分；语速过快或过慢一次性扣2分。</li><li>限时：4分钟。超过4分30秒以上扣1分。</li><li>说明：朗读材料（1-50）各篇的字数略有出入，为了做到评分标准一致，测试中对应试人选读材料的前400个字（每篇400字之后均有标志）的失误做累积计算；但语调、语速的考察应贯穿全篇。从测试的要求来看，应把提供应试人做练习的50篇作品作为一个整体，应试前通过练习全面掌握。<h3 id="说话"><a href="#说话" class="headerlink" title="说话"></a>说话</h3></li><li>目的：考察应试人在没有文字凭借的情况下，说普通话的能力和所能达到的规范程度。以单向说话为主，必要时辅以主试人和应试人的双向对话。单向对话：应试人根据抽签确定的话题，说4分钟（不得少于3分钟，说满4分钟主试人应请应试人停止）。</li><li>评分：此项成绩占总分的40%，即40分。其中包括：<ul><li>语音面貌占20%，即20分。其中档次为：<ul><li>一档20分语音标准；</li><li>二档18分语音失误在10次以下，有方音不明显；</li><li>三档16分语音失误在10次以下，但方音比较明显；或方音不明显，但语音失误大致在10次-15次之间；</li><li>四档14分语音失误在10次-15次之间，方音比较明显；</li><li>五档10分语音失误超过15次，方音明显；</li><li>六档8分语音失误多，方音重。<br>&emsp;&emsp;语音面貌确定为二档（或二档以下）即使总积分在96以上，也不能入一级甲等；语音面貌确定为五档的，即使总积分在87分以上，也不能入二级甲等；有以上情况的，都应在等内降等评定。</li></ul></li></ul></li><li>词汇语法规范程度占10%。计分档次为：<ul><li>一档10分词汇、语法合乎规范；</li><li>二档8分偶有词汇或语法不符合规范的情况；</li><li>三档6分词汇、语法屡有不符合规范的情况；</li></ul></li><li>自然流畅程度占10%，即10分。计分档次为：<ul><li>一档10分自然流畅；</li><li>二档8分基本流畅，口语化较差（有类似背稿子的表现）；</li><li>三档6分语速不当，话语不连贯；说话时间不足，必须主试人用双向谈话加以弥补。试行阶段采用以上评分办法，随着情况的变化应适当增加说话评分的比例。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 职业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 普通话等级考试 </tag>
            
            <tag> 教育 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行编译root脚本程序</title>
      <link href="2019/08/06/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91root%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F/"/>
      <url>2019/08/06/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91root%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>root可以直接运行cpp脚本，或者解释运行，或者编译运行。但都需要借助root编译器。这样一是速度比较慢，二是当需要执行大量任务时，难以实现并行。<br>因而产生了将脚本进行完整编译，使之能够脱离root单独运行。较大的项目用Makefile管理比较方便，对于较小的项目，使用单文件即可完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -o <span class="hljs-built_in">source</span> source.cc `root-config --cflags --libs`<br></code></pre></td></tr></table></figure><p>其中<code>root-config --cflags --libs</code> 用来生成链接命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root-config --cflags --libs<br></code></pre></td></tr></table></figure><p>结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-pthread -std=c++11 -m64 -I<span class="hljs-variable">$ROOTSYS</span>/include -L<span class="hljs-variable">$ROOTSYS</span>/lib -lCore -lImt -lRIO -lNet -lHist -lGraf -lGraf3d -lGpad -lTree -lTreePlayer -lRint -lPostscript -lMatrix -lPhysics -lMathCore -lThread -lMultiProc -pthread -lm -ldl -rdynamic<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> root </tag>
            
            <tag> g++ </tag>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp配置内网穿透</title>
      <link href="2019/08/05/frp%E9%85%8D%E7%BD%AE%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>2019/08/05/frp%E9%85%8D%E7%BD%AE%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="frp的作用"><a href="#frp的作用" class="headerlink" title="frp的作用"></a>frp的作用</h2><ul><li>利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。</li><li>对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。</li><li>利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。<h2 id="frp服务器端配置-公网ip"><a href="#frp服务器端配置-公网ip" class="headerlink" title="frp服务器端配置(公网ip)"></a>frp服务器端配置(公网ip)</h2></li><li>user: server</li><li>passwd: serverpasswd </li><li>ip: 162.105.2.3</li><li>host: server.com<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">[common]<br>bind_port &#x3D; 7000<br>vhost_http_port &#x3D; 8000<br>[web03]<br>listen_port &#x3D; 5000<br>[web04]<br>listen_port &#x3D; 5001<br></code></pre></td></tr></table></figure><h3 id="frp客户机端配置-私网ip"><a href="#frp客户机端配置-私网ip" class="headerlink" title="frp客户机端配置(私网ip)"></a>frp客户机端配置(私网ip)</h3></li><li>user: client</li><li>passwd: clientpasswd</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plain">[common]<br>server_addr &#x3D; service.com<br>server_port &#x3D; 7000<br>[ssh]<br>type &#x3D; tcp<br>local_ip &#x3D; 127.0.0.1<br>local_port &#x3D; 22<br>remote_port &#x3D; 7001<br>[web01]<br>type &#x3D; http<br>local_port &#x3D; 4000<br>custom_domains &#x3D; blog.service.com<br>[web02]<br>type &#x3D; http<br>local_port &#x3D; 8888<br>custom_domains &#x3D; nb.service.com<br>[web03]<br>type &#x3D; tcp<br>local_ip &#x3D; 127.0.0.1<br>local_port &#x3D; 8889<br>remote_port &#x3D; 5000<br>[web04]<br>type &#x3D; tcp<br>local_ip &#x3D; 127.0.0.1<br>local_port &#x3D; 8890<br>remote_port &#x3D; 5001<br></code></pre></td></tr></table></figure><h2 id="ssh代理服务"><a href="#ssh代理服务" class="headerlink" title="ssh代理服务"></a>ssh代理服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -oPort=7001 -Y client@162.105.2.3<br><span class="hljs-comment">## passwd:clientpasswd</span><br></code></pre></td></tr></table></figure><h2 id="web代理服务"><a href="#web代理服务" class="headerlink" title="web代理服务"></a>web代理服务</h2></li><li>web01 <a href="http://blog.service.com:8000/">http://blog.service.com:8000</a></li><li>web02 <a href="http://nb.service.com:8000/">http://nb.service.com:8000</a></li><li>web03 <a href="http://162.105.2.3:5000/">http://162.105.2.3:5000</a> <a href="http://service.com:5000/">http://service.com:5000</a></li><li>web04 <a href="http://162.105.2.3:5001/">http://162.105.2.3:5001</a> <a href="http://service.com:5001/">http://service.com:5001</a></li></ul><ol><li>当公网ip有域名时,采用http和tcp的方式都可以访问内网服务。</li><li>采用http协议时，需设置子域名，此时共用一个vhost_http端口。</li><li>采用tcp协议时，需对每一个内网服务，单独开一个端口。这些端口在frpc.ini中设置，每个内网端口对应一个外网端口。</li><li>只有公网ip而没有域名时，且需设置多个内网服务，可以采用tcp的方式。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 内网穿透 </tag>
            
            <tag> frp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS设置自动化脚本任务</title>
      <link href="2019/08/05/macOS%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E4%BB%BB%E5%8A%A1/"/>
      <url>2019/08/05/macOS%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>北大网关断网自动重连脚本</title>
      <link href="2019/08/05/%E5%8C%97%E5%A4%A7%E7%BD%91%E5%85%B3%E6%96%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E%E8%84%9A%E6%9C%AC/"/>
      <url>2019/08/05/%E5%8C%97%E5%A4%A7%E7%BD%91%E5%85%B3%E6%96%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>编写脚本<code>autoconnect</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>curl --connect-timeout 5 <span class="hljs-string">&quot;baidu.com&quot;</span> &gt; /dev/null 2&gt;&amp;1<br><span class="hljs-keyword">if</span> [ $? == 0 ]; <span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;link already established.&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;link lost, try reconnecting...&quot;</span><br>connect -u <span class="hljs-variable">$&#123;账号&#125;</span> -p <span class="hljs-variable">$&#123;密码&#125;</span>  &gt; /dev/null 2&gt;&amp;1<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;link established.&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>随后赋予该脚本执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chmod +x autoconnect<br></code></pre></td></tr></table></figure><p>将<code>autoconnect</code>和<code>connect</code>移动到<code>/usr/local/bin</code>目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mv connect /usr/<span class="hljs-built_in">local</span>/bin<br>mv autoconnect /usr/<span class="hljs-built_in">local</span>/bin<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网关 </tag>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管好我，爱好你，顾好家</title>
      <link href="2019/08/05/%E7%AE%A1%E5%A5%BD%E6%88%91%EF%BC%8C%E7%88%B1%E5%A5%BD%E4%BD%A0%EF%BC%8C%E9%A1%BE%E5%A5%BD%E5%AE%B6/"/>
      <url>2019/08/05/%E7%AE%A1%E5%A5%BD%E6%88%91%EF%BC%8C%E7%88%B1%E5%A5%BD%E4%BD%A0%EF%BC%8C%E9%A1%BE%E5%A5%BD%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="85fa52167d82e6e0b377b06eecadd4333c9a3548313206c6eef1089f0c4c7530">d92e3190bee28130eee617d8164260182889bb9556f2b14bcfa0fcbf1d0def50703f6ba4e6a34abfc9ebd1cf1544c28af8e96b8c0b6240de7a52f2cf725c8eeade5aa37761bac4edd0fb402579f3e18da5fe4e6653c90aa81df55a146dc402156e02b15422e7bc5093324125e2091cddf6b729c17827abd13e27e34d4daffef079a242bf08f364d9ab2021603ddf27aacc6534172b3e9f8f303cc65d283e3cf2adadca0f49e6421462b4a4e7b9ee156b1b8651323f000dcb8612679af5f4afb73710c533c4979d993b6aa6858baa993783e2495ac1b8f493fec98188a602c1d7991f73c67eccd68743f45303e99a3e915a01e2fe73e6696eae279d9282cc5e71cec1b088af8ddce792da307d8a5357426c094679a188dcc3078b733868cbe7a3e28979b7e56ee16be0dae64cb3695e2810d13b01382fd32cc010a917fe83b9df35c3d47f50d9e9de9130fe46f1c29497f1b3b46bb7656a87b57da5531ceb3392b4fccbcfef3bd776d365e9f645022f3b6980b4799fc3591df9b23ccfd5560f9582a6e653ca2356570a8830a0b34e2924d01401034c3f65039af8fbbfd8f08f38f5ce31d0b6224a3c46abf1ad0cabc57eb4a2a79e0790eafd7ef27b236b0601249db17a3a0d70149c4f0b10837cca6485a994fb3039c6c6b48d0d4c82cbd50399959fbc1d3b265ea7cd3c97114e93e6fb2d0dd9a8ded23a82694d0addc08c344c011988e4dcc8513db70002abddbf3e5fbd93324d07d9aafea7f50529552fba1997fad8e627e3de6dbf946b52b00f1d477ddb5735ea59aaa05dc6d41843df61e481b9bb3692b295e0599f1ce2e820f1b0f5e272799e3cfe94448e4cbd0e7834763e0df1207e93581a4847f3108eaa5c71b5ba952d4b24ab4ada0e57ab6d53ca8a4f939d46b5f64f7e7e3d1cf549f5cc3806e29e45e54b027f0df444756e7aae1b38a4ec9ccaa3f7fcd18df95af3f240e9cd9eea3dbf9274b80edbef4299d5379485de9b1b3a34eb37d048f2c1671a4841ba7ce8b95eece379d4acaebce7cfce4755083a4a4a67f6c7f43f71cb088138df926eb5fc74f6407c1d5147948aa83a90dbc87a44fc628f8ba8388027287df3ed2487c4f1d6c3847433ebad55c24ca1627215277b18463b03d2e27e84e168665d08b02a2f9f4e7eb473efc14fe4fade4d2093217ab6102d8bfd147d7d0008ca5ee6dbc8b35a32421a988ee7fcc97861ed43b97f592f111ffe7d6f62fb0c6951cc0a062ba672b8e3939866a36b0d7da3baa060f8b19f3680a4fdebb9d76bcbb7d566c7e6cc39f774fa6f60db9f8f5606873d13367c91a5a3651e9b7b62f3e2858ab94448ff24b3a0098808c43eb3be68dc8503aef53ba4fb2d6779674154ee6318e6bf7cc13b2dc2c54bca91f05c379f99bbfc0729dee51a5dbdde39ca61952c2ce289ffdb36b0f535f5adec174667b6ee4454b124987dc40e5bb13f9b4fef3b641aaa795785e0bb3bcf212029a6de7033c4b92c402655bcfd4504ccb6de2fe4f1fd175e05767f3ddb0d32999f2de66438a11ecad2d8444a0600a909526c631d707f10e1239e20a4eaeadcfe73ffe5cbe3323bf99e9f558f749c8a38ee2b481335fcffc30e68d6e8c80c279629a2b63366c5fde7aae0df487cc065d2eb29f5294cfc9ccbe3b2ca46fce0242147aa7e22f5895776f8f9797ab582edcfd0a891ded91ddab6b3b22480ff8a473b54a237731345abc020491d18b6b9b2fa629455d13b25da8ae49a1baacaf2d3b11cc83aebee543ccf25c7939a8a3556271cda78170a43370ca5e151be711a396ffafec3400e0b7f68464cc6d0414bb8e61a5f6c62051f59cccba1ee9b0000bb7ac36b5a77bc0d14e1ac88b3a8ce90485e3b86c8048ddef75eb770acfc8a272314a3ed0c0f1f8a4b3e642928343d4171e5b280b091973071f097e92807330bf51b08cc9f0b9f991cd9c52cdae5079f559311396282541f23d83850b53b317a35e1d776d7214ea1c235f3220f3ca8243ea0cf6261648f3328e2b13425adcc2b7eb790d4b6aaeee6dc22d6fb4529f9b97f37afa73dd6dfa37c22955152c4f6d54255563dcfda9193d8658db80b6b362f7ce714cd800327e7c05521fca76fa1b783fddde983492d3dbfd84d313ab4c0096d458d82593ee8100acc2c0acec24759b58bb68558f2154e69ed4ed6e329e71f19b4652b4a3b9a2023f700f60daeaebe5298630c24aefbf09bc05de7442a911dc34d47ea409b43aa34a3ddd162404f4ff0d1ef1bc2c12328e7362914a778565103e2dd0393dc9cb4cecb8487947708a2f8b99339d0fec1acc045d7acf48f96dee1da988b0192fcbca81a7a986efc4044d8e3f00f119b69d9d1577f06e2079b2080550dcf0278e927196d7d89601ef058ea85994a34acb68586061fba3d16a82ea528e66bb7091e4c874f4ca48ed5daae994872346cf47a3e947d3699e193e070f32a3d9cf24c3e4bc28f0ad4cff6dd98a1067a694f6de12223a54666e24a6fb76738ba5fa9b58db0d9062ff27593b7e9e17535f8d7ae33220f563e0825b010059c12294793f4a2fe10f284141264710224ae9871b27c5923a55f0773728585780332dcae85a9df0788d6c1c0760df44b07c79cea5881169a2ac745a46785e6eb5ce5be0e2f095878a7cdc70e7626123c119875bce18e959abfed4902c55daf914a6c0650ed58e6b4bd061b60e3ccd5d64adb0746dd1895e111a8856d069d6e4e38b21925f803a2b393728a6d5af180f25c1f72ecae49bb9a626d7dc15d1ad7d30bf911a5ea3ffe537c3118dd37b6703238ca9a03c4bd09ee49d902f56c75c448994e07d801c7ca62a3792ac22045e6fc2b56c88d6f469b727f91bf846d58e60c366f63613b0049d7f3c6b0dd2803e48c3c2d21a90ef28cb191760f1f1fce64f05b004ea296b59fbd02a891c5c7ad75d0f0edd47c2108fd9de781ac77d8e665d25674727ff469c2addf85a98f12076fd7c3107f61a457bd733d8a0b021805c55541cbd7e7631e4045afea4229269f6c559052eba58f2dfdb9cf452c41922b52356a01d6faf1dee8289512b6dbc859444132dabf474186fd3b8bfe66b2ff8b12f362f21af90e5d09b2c17673d0c438ee6b955e579e67e22d2a7350bb9db1b9e1afceca7415ac96832b6a8f38ad7c99a9ea0b8214f6973f68d9cfa16038daa00c6c09b34c8c202ae28950abb8f2ba84d741150c124b6dbb6d2866514004c4203a856dff19e057ffb2e7aac94300e571a97ce9e162ca77356098534264381a62849afc420e26669d3e7288ad73d06f2076f0684975c557b4eaca2a99e8f59d3c673433985a460d7abcdd1c2d456148b2dccfc4ae174f4be85796e048201372c7afa466a78cdbdae2e82d9e1bf1c13339904bd603efc057e2a591333702bb57c7303a36cb34a13d51eca855e9890628dcf72c33d06e407bc32a209f8cd742051a91c25a48073920f8039bb73ddacf2a8f98be7e38a6b846aa9c5a55a9f276a60aac4880172212d4c43e1a3e87406f606732004e7c6882d52f96ea02b963558b0a8b6a2856cdc5096a429029a4902f12f4fe2bcec19dafedc46295f6c388b68dfd7db85dea129da062b3746fb8342110a80eb6a8a0bc9f1edc684c67fab5e7fa23018b4c92dd87fd42a5d306ebd0d1b5ea84130447eb91caec36e5b9a530bf27052ef8be09b22a2655428e8608571d56962e1ce405dcce5fb60f7dca65797a4a16bec4f0e5059e4501b854b8c04e9d4cc0707dbd6c7025457cc050bfde060df2146c32590d043ffc8c974fe406eeb8e791363a419fd607df8c9f192a205e462cd87a69b3d3392540d1e6e9694869dbd0eb865e59bc661e35669b4228fd9b3307a2b149a4e158d6401eec689ded1613f707ecbb4379976ac785e0181d2e35c5542e8b0cae3aa7bbb99a1bfa69a6e3a7c08145d40d995786c0cfa63f598cc6b0cd3d45b1bd41225a7f3a5b203dac8b19163d8161b9398bcfa56f26279696ad3bf8d56b6f2423fac299c8c7615f8c8459d3759b74e4ae187be44815fba365afd962d02231b7de05712198202908efb3dec872712a2a735995aa557d226dc4be2caffb5cf89b5448a3c1418509dd6c82b69be7f104dfd57266d824f5d35e729f77dfd021031b45d01c25759b7bc3f7226a1e8f96eb86fba98b94146b0b5e7f3b96623237ea9326209505bc5f9c0f6cece94c43b568db287800d1cb376f78a606f38de4b6b03166a3d35a7cdf01f4df6181f8105f710c0eeb38823831379ea12593f3957bc2320e8285371b9279ba0def17108f764420ccb09a10ebc05884f4f9da3c77330e37a40dfdf5d826a0592bf58a0a5eeb8f79e3bdf7d866eff92a5d701e8106b7c9d5715bdce2137d814074be0574cd06f4ed90cab119a19de30aea4c0b0462cd8bc70b44dd8faa012a4ebe45c8e0e4b687c26c906350e11724a13be64a36682fb1dd4555f1e2275d8b4844d0411aae28d4c395c5270d67eaeca03dc95464f1f2a5e1c59b98acca3d85daab4b5da2ab1b994e8d6a7db2e4ac087b71fbc8f626f1b809a603a140f736a4ee42b4bbaaf7675ee8eef27d58a8892eb51d5ec36198b38c8485d2d91c8bbf62546b49a8317168e4b031fe744d0012c16dd97d5997e14f9cbffc76f0cf66df2660a89bab99c14940ea4a01fd806ee9fe251f3556ede92e5a65da3c13a93122b74cafc71e2f1cb5a8d650bca9e6242308df1c58495a94748a8b625f66028a2993bba35f2cc91d1169c18731ab4b21418e02e5f8a06dc7abd333aa835ddc8a7f2d20629f4ea3c9d0db3a5907d640ca0535ef8ec75cceeaf554d70d6874554fca5778fdf9fb56a3ca1d404bf20924766c8fe2bd4a4fa656815ffbfbd6c0b12f1eb10a2d1bde17b785587e1dbe168695a9f1740878380b513a689eae8a54e6697bc9f8ba102abec20150436a22fc366319826d053f90355ca3d9182dab671d75c13a93f7c6c4c68384f67eff62e217c0ba64100496fc22472b28326cc5b052eb1477e700c96d182eab73c3ef8bf8c942a857e293665d014279e4c7f31c7f84ee8a9ac2700d801bc6ea8b9c47267bd9be93495893f12e6b8b81e829854c8869ddbe9e729ca3ace00dc4adab1b04b8719b494b91a2dfc68db52f924becc37f1ee3163856b901a705f0cfbbd0fa8438af89b53ba7c77cc210ec8bf3d4897bf2c99cd014005099978b22a62fa3ac7be2a1428c81595635dfdacf7771ebb0296f29c08bee4e709a30ad4d97c3b6e2c2069265f3c58ce78002e660e793f30ebd94b1412cc7c84228f12e1f4ad9ad04b2be6604f816eb62d4c9ab3fe0bd3dae328e3683a6f0092b34d328924f4137e535c4cb9258ce193e5c3e5319bab4c94ff64da5061ce351c1f81387e4860ec35cf8ec229ac7d9cdb5f3c6574311ddd2bc45fa1c88a10c3002a780ac7bdd72ecdd30ecc22c895d6ca6b1abfb54b9d8f053aca42c6de387343946a5eb59cd47606e1391716495ef2240f3614969c99a3efbe09d10c7ec685b06e4f23b8b9d971a9ed348fb303e227dac7ad01ec980c5658853c7b4efc9888dcb3c1392e70cdd76ab5366e7b4094e30851ff99f56569ccb4f9da86f2d5dc730150aba256ab0cbf6a1294aa7e5249d47cfc01c6bb2115a6adac219a9fb2ee42666c4d0404e37ec7959b8f149ddd7714c6fe7e23ef1e285600746e79f324fb7ea5648d60ab19fd73a46a2f5f58abde4e7febf1c47912bbd5047a980564b7f6ae3b003cc280654f2770de25cb267b91c1b60cf40952fe09322f3538ac3ba0214949ed66e79837abce083980c1d9f1fc75171e4ff48718a603aa5c8110cf8c3f87e45136e4298930d3d056fb9ee24aba706ba2084a07dda2663be98831acd9c303819193bb949666250c20b582d4c49244fec6640d200a36635a311bf21f5300154f725fb1da28e00ea49ebf34e34320ae532b7507178f8957f2e2c5572c3687ea6cc6e284438dc82c9e0fbc18513203bab5299c531786cedc6eb909075e488a7035aa13c7effcc29b7d624f2c7f2e6c6b9f8cffff2bffd4fa62c732264f9bef9ee13b1a9ce2b3265e43a6e6bc42f88ad8fc6c306ad59ae06249ee53f26d0311facb0ce53c4f85e558728a0f4b98687e74a7da1031309fc5df62dcae142cf56efbbc4cf09fd84a318322be5873b6a2a9313f1c390c029bbbfd9de6ba96c9f8928069adf2a50dc6f981fe87f800ae701121718e6350558925115bcfdf7b3131dcc21e3dab9c82f1d30d87a6ccc41a4ddb057b5c0c8804f9e4229a5717e314c91e91a8ff6141d54aa68a1e12fa01ba68f5b4997328a77a9bc7c77f28c763c081470b858df60fa34b12ed9534b7569bf08e4daf89a44255f3d88a373bcedc8a6d2c5bbdeb5802ea472857ee8ca7a925b8eca22925cba686e3430aa2a4a86d0ab9cdae23353d5d4b770c2236653709831eb1d6d0f1e1e1e065aa01c94550312a4ba0a41f27ac0ec116a55c8744cebdde70b3a538d527d2e686cddbeaf91cdc2e1e894ffb1410fa9d2a56b55481606a50db58d626bd10e6e0db8130ff373f39ca4f97d66d8c9a49ff8e5e4a6af7b170e237f048fe4100d723f86bdc3a9f891066137a31cc3337303ff75858c3354357a8c3643bfad2cdd19818ef303ffd618240ddee90f890fcc2c159bef31bbf06ddedac0b9ca43e84598ef8c1285cd50fac13e0a7fffe9a7b442fb7bc94103b1e6bc8428db76b09f6e3697e86a5a52404edebfa19a64e0566616e40364841d8c3e3c83f93212935f94992ba0f7a682c27895a6a5711207fbe641a55febc3079e15b7dbeba4ac4c87dce0321fce1ae3594c2427aa215af7df059f15e0f6e09a091a915e116f658de671bafabc1cc2087bcbfd1be8802320908df59cb5f59f80fc1ee92749164dd1faa901c94743261531bc2b360f2dbbd1b1b049a39168e169e39f63d64b0d8bec7a9dfc85813a423266f57a591a9dfc053006fc09474b6a481034fd089b38cba43a9d988df5e6692ba0e28eb77bea0b079abf7b6b0aad07e5fa68f44890076154858afe0d6bc9a544fa051d9141da35bc59d5977b0566244aa74912ca21f753edf076dc8df7c9a5a70c3cf8d1b6e2ce54518dfbf8cbab93b9509450225d17577aa017a04bd60d236ed29740ecd16bafea96e09160800b4f345051d0d1bda50ac734a9282b52c667c75a4b88b47e85780f113ad349f394e34d5feeb22f91d2af5629a306ec9e62f7a59a75eebd6c067ccf421b753981a6c88faa3cf337547ba017a97c8caf79c129173e44d54f4ce29789f5216f4b359cea7cf3812ecd3ad4a359f3f8c9d551098e0aa7a285ea6a923a153a3a1f0c7469b82bdddc805749d7a58d79f770692ccd2f5f2dfe5a8d5fb80e7f30aadb3083355cfbec93f28249f8090642fdcd96918c529ba89895a92f26b47b41e8753f70d8ceca4e8f097e099e1cd856f89ab740c5b1bfcbb7e1c7326b805a5c41dd7799f49e452e8c2cbd93cbbaa75d64b7c70aae7ea29156f0660958b319ac81fb7825d54c9098065338ab4ace742a0bdc68e7fe28aae18b20c3642b60c606e52f64257275cf62e1f4b8c684d237defe0616ea959f4bac65cfd1625ac4de28bd8015418881d6dd6eec86398311f14eba94afe899c0fbf0aa8e3e5411227449cc555220926fff74d656927b6230f04cb7c2c0f44e1e7eac4f0584a6a5588d2b0f10f781f1a180b9be9da33c327f0f482348c62678fc32fa643457a6705c355572145a38e624be1dcf48f2a8dd84668d041da164c54e13e57c3eaf45da242422b89075ce9741f985591863c7e80478c9fe31b8e00561c147dc8410b55edf12e11313139a3661393e6e3b2d828bf3df8f22f5fc21bd5339bd3bdde7033cd732eecf981613060136e59bfbcf93eec6899b4eff0d8ac6957753f72182002d6465be5213e740c3d62ddc5a460c8a1d1f7418d3011a9f4536e75bb493a731da3d0b70e71ced19e143a112bd63819c7f97801665296186108a530f5a4305bba7f71ef92cdbc7a5b2523915b2af955f777901e867d1c514ec870497c5e5c6596bb7860b81ec156786e2408b13bc03304ce59ea0ba948faa845ba195fe7baf0ae5efb848c91a32dbd3fa8c8e072ba9dd22f2e2aec74ab10407a54255e3a752700b7374f2113429371eec22e94ec7fea984c4574f01e9311cf78518efdc9ddc5ab93bb6d271f08944ea6e7c1922a1d22155938db8d482420b9f72735b58171e4341b1c9b166560fb62fa7716dec372d8715b86b4bdf7b7438857dcbb8505bdebb3257e847e7ae4c5be1dc37177e1e977d7cfc57b212204337c62a051e9c7d8cbb4eca4c4b87cb76d4b222b0acecf9fdf5ec59bf1ed103ccbbec4e95d81323943240cb321753c325427908784fd6325c5aaa5f59e522e85b86d6e9e297c220072b5a01f7bbec393f24af614ceecda816d4d26cb6d52bf1cb0600f2bd290b9ddc20231d8296a48701ec4affb03e3c47655f5dc1849732b030591f5f9949cd037a98b1b2c372636a3d81d564152d94ccd643e96f281466904e33476d984e8a0097292cadab7293943fe6ddeba0ed48d6d690d768b2684d223ae58140454e0ae7dc2afd89dc787436df6c7bebca2ac22763652e3de4fd512017131a1396bad6e6cfc3db6cfb1f03a85387ab54a3f50af48374c32059b90e8a5c82d4c9200c5b67b4802f89b10e5c4e1b7fbfd457c2f4aaac0b7f652e9155ee002eeaf4d5c575dbf41f2604b37dfb59d4ef38e0a4ca23bd4e306d8019e9803e6f679bfae90eb1658c2d2fb7f275903c820b0b35a272d6315039793b4f8db1e49739401a68dccd274cb5725d3493db3ab8ee6bdcfdc2cbf689f49c58c7cd116a8a1fd6f3a84d4ae6b6608fae48c00373b425850fb3b89235852aa7469c92df7fcd38d7ed8d08a54a55e883e2ae34c8b25cb7b8b6cfa08429311aec148a60ade24b53286759986f95829679d3286a13f742842343c5371493fb5f92794e85829f69eafd982e0a6fb97f27d09a3b68c52edb8f027a34e25248ec83fc7815938311686bc0730fd88b674b8478e54a3ddd0a37274cf5cf242921c5c2b985fb2c70cefa6564c645707816506721ffbc5bd3f44e79748d4c6be7be53339a6935de67f49dcbf7fe9ee654e82c5a8473cad2fb482dee0bc07cdb7f78eda5b206ba3f66429d08dc9098fda98dc24e292ac48ce0188817b21c7af41e0d3b9d9a4919824f6100ed67088e4ce6004ba39c22494780bc8f94d629b72487fa4420a698121c1a3c6213d15c1f4c4ecd43647cc67f6a6408ecf4e75460ccefa4ca9b2c824ce40b9e0536ece1b4127b8be39a980e173f6e0d25e4cb383f57471b4a9b310dc81222c874241bb70941a5b22555aa00d6b43f255012b0174ffeb62d422fe1a484328981b0ac47e4cdf76f262e8d8753cb65cdc9bd3280cb8dcc51d32122eb7f131e72dbf9fd9b88b08b70c78e27914490dfb9687e7db521f3e80ded84c00e132c8f29a6a3c9cadfeca2079cd7ff07a5f92ecdf2bfa022253f219b232136c1c0d0c2e5d9365e9fc0781a7da5c483dcb06ff9db2938c25af8d8af6fe8c4ba4dfc5297601f745eec0c83336664f8308caadfc9346dace410ccb075f061ca88ad1ac1a25743c7bc053613ab37d6d8d74aea96b3faefe6be1be4138458be49d1e8435eb97085de9845ef9c5d8833c97dfccaf2c77fab19940594f3e5ea630230dbdb093528e3f06104d858e5930f7a91c91200083f904390265c58fc9c3b3142cebe9d733d2ae43a4b72da5c86a808b31f67bc32ddc21913ee8564978988bda519987529f8c7ffb3e4fcbf1700bc9500feebee759439e0660b6b6ce125d3f01507fcb4b45f4fa3a557e374e95ab1e9a796736e4a9f418f0919a1b28a5e1522765a0c680fae34c95480f5008323e46e8f19ed2ac10260a6d06ba7321028e58744c76895481c504f3613b7a1a40adff84626477139e8d3bcbe239480396c3ed46c6d7b69886e2133290ee9e3d6a2587e18bc896e9fde7464caa4956a67286f8a7225fafbd9c33390f4fd0d6a7f3c0feb9a82e6d29ae6730c3d39708ef8766fb0f65eccd9ce0078ba74e84e50293ee6773c5dccbc22114a76caa7e8848a3f2bb57b84ac13098eb1fc5e6c2f00f09312fb8bdad2c615d2180387ed0aef9cbaeb2666af17d2389caaf4a2d05612bd8abcba451a00b90b131cfa51e2c11bb261122968cc23d36ddde6dedc60308ec2830df82b6f7d64b87ea5ecb680f1dc1b82a8da96e0930146391fd4c0353556884968e2de7eb21c5b23f91b4946e26859c53bc15341b9d3747dedaffbf899bb5e93c632a1da5ff1d87a97f7392aab6568cf7a88c32dea180db112500f652c5244c1897f770b7ebf095e1c70892d30de63d56e2ac135a79e33239055c0dfb15b2e60df56d7ccce6856ba0e90792eb85a20ffd22707c6d36dabbb178c9357fe90791681dc80d6d6136c8d7bb532f7033c6b595cc52b1b4fd304aa0ede32105f177ffb393dc1818b29d6cbef40d3c397a230b88f7ccab907327715f74081d78c6ad959a6c55bc19d67290712260e8de6ec9f2936b35159664c581b0720de7387ea8dca2f1ca73223f7de40674951ad901d79208febf1760b67e5e2f395277e3b83e6ed74dca582f3b2cb6849690db656920605f38157a9043e2f6f771285e95789a5ec5cfd8ba302cc5a414ec4b6edfcd51a025568163c80b6c8ce749f23d73f02fffc711eac55e647fd8c1d23a0c4630b5d9f5d2909f881719c44d84797ee50817c48d098c5744b127cdbb1fffb513b1f7151d7641ff9d5809e9879ff4549ee2ae5e856baeb5ea78f14a71f040c25a0810f1eb1cce7e435244a25d21179328999e121bc3110491ed772951558f140943c9041c3542a823416199092e16bdcd665aa54149b997467066d316c45ba77ea6ec96c6d98ad80cbd886993a609b989d560dbe21e6a3cd2fe5ec045127fa6335c8ae48bbd768143cd45878a2dd786d306265bedc45f4cf07c6a7de2c889b692b5b6b09c66e3de099a35ef99789b01f2d08e84a3650593cbeeb5331d7b189b1d225e7462ea0a5217be20add9e717a0962fdcf181cc77dadad4f3640f52af3f7c4f074e4335bb360e3c80dc2c369aaec9b2cd1f90d467031b8d0a3cacae09f929b4421a65372baacb5707f2cbd3466ae9f14f32548c9680e8d7fb5574825b0d91b33908ca3063981dcb2583ca2a0efab329bf18d0df938419c52214dbee4145ff2711fedbd9a7a08bc16ea1902e9c5e54a5c4253c56f236820940a31539148af3a946563745f95487d7ce92d9163d7ed87c106704fe43379407c4ea0f4dd63d8cbe9db414ac16befdd9e4a9f94932c8e243c77b1f87f4de7ca0af10d195bb722f87cf0cfd6a1fb374023270cb1e1d1a93e60fed9e030743eed0fb244e5b2876f4ca1b013c9e187275d8b8587e83f44145086dc2c37e4f8484b2b09bfbb6ce7c66cfad5e46f0c8b1b9270e4f1e685081e80350690e45f05406021dedfa11fa16e00602761724659cf58dc2f1f04692bab90854eb672b995b95da75fb2c7626046780d26f56fc06c7092a562a1a861dab1dd3d4365bcc71d1e53e608f0adbe944961a0e880087c02b945f503cbdd59b475d3d726bfc57bc0b2941518923052419131e9608cd1773c26d99e7a5746eb8f539692d7ed2a31eed24b5aeaac809981882848985e935113c54b016765ee8b08392a4f06ef6d874ef749a2940284910d59d7ffa1764d1251848b7b175670ef9c9b93a4b66a043db31631a67a597a8a5b4a36ad6559d48df06cca20433eba56151658741672d11967b7f2a219c5e6bab8602cbc4a0cc5c94a20d06208522166c71ad4281dc5bcecc71cd7d201cb72e80b64f88f01a7307f7b7ca06398e8ad64b84f1c746ba702ca7246e3101644a74c6b2d5c97f722a4a4ffc62e549fdd09e7125e0acaaac6041d776d118696059f11865a6775eef525c388d1f71823c81991f8151828101563a727914cb44e8b8cb068860cf6ee7a9cb72e4d8c715ac5f8fabfcbe7c5d2a70f93e92e5375dfd06f48754da7c4dd271ec88baf2f75366dbca14a6ccda086b954912f413159113e5a3efbb7872e81b9bae91f4789e9dc39473bdb4041bbf1693cdd5397e341a5dc10feb2616d468e9a3ae1e2a5404aa75bc2f9db8cb76d0be39782fdd10d05028ac068c9322a7faa6c13093938efad4692255f1b14e438561d8f97825a4c2d39413533d27f213636fa1fb7dfd76faabc8ffcbc4b506da808d5ebbf7ac30607b2a72063559c3129db99079da86c084371f53f08c185616d88af6e615a308bb5947350455e7d841fc1801da057791f299bc6e755b0db6ebe9ed3b15fb6bfd45cda389524d53bd4aa3c92cba1d6455da830f09279376be15eb4f4ea44a15b617b6ae719b2e871d634ed8b034a297b8113e99458bf5db5ac7e8774c0e9cc9f5a38c181ff25997a5d2efcfc378cbc11a9766a02fb9dc5d12bf79e7f362aaee20e7f2eb6d39cd9641bd91c1029eeaab0f2321988280e4ae6fde9504c7600f107262cba464b73828c81f662720f400f152a5d247ab740d87b867f9f0bf09c43021c78896f2a039973828b795fd2e8525456fd1ae730702a330f9f8da6cb36d8afb178a0d17e7636b37ab2b4cbaec4ab566c79d041bb8d74c8bd4f070a9712b12dcbc2604992f632485a733225bee5debbc1c83659cd21177a2beea6a46a8d401953e978cca32d1f428781b75f04b3983967fa4c771bbc01d47bb27e9dc12c344cb485933f2ed3f37741218390f67be9ade3ae9f2169a6177fa4f00c0a78d928a7a7f6843f6b5ff6758326d20306c7d0c7fcf8a38326ab9cbb478558e156def749a966961092b8c2f507905c157104f9dbf2e8e7b10e4245202edb45f1fa88f391705b1888f316a9cdc65d0c13272c757deb6be6b4b6308b85677f48aeb1b97cc371477f0da80adf96595633717b6f4c9e57a60cfe836ed35e3c30bc5597f9bae241895e92e3bca853b103cadd4d36dabe9508aab8757a8139be00a71e050ff8f29a7a78abeb6e5a7017689faaf170fb6f6c276358f67f34c25c15c41ee067f9f9c58149acbf0300735067942e73926f042e9bde2dd24c8c4d693f58f8755580ff66dd6dbac951b91f906a8da3b5025e64d621b2539317794ba04d34f75bab5bf7d822fffb9bfcf789eff8098747af5ffcba9f5abdfa07aaffad74eb862dfbcb9adf93c0deabca3c8ead794c2ba33b90c89e640647726d25754ae425d1eee476369f1e45fb32326c6d922c0edcd0c694ba30b51a78c8d6c7e7cffbd02a7de0a1156e9acbd22d6ed2b56317cceb3f750a7b7fab4cea7d3240c140b6e2c3a253cedb4cd18aa9d2d399436414184437002fc84f43ac868d7964906c787f092a436bd9302a1b46c4f7a988314b58413f5ec9d33c8955e42114fcc016671d66caca468fa769e87d63c9dae614a14b355100987e19a2400365e5b62f07c10c28dbcad54c1b7748949769b3f107a413494ba5688168a5f22c7f745d9b9d66a916bfe025243308ab29d816bfe96c7f8bfb6af438735890d3e798f97c9b1219bc9f8178227270eccca8fab752ce01248ec52318e46d89e9214c7b6861dc082359955ac37afc0ec933042e0e685a19a505e8fb52a5f2c15d32cd2b31e742ba893ade384679982645a4e3e81460fba88236ea31de17de1cd0fe6eb80a8f2236582d3316ce609ead3102e8e4410e45642ba7253a5f3c6f99e6170fdaefcc60d1cd40730e2c98b06421c153c2b4f2a9900d0e4557b28fb9a5516b066e33bac09b28786573741b0f5914b1e5c52d38932a2d60fc8160cc497dd967c0bdc6a095710ccfdecc0f9888bdd9425a7559a7db3d8146f1f80a1271904956e375e0e57962f1a9159f8fd885bd9f4becdb26008b7dbf0a8ba264d685514d18ac3d3fb82a359080e084045bce182d6f846aee51410dc2fcabd568fdb1ffbbac94a55a64f5c06c782648fc3ebfda0bd6bafafc02ebe2c29e0c7981e8bcae55ecd5587065d65be01dc1ad002874ea3c58944ae3f42769c92c19ec5808232fa17d6d17e457c14fa7c5c2470e48efccbf59ee3df7c463a4af590978582b365931de444717b748419a319d969a9d4c1c8a2a2868035a25d9f7490463fb9cf8ff092904cbac45a124d05eff40bee15ce491d4b4141a75f4e1f6dc59b3c835660b824956fb75d0d8c0270ec046938bfb86043137cec6aea979a9260f8bb6b54566c0e0fb39589fc94aa0005ece22bbbcc2accc8b45d31c720645385b89c7b39cf3b93a68f70b32a971fc0d1fc3ca19fae6a36e0cc683981e0c61e58bb968b0ace7d20fe6576a3ac6d73dc39073f7e782b2267719cf950751c74c790651e56e90b6d4c0e60c1645eb59862120e6a851805350c647e89f666ac77b195cef11e4205ad0d11aa8dea9cff977b16eb5f82245b81fb7e798ebbae5cb9098770aeca70110aa306e0690f3d23ba098180458da800a8073a8b2c08040bfa9758638bb415fb31b84020b9405a57c28ab531c7c463427ae6854273a49065dbafff089604fa79dace8838ac83c4fbda339ef05ddb4b4f6fdb234803e0f4a7816c64860124d6bee3f876fe2411af399fecd07e66c0607e125af3449b240bbdae95c6384e28ce2f8a57691904155da277ed705c3bde96ae476583a038842ba34c0e109ed90b5d06d16c654dd022a5f03c5b344e34aa06cb05c67d950efc35c872fb116c875689821be3c8bec89c893ed75f517d5eac7d2df428f9186e5aaebc546f5956ca9f95d943cf446e9cf569b30cdedd3ea8105998a9a5a5023399750c749d43c60078dd2e6053e74a0da1721a7b0fe8f772fc600a78eb2ddf2391378e1a428457bbbeafee932ebf2e1e03258bd0707375556fd0f3bc6d0d1e38ceb788bfc11ff0d71fbc18bab7c62e19ad64b484b1dfafd0e04469abe33f2d2734f29b325a3b8d89f5116dc6df95b8eb14cf09c3b87dd7dc769892bd981424ebf23b65bcf51f88c63efcb0b81fc10743a60e002b2e0e232548c55e2c61bc3b3a2421479f4a3be706b016b523bb20c47468c8c2b632c18dac585dac611800ac256604b368949131ef2faaa9730cbd742b54f32e1402480c0f48d267242833c076d837c09c9bdcaad491a2dd71a8887d5e61d5b8428ecebad07801f162defc279eb0f6c9524a01f6da3258020c6b742f95b53a3e6472b82725fa1d4232e52363c7aa1054535d19e33a70348f606dfb6867d5b757840dccdad567c69b4831b6e42b45fe6c791f964e9b0cc6ae59ae0c66f397d76530d4170e4c249c23182010018546103439778bfd37d0d36dcde38ecf07f70c721db03eaa238ed28fadf1076bc783c8d1373c7e44fd912323aee1f6f760930b9b4775f74690d755f483329387e68081ffc382899525772a20874188c7c6cdf6c1817955d7e1ac10c5210c911e118ef2224eb13389bf0eefd086e9e1970dca56d8044fe0d84ce37a04adbfc04fb4cc362cea22d2d968e3fd9539de9d18c44b7a998715961c09d3ffa52abb13902fb80d8583af16467dbe0dceda2dd0d587d161ad57ae9a4b7ce6ab81b29f30b55afed210939bfff9ac19dcad48a23f9b06d5701aeb655cca879887d4b51f99a7069e25eccce1e5751b17fb340e390b80b306736f52cd8502c689a28d3ef72e79e8ba94684cf1727ff92d777924a3488b0399aeb9c51b0f9a86fa3efd4721c7a7d31b606680ea6aedaf65de791223623883c3cd0017366a28ca4047ad37783c011604f59e15171bb5da060effa4d4edb8fbffc9d43ea4c1c71dc431b23297a4a19b521e952f76300e68bba947b55b42fba12e0faa1c568303095472d869579cd8d6cb1d6d72c9b68853f3a9a7442798edd80398c951ad0a3fd3cbd6ef115f2d91d33e2806d000d69258a5e03e3b86149695f9c89ce6307de63fef8cc790bdfc97ca8ca497bbee10ada40d9c96ee6cddeda7a40651e7d5e6dde6f97a07281b4bc1db38a8f5f144391363c983ce6e4cd8d959671002a35dd799b8b04ebadb8beb4e1a4fb065c289b8ea9bf02a2cfaf8a9d8501e0df628c104778ef687b81b4010a84e0cbccb5aafb037a5e3b73f3ffa5334cbb2e8f93e5fa880ecc73d79df2b2899c8640684741a499dff1e2d597e61564a2be29e09b2ef37569faec0fe3fa991683ba914a3311cd9fbb13d7d976723d082f34f84fb840064b93c2ad8d11703331ec9c225ccc974f09c5099dbc63f4c3609bdf90948f00b2eb6a9cf9def578e973ca0b21228c925ec450f6f4f4b8da398d45e5370ef9e26a1552ecc1f7bec7f64f897ba083c4123e7fb589222d114c4c0187b25cf5466b6117d2681f48e4b2548a968fedd819afa5826a5344e9d57f875fa21a5d2881a321080a432896320b4a2a32dde3605365b2321e9fba46374149ef8d27bfc2c51fbc37bf0e070ca18880ce1f36b792aa0d783853f535e02f964d436b359927fa44ba971ee3cc521039251ea8f7091f92ce1f70e585610fbcabba5c218217c500d9829f75728f2d5fe3201361e5d5d97b8018cf3f2c30d55f5e04be35e884939c3b6c6d91d5c77cdf3ecadaecf07cb194752104cd6441d5a8841a7e1c302c656240af768a4f8d5aa5ee210576d39cff4c266c749999dc36352a135dfb8e7aa57b1f771a4ca97f856dfae189b49f480388bde03ad4194117522edf6f32439479831ce6119f762d15959c65226fc467b4de100f6ae25ca3cc746589d9b059d9e4a230d328e25d62faad2f6f064e4dcd5155370318a7772f4891aea2f91a4d2f7ed218e5c5d9947ba4d2f5f893b0fea2fa473d5c4a1cb7872b7d304d919c073db255bd62ebf417d2b4bbb719e39eba8c18c5efce54b34de5182181af58ae81f9122aae0b6ca5f423f961f31bedc88f32af6794767a75014166ff654a2a586e539f78db83fd0bea99f3a8a4c5f1ed569df804b197730f1df909f931931523c897344f7937d73e9dbed22c950f406fd15b6a1c3e0f7b1bb0774ed3a1f0e3412c7e09a098f499b6209eb4939fa4547e52b0f9f67f547173d8feb9f33b23d07bd9800cf912aff54bb75efa07306408751e746dee24f954ea052c266dea75f27b893a643da43785370f29692d90caadb54d52985ce76a48269882719f923b95f3ab4f4a6682c5acd2023376824ed17869208aed16668ed5dceee7ab63832cff29bcaa44364b2ede008556788cffbcd1c91b1f9b075da64a51795895b3d5975c0c78bd67a0304808a318ee307fec1662d4d5459e2b50e3974e56484d89dcfce4d4fcf64891aa027faea7470b7e89303817a3cf3be35be5a9a869b64748d3d0084f46852a43fcb4c1f59af5853be2a666f46553a9a86a73d972d1f85686451b4ba694863e6bfad562ea54cec9fb65cb942495ebcd64b69116c2c5f05f297b85aa4a765f84905577b00837282284114ee9d1b02ace0d5a687966f96379e9e16ceddce8ec4d3f80d9fa9aa025eb7a883a10b6ca292115d46db715ad42c4432a736dd75059b24ca0f72b23cb145d6dd24eb0e6b62bb6a702fd51f7ca3a50552c03e428b030a5059f87c82e9c2510f63df6bb049c9015a209c80a576fb9f0530b42e198eb249a08599d6bb330ca4613b00643eb6099760b76077db9c72124ecad1b5ba3142f5c7524bb455172129bf15c9598ee8ed6b0b3d8f4a1b0cb35f70b5155d519038be3e3db4d064bb75d0aa22b3143f23114348e723672010f9d347ac3f490f9d8f7df0a99f2c631554cf88d81cb5a844bf2aa659e78e0d64ef872949ed7c618d5e2143f2c7abf8a2f4c2f669bf00db68391c85068a3af7105279f2970b78c375cfd4904ae6a6f9c3b510451a7c2f48602a5149055edeacc8eed9a62d9b032f63fc6a6830a2c8fa0c0e1275951d20633ce60d7f803d0be25945a1b6be734bdaeb37d881843fa41414e64d1a3775008eb3cccabdb7baeb03dce5f047ea269557737deba1545644097326eeab905fcf2547f89cc93080829f9e8fe565deb262c58d45f4a91d0bcbc282a1b3895d13c6e83cf2c9bbb6421066b637de69df4f329d9cd5fac4d32cbca7cbb2d48df406b6ecf981381ffacb8d71802f8025f0982cb4365a32a218d4a5910bbfd0cc6296d76376866abc88d43c2d5415d6c83f6fa8109307e4cf6087212f7e4643282172fb0123f328c16276160c5514331252b4c4cc63d5852f86e76da0515bf07f152db904dbca57f9e4acc4d8ddbcee4bf6081aedd9d41b4321639bf68a88d5e5bc48a2889f23cee7a8826172535bdbba5cfecc9ba38a458b88cdb8c06c3de7c9a2e84ffc419f114276b83fc7bb644d139277f9e7bd85001e190f0c9d7b75c1e3ee03b68dbcdaf8647b7ed2359a2488cf09345ea73327744ab7c5f7e85d7d2b6b46f3141df70d6fb05c3c3de063b6fb105582b12bf8b483fd7e84f982b293e2e10efa6d43cf622dc66d60703a20fb88eabd25aa4bfad66189630d462de32c8e82bf3fe0c2ba1b663633b863e51fdb5e4c959b6fd2bead757eb01b8424e3929855775f8067f0b8c6d9e72f326950586643d3fe98ef79830cad4b877e46d05ba3e86fffff42584f959169ad6295acbc97113a8893259906e00c8477c28e9d0d6551773d298c55ec715c8a49a9f047c07cce1d1ae2bedff31c84aaafbffe499b2d8ba9fbd071a0271755e56a057c4eefb3a1ef4a5603084dbeddbe70f458bb0be0f13e7761b207d6f7f7c8376731208def73ef71052526a0ec5c272ef5f448d5db24a4d502d5352ce1a052a1d7b4a22d812be7877c56b3e1bc491f09653214c363fc07749aeec8ca96c897b2023cd47b103754ad7f3882d7c789adafcdf55c3e74f8ad110e97c372729a13577e2d06c3b24bdb1e35a072cdf1b462bcd48c2e0d820c2c97416101b5358bd354620a7c6658dade4e6ecc4c60d5395165f8bb88ff6763c9a9f0367f6f526d9d894512d6878fa1ac5c5d8793de2bb8b1334472ccd4228dec81c303fabf4e7070dc71833844eff9cd7d0b538a40adb6807ddd7b72934035a1ad46d9d5ed575e811c78713b1527ae73fe205131d08a5bd32d76374a1488fa29cab87d3017270eb1e86615b6f2d3ba896c21ac1ad321948bd77764bb2a745cbf55357d9a5f1c4317f2a7421f8be98568e1bded2e22e60a5c9cbdcb4f2fff6773eede25f9ccafca3fb9ecb2af32c8820b41797eca4aa262ff11d8a031f6ebd4a8e49bed7a71268e23dc2c5d2cc2a7dd12edbc69b81918899153ad3a17f1c7e0174703c15c35a8e473e79663cb13746dd2a0c74c5390515bfa7a0a3f6469a5a4da81d1d5b7deac5c74dc00f5e394e703cacf5b067f00fdfe3510791b472bfcde9223792fcd2c9a16ab14ea30a9aa0acfc4569973f336ab131e4a8f73d720fff741d11c399ac18691bb006c22870cc494f66d00f6e44dcd20dd7ede1f119d89aa2795f98978ca47446d1b656b511e4a517b76d68503d7f4a68e23b80b3078a3c6817bed510b14771d7c7c6c53bce48ba3e1ad4ef8b56608498d8f5448f49bc17235c3daa6cdb6d1e638fff4feddae35d27a1840e6a6802d4f75b7afdee62df8e44192ec529aca6b44f5b17a41935f2784b90f1e335eb211d505871b14a0ee58be607b5ce8dc207ccc06ec7c4eba8ae7ad4ac43998d282af31712132daf1237769479a746f48cf8057d42df2913af5244aab1383518ca9ea0a623234d93ed9d746eeb1e9c89a948d78614ab4fbc2634847f65817134c7c7403362522b50b05d4f65e1ec318fd1edd92eecaf605b990926d7b724a4e515c128c1993c4681811f637ac1e982b8569ce1602796dc841c766517a32ac0c12c6d5923585a0b754400fbdf12b24f735b6624583113d6e6965c6bf9083f7968a347c079bf9edf34ff45c0a58753f682b995161ddae98d4cb6ed346d93160943f81b02a900b03acfc21658dd3581dc7c5c85957a0fad8e0d57db972aefa562ad3abde74252af258ffc01f92b70a28b97802a22f111b9f09657125d49900a1226b4513bed7b957cb40df4a858dbd5d4021130fcc0d147aaca5fa02d3ee5b57de51e2e7eb5e8fa2ceefac71d1020bc0c35b4c036fc81ce2f6dba87c666aa78a482abf48bb62f4bf61acbc2271a2de036336b43d67dbde8c73e813a5368bb4f95b8aab68d16bcc6aa839a5068b200c5f25e071c22ea778ec80332b73ebe50be1242e0a223d37d2b1dff7b9846d1e137dcacbacb4decc6dc4f30312177a8b1fd927bbcaa3606fc6fc580f4d68747e458f047a2c6b64f01afac0283719ae212a1932f1b0d47101b099673a356facf50cfe626dff4cd8f02be638c2019daf0dd791e619cc9d61b5bc0cdd11348aa22026831d999d287272b5fddfbbb6c7f73a2b13680f78ecc23b781da734d102dd699d71536f4e59deb845a1d6dcbeb266857326d705df6f1a68b851a704cd2b878e8f095119e8ae1962fb03d3756d8030b8ad3f37bacf2d9840381cfc30c947292ffa9c1b32141c38affd621fd76f5c33cd0bfdcca9556ebd0e6d7769c3357e7ef67d71d02d941c6f4be4e2bef278969c0e871a0c66f29e41e5a205345a01ff9e895a804d1fd9d4da3c111ffd976b1ddc06f58bc56160d3644dc3871599992997fd209ba37c498c09dd83369306d92024b261c4899448d22e53af8e069db189e05375aad96b884af1f568f9befacc5b258bfbedead8efd0b84e9b0c5869b4a34b22312c1f16d900861da36aa4a2412932d96400bce364f443bf6995eee47ebc4dd6751428204e00b2b66aecc3da86f717684dbcceff50370439cd13c3fea0e8c4f68c41d444d73318ef9d37c23ade150ae4acc055ec0084c44a60c82bfffe4ed2348e2c85bc4b1af0045bc8353f9de77da13ca535d63f01240b7ae46a26f0ef5ee8048cad2ddef9b4cfb62c0b0a04b123347c2ec50e5dddbdc91127f3d86c0da40be4023d107d443885d51bbe62426fbc0c69be27403687cadb606ccd234b2523a34f15c953dac9d6f006952874450d3ee3aabe3d399fa72c54cf00f4e04af21c9cac186989b6575f6541c545c710f55c8a9d91b53db4723fc93e0c79cd2bb6a40a217f6dbf6ccfd53797a18dae6ddf02195912f43288c2a7c7e56a571ec2d743e8dc882df73597a7751e44b8e6e5dbbec3f5a45e932aff6d99d6cab891d874dc37a338897f1599ddd7ff8689fde0b7fbb33beff819537ebb68bd4b717339b5c62bfd0caf24deb2ce68353f7e1a6aa5df58e2eec9b9239baec2fd76972a5a5af6d5d199864babaf202382f808cc4b5efd24a7b77f9c5bd0b23cbdbb2f916ce0e1a5ae6986e9016a1bdd5dc7b4f979006d49523aa8962ddf82c4c9e854d190d00c8abbbce4e35996eea7cadd2d4785f94601669223673f5d9343b28d3047122f62f1840638b8e8f1668d8f29a1bc7f4786795325a671709e2190187408e2e90a2a6feeb764536fa5ef2fb33171c9acda592f82f227c2c2b334d1df3920cfd5911e7e1d030ed7eeb2c5a3d08d04a5c0ebc8237bced151fe8df020cf7ec0270d97f1f7f6a6628965927a24fa50fe6a5cc1293e8b15c911e181467d9f3c0e602f958a35811a46437cd5311580e492a00f1b91e5af1d614cc8bf51936dca887ef8ed4d326598f6881bc8a51f92515fc30a868dca683fc50839e38d1721e020afd0ca0f204d9a8785048bbb2e502e6e4cf9a0042251092edd55639b4837361d991483b9da3a79dac8f314b722e8d55c249122cacdd6ff7f713acef2f6c0f3a69c7a46a982ff0054463f997fff2f45e382e78ad8ebf93610bcfd710da6791ed84106a29dc6d03c82730d1ae8fe3437ac76b0e71f54ea8189ea4e92523ca06cb45cebeaa0a5a39a0a5bfed2d8c9e5952b59181e71bcab34337b17a67b2160b8b29a22d99975f940a3672bed44e1685ac7b3cf9a27f43c97a98c2f42ccf0efc832f44194c756de3d1c9327aaf2dc203fe1299fe11a83304397c8bf06a34b67ff11e6e9dc8fafd702b25d4f226c59a810408736cd41bcb4c6a1fd11f53f2e7f129aa1e44577b0b032a6393bcbe9b2ae0ddce72488b899383d53b3a5054aecdd393b276291f43f971f21dfe40c2ad0823e99f4b1227a2d3bf77df84e1ccebc77706388cc842ba6334d2ff50006bcea573ac90d95d296fca39fb4fb2a0d3a50880710c84958917ecb2c78bebfa98d51dea6625a1647c3720bbf64eb1fc418f7b409ead538fb3fa1d14cc0e7a1f211df391a767b371ff02f1bb1038a8c6ee54fb5b898fe5fdc1c4127c8c4a4962c675e8b95ed2f6760cd7611bfca20a12f795292042a0c70b81d095d7b3a8787e3055c607f7b0d7caa8b55dd1d6ba8ba6cd765dd4d4aba62b0264955c1925fa75705a84f40324b75ce4672eaabcd6863c41db737ccd73d27c376807395c11153d13f0c704ed491b44f5753001924dcd774549d11432f4d5a6f9906c2defc586b28aeb81d7be85878a429afc794137dcc925d60e955ecec2e5290e5d91eae17db6f2e224e188093a5e13990085bf6b478ebc742537c54370122df6dbd2152b372401310c818ae82687016ab717a4de179ea22a1d0d289e9b8c91f4a31ce23aabb69d77f73419d73d04c0e845a83afd8c4d412b4691d3a5be067fface0de3020591aac2073f0da4175aee49db39b5ded6da3b407102996eed158b0be163002c95cd7a115f3de13523971bb1c5b2d7ff1fb503b163913ff222f6356e91fcc82ec03ce9adb077534c74ed522972c40f71f195775c7101dcbfc8e9e35b327117636c7876fa424a312d592995892d5097701417f022b8daa29e5f1880abc8aabc3bb2b80799d4259507d1bcb200ecfa55686a114e3be0f2478ab2c9a65df7b0dd5a16667119ad2a31ae293343e98f5c9a4280cc2936ff804df67ddc6dd3b25d4b4dc3c7004319e5701f62a877f1f9b7817c0106b15d49baace3a024617e270133883e67bb2bf87288f7536f298df43eebeae7a08f8ac86f76276dbeb14e98b5a09a87efe5216910e867cd18918649d4d39b0b6fb5625e233151e7ab568835bbee916ea0e1b602f7f6fa628aeef4eccfd8154c3702df2913b4393d85c67c373f436a488a82b88b0d721fd33fcc867550a99048b3e88b8f42cf68dfa99c311463ace4a4d2b1bf9300d760e174cd44fdb042c405af8815b7eb02f8d99c3919e770abdabb09c0a756b94ee49a25563126b936577ed5b6961e244fc2de65222ce674067bd0e2cffd27850bdb1ec467fee25bf8929222bea90f3dc691bb514288c4846f4e62889cfb772cf4f6c576f5038d32c4da9df064bc620518fbd4ee6b9a0cd2a917c658a0af3d9b4eb2a712a2e565f6af581d108d95dc7ed09e43f050203c3ddd8da715b8222bdbf76a6edaf82125d135bef529f1fa826a8e7f3cecf27d16e810e87c8860eebb66c7d90d43f8111e0d776ed3147c5e9a3bfac042c9f665bb26eb4549f01574a042439786f670b6ad71c61b93b2b5521492f02013ad7cd156d4a9a5b6b0444d6fde655aa22ca3d5a797778e630c8ab54b85c73a4ca3c6df5fa6d4631023c69c176211460e0b69f224ff4c8409ff4d0b897ef024105332c247963803282c9ea14a1dd1e58dfae2fe2bdff3ec3f5ce8b27c6d9e5c6f203c6410c209653bf0963397ae845ddd296411cc04fed4350e666e1e380ba2f48506d29ec6298c0663690488f563022533e876f21ec8ace7746526d43841f33ae03f38b982bde6b5f18af2463349a6f8c90ef0c3a659119429db3ad6e27b37a652ee618d5734d31f743626880f87e280342d3943556bdc8a9fc90f1817e6873ed65a7b44892ac67311d6b71ecb87df237677864ab807ce769c41b683d96d43f95f4ff0d4405d983d96288b4936ea59cfee2b1043e6f13a1bad0c1274a33a990086e3d9b39059544eadf5226ba8abceaf25f25303cbb2f7406a57d2d182f5648cf3ede5172b630f9983a353e469a8a67d28d2ee69f4d0f9e8f6d62135f56b2ca35a6ac9e0e51642e04ad85e4d141336d7b38dcb12e0549fa6b6e7b6424e41ebfa231bd45eb64bcaaffc60a8c1c389b9b58e37477b72f28bb4b53cfd365eceb5b51e3ed0e68a936b44f38ff3a5d06a839d29b3ad92996e68dd8cd113cec5f43136005cd024039ceea12cd96a634146180d3d557e80193b20c8e2013cf726b13a338f9bd97cd0ab3dc7f71566f5e22fc207786e86f66b7477b4a7e1689006eaf866068c68cc13bb0bcead86e4b294423b8a25730f06374a9b036a2f2237d55e7d6133513b12bc51a57af6c55ed594fb1b46915b7379aa707a79c70d98d49afda4dba144c11f6d6e4905240a93295a189758f8a4df7b3d9a4d47de27bf5111ae46e3df19b85e1f88c81435b8a7ecbc0ec868fbcade9c05a9c5372425e96e8bf0f80aeab7ddfb18306c7162201783e9588de985918d7662015ec4323fc984c35cf1ebede5d3d25d7b8bb2a859b99a114c990d832fbb0b75c38ac28f3c8644b5ddc573ef3315e7dd2b752cf12bd46c00ce300e2ad3e6245162015d2583875c2bda2b21035ad7d3f4080f74d4bedd41408a331bbf9b2eb5ae64c3a430bd94bdc3a67c22e790c9051b4fdb910fae90a62bc50bb50c1f253158c2a6a5502a5b3844830bebf984a8f2254b6aa7c1229af380750e9580515deef0a72cd789340e84edde00b4eeec19e3e79a9c166670857439be8afbcea403b29a66bc3bb3f2b33de0a5dd91194a6f8698bdec2fff45c3c6054c7a22dd8e1723243b065b1b381a59d377088aa4730d59b17e96fc3b76fdd2bca9001b78fe6250faac7be133d3459a7ef0b9b8d92845dd1f423903465fc696f506a530e1900f7a5f59fa682a519d26b3dd6c4f2787691871e7bec532552c3f3e371e4ad0f964a743820a9db58618bbeb686453e0d3c7c506f4907d70fb4388260cd1c5130138ae1de1600cc993c846124ae76ef3389c3e325ece0c38056d19464387d57eb040fc604bb6e7668f8ba2c045d7390cc09b32c82d6353342ee0c083883be41e40877f617e3aa3fb1b0a279abda06696c0b648fdd5c19fcc24a643b1367cab7bf0826a95917d44b90f89fe76190dc49fec7f99d9ed87ebca0072e662e6271d0f1bc5a09f7d9ae08619656cfdcf013b3390237a57ff0e4232ede307bcff2e48ebd4a3c6ab1ee36eccfe63106496f3c2686e79dcbc9ed524f4a6a64a88ba0da6c085a6d4d169590e616e6650ee14f3df0b062ce53ccc76d1e4c6a0bca4771b8dec08ea1d596ef5aabacf5e677a43bbd03dbee5bf457064e79eae4a302d534fd965b49e446466a1d018ab1befd8a45a7079cc31d2a0125ba78d83af6a22a0895dbf0a5e957cf357a982ef545ab03d6c58072fa362720aa7ad4c0bb0766e11601a89e3573bc91361e1bcde5b6af4b89b452bcc21f30be10f0486f5fad543fbb49ee46e247637f7aeb793181350b2b1b3da490248af5d0a8a7a0ecf87d0237e5c68b82a02d35057113ab4145afb08f87d99372874068f5be0a54bb90261e34e2261bde667ce28efad6179ebe804835d0a0f9a60516bce38a8ccf6869d746962abbf0f01c45734c06bc0560b4d395262394afa1f5fb16e562df20691a4f5a179b22314b307feedc3034ad0e3846c8f0adc4be6fc5b2df42224d8d2ee9a0b4f333249ad95cd68fc21dbb7d7c30066d4723e276f588f52bb33c5a0d1d437b8cb6ac41fad537f7edba3a48fa7f04e81b624e2958d101dc6694a0b8d1888c207ed1e7aad914e58a0a63fbcdb3c8aa758b5f2415c5ba721eefd0137104d4cae4bd07b9a04fbb754ff6c90a6ebaf17facd65221220a9275897ea939e1b73f1f165ac166e9ac0fbf0acbb2e73fad01a24b129b3547e2128ef1d500dbc75c90139954807a224763fc27f2df169684bd468604726a1b72a70e4af278d1d4158cd5d9fc792571a3c6a6e4ae028410b046137dc31521773fbb257bd9dc804050d8c4c22a5599dd992bf0ee58ffe15eb404f5815088849e6249fce99587aa4fd3dd656362d43964a9bb36855bfc4068b9c6fd0482afa0093c729b9b87528d501ad55fa55bc4ad21972cc50900d89b195f1a355c1fd628184ce840eff3f08f0e06702fb91294aa73bb6113b1d29999fc11c76c685e832eb4bce7a4cd1e941746ad0956e1a8cd9496a6bddb3952eebda5f7291007506a68cc5d9439502d3fd773e78a7f8b05dbe479ecdf9173ce3674353c05125b884f652f28409d99129d079bd7c8c74b2305268d8782208606e5718c20491456eb3b8ae7f886bbd4b613d902f26165b8c20f925fe83b9e8c568ba3b21c007f83e8c31c0b5b7a360b4f082815a0a99443d3537db3ef134119125a6076e021515ce8782f0b422ab16aea4336de380b1cb82ff748cee8ed9253c8bba2bb8fc87b3d27f313208f47f14efffb8084edae52a203218f4cbd22a09eebf4357484e4c53ed7260b0384ab28898e41400b5b0904932e101288e5091024b16db00168c5fd12e278d1f463f977ac499fb0f8052eb2dcaf3e38f7b565d96d371e6735c29d45670095214d7ef9fd1cacc2a4dd1f2579732ea3d2b4a9995c5f9ebd046045923759fb72ed4f7d492aa19b9e854a7ea00f905f9f2398221cab12ceefe1d79c6f692741641e15dd07ba40c00bebdd8d97c2158112b3b6942bdd40d7c977b6b83ac4e8c8466866a3eb497b2087e0590e04e2cea8cac631c2e44fdbb57af3d87438a70e92117fdc9ba90a184597eb24a87b627ec28a1d0e96e2ce06ce82181aabef5cd6368a4842e090ba86aa291b38259ea7b75f28e80178a1846b7eee2d90fbf93c26a64412f729f56a3b1012b27ac25393e3670db68c61cebef384a0c31f5d6076f8827e63f58983017b3fe136c585717a4f6464d4494e8d662691eea201e7daf9b62aa059c678f01feb5c57f7bad07cd7b066317c1aa8b065bbd7fd93dbae941bb6e998bc0f2aa750a903c77073ec6dbee623da6683c5ee5379634077a9ecbe32726153b307b0aaba7d238ee796785e87a2f304f02afb1e11d97f5e9bc52a7953def22e28923408536cc7b76bcb38f7c8260d2c0f9e471cdf622cc05ce068e737e9ecc5843b65330d8bb80f93347ddc02dd6d7135347108d26ffe8cab223eb355696d4353ee120c100e5f3bb887ebbfde37413b690c77718209d85d34bd5f8a9df2ed17e5e523f994f9802d10594dda802ee071074422c51f982e60c024d2dfdc3e71a5da865e796c70a065a0d5f054e3b71f4e259398bfec49ec7e883e4e9f307abb897e9b3984908c4cceaab3da459ca9ca237e23f7461a17e58e87db8059126810e2736e1ff1bc7bd2fe67df36222602394e0e53da8c111b272f7391cf1f30c45a08a19f2f6c622d8937055d146611eb838dc738e2f6d197569a2f07459ef06420b85e063e92993f0af24146e24471ffcc41ca2f7eb33e85498c0ba5b3bb5184fcb57fa08bb7a1a494e60261f84b89f11bb5b8043b05d51f0e28225401a6247a56388c48e4c0892822d828d16928d3ee6bf0fff5b6cedaed3d4c2dffdda9670d822b0071ccc49055b80bd025cc2475e07f6d30cdd60fce37c6090fe74138bc24783da78dcb69ae5f45f76aaa250685766200c754b9bb1755a436bedf827be53d03d0a6a1f4e16a67c34f2fecde40fa741b57c650c7babcde07e5f6b6eff5996aea53fa9ced6bf54927edd120cb776d0f1212357da4839f3c651411671ea69f8b6cb298201715da468a3fd774700f1a9d79a87f0a82834bb92eb84443c9e5af8ecd7a4145411ec2d0fa27b50f3fa6d2742d71946f1d2957df3fea253d270c162425a7a97d0294f4c64182e98426c57bc60a55cabde9d50d14c9788b5cbf5d44041e6aeb4aaca2df8d51cefedf9627966f7e1f82a022dfff1223ea66800c67d8124093baf701976927415b33bd557b3a7bd9338042585d1f1bf197f7fc5dffa6496b3d76cc731783e8c0dabb83c2f9150bda2a97e0e024843701954ed119bc5fda1d9d2fceaa16c857db103db13df09bf91d552cdc581308f92666e0f93d028776b182e4dc358b40b5f70ed51653d954a66f4296e123e201e0996dd944f96f8f31f633b0287e68bdd86e378079af16ece9b9b7d2d2c05224fc1b26c277816741917c6b85002028579259c1c52e89d9eb073ccecf36a59417c20e121fcfce6ad7fc68afc51d57db686215cf154fd8a8b110bc5785c73c95f9b342bb43330ebbf80916a8f6c7491da7ca70da8b5692e089901e51c16458dc3e34856c85d06fbf9997e9737e45f50b0452938d7b1795fe961bdcda67fd9214906022ce5dcfca48a59dde21898eef7598a904d6e9138173ab30a6f801991272c73286e016e9146d2dbf18c206747f02bc21c261ec653a5ab423ebf718270c40c2e10ae209699604aa6f90df77ae920daffdc2241f8c0a0ce1ad2d2cc5794404e1449ecce884dea3ff471700167fcfcc385fbf5bddbbb982c9e22529705dd8c746d445fc238c44ea8849b0a7d23a5dad68bcc5be322640216943501ad731612cfbeb1b3e0283c4f57d5cb84a3589184296d78fb4b4cc2da9762cfc4810bf936d53c8b9ceaabc3b79ad12a37aaa4fad2c199e6b303ac47d6b9060e29988ad23ad8f6b2003f46770abf3dc0be206036d72b2f70612b972215dfe67395f1a62e5e6012c2b41f8dc465f7349a1750922b276d96157f4c99b75bf330979d30b21aa6450ca37c8892afb9d2b16948c96ad7beba7b0ec000687f9a083cb9bd05f04409caba37bb07b94e4232f1894ff0266172a12d829ccf8983aafc6a5942dd3741d0b729d191eee151eeb449df3814727571e798cb052e762ff15af516e160d4f8e977e6992149ae4468fb87856f0683a3f8fe6a72703e8ea3cfb319671c33d049f7b772c1f1607cade2f8ec7b566e3dcddfd6dca1c845e1386f4546d2b3c23a5052235196bc244396bcc2c6bb3056936ed1c416a196472a8c575704d3a169fca0449a49bf6eb6b6bacea2aca711694bb9d1e5c37884f007d4b0a9c736729e886e20786eceecd05aee3fc497454ce42c85baec255d5277c93d5326934585183de18727881fbf400f4e6603809376854ddb202f9902e0ab0ef49c2955afbc61e3a250e42333eda10c418e0b35784711be8646cb35f6cc9f800e9da4fd1308921441c4139eef14e78bf5b1afb1bc71e5ebf5f58ae955081aedbe8cd49f44efa6cee5227c4a5890a2a5c68ca7f421fbb1099c624f4694d94cafdcadf78885a7e8d9b5ef21d7bf845121d1782b6700a1e0f9f6fcbdd37d34a872fd67cd1a508800484f676ec0569453e6348b065fdfe9d7cc370b187d484314c0303e3b61e027656fadfe03235838924dd50c23237f06e559360eb972f851231a393503d22cc8bdcc8d05a0cdda55d6f265df81de90c275e6f12f2abc64e52c7f0de3a8dc1b53625bc5b2ead23887170d13cad55852d6fa8172ff3d47b5323c51f91f71b49dfc02de27309b4e6c831ed4a92ffe88a0a891cbd43f456a53b34c89c84a770639b4824540c5462c769ab8da73833d8f06209eab5a0e9a28e9aba1cfa9a14c60a3df178e7152f8d59261d194e3022d1b08073745a3ab310394e48792d777cfee7fd946dbb11c22e05cdfaf735c81db95b79ce197960932cf8ad5693fce958c03c07cff16ad5af7ab9f91d943c0410602d70dd72d62105b33863c31f247425ca5159e1739503972061913931ec1e492c20489f2f41279f477e6def8d37af7ace1776e5b4ee3405ce083f3d3d2b7e442def4b1b58007e1e21d648c0fdd61399b2c75e8ce644c0cfff9431efa8658bda3ae96627b2dc4815d0c8ad79263171d3177466d533a9ac83d5f2acc737c6adc141fc0c791fcb29f6d789aef2935b41f27fd7ea8f12c19c021dece97772416339fa874caa78d87402a25524882ed2f52e1f6c12a317658d0c324705246700a17504be68f08821ea6e812616a5a1fff2c5eca46f10c4c4d8070571133d2150f3f1c83d1abd35311933b915dd898f12940ef4d940a683a8f05c1d2c91bc459649811c2ec691af0025b8944c6bed5279f80d87a938d7282729e0070fea9ce4e3140dfa3c0550353878238a4e3f1098342c715bf73692a2e5d8c6d24fdaf863fe197e92d87ab63cdd34813e3412e9f5fc3db6a02b0b6e3da57007e40406b96f3163db1fdc053018b24a89cbf139b3901eb980b7727450e97dc1c2226846b54325a0fc4bc3d47bd9e3fb4fa4e52b57400810d25e44e2eacb30ee2b6f0ff38eb36c3e017266b9d375bd90380f341eada32cc91490a22d59104c5671986646baee85831f4331c71b8fa9a467d6daf75d2ed4bdc1916791bfe0112a9467235a4cdab26c0173b4b29d818f7838c39b295cf844102ed9d4a0d08966f76824090d616b49a79b84d6386aaa0eb15a83045c1177153ff24cc58456856d6013e4fb795f8870b989f7e2dff1af15abcc8273d3cd0f67c8184bd958a88072d478231e8c546df7b340d1222bb3edad969497ca25617c1b40fb2a8c129042cb2dd3beba63ffad273c500cf196c6d2a4432d8964749f1eb3588bab491cd7982dd66a474b942cd1bc3c05995c7ac00ecdfd58e1b8f842fed427caeb9034bb9c09795afd55c3b77f1ad283b5678133bc16ede7ecc1af3f8a7635bef5705e29d8bad002283aac3de2f610c42d503e2a220d9dbf26d9841d9d1a8cae6819578614ff29e5fde4ac2bc9f9e1447170e80df93e572d0851be81a36e4a0897cfb0f4ec4b264a08bb9911e9bb2a21f6e8de767303d68a7952953dbac81e55b900768fdac2b2896e71151dfefde815714e6f5c87a6cc7f1b3fff0b667866d554f96837487000de89e1e99a19d3d052eaf1952ba2ba09ea7882bcd844c451e0cbe1af6190f23fd820dd196c6cd2c94c09231572494da4cfc615dce082d22a988cd27b39113e8c9e2a454ac2622c0c3a559298f3cd8795a22c9565c97123eb046fe91cf47af3f0d570b623b1cda68587bb2fcdbe6e0bf71cca253668285d2489179d8dc0d4be24042b795281982bf9d5d69cd87f3b7c3e682060dba6fca79888bd8469e75908e36e6e13c792eb62f033e213f570d8f31c64ff40fdaf0a628dad2650faf5f2f468f08351e214d7cc4de3c155d15b880a76e3cdeb03d6cf1066e2fbecae391f65cf130268c24e707c5c51118685fd9c5a31173dca9c4738773600a16e3e03c70e6dfdedb35d5ef71cd41320e2c32c6e3fc19df6b7e7854136c58bbf5087a890613734fde7cf0c09bf6068f1fe23664a035133d4ba395d5cb97508ad9b5aa2fdff65c3b4f3c0bce1aa932d865cf2885b4276a31b7371b8cafaeed20ca49df1c1e346a186bf3aabf315e246ff5dd07ec08e166c8f62b577c4e62d332e57e99b4b60a5df18d2ac256c8b01c8569d5ab305d6e2b7632d070181d306ca213786662b21be482406b25d53b4588655fbd3782fc836c949ce4c511a1f884fb8acea8c2ead4574f1acde2a1c1655c326a04885cac8f9f9f8ed96545be494b8e065d2e453a140daee1b08a764e77931cc47a489048a0a30b6a50cf5c99808436841a91ab60378e9ae03eef15ca07271d0bf620a7822d4ee18f6cfc912cf95ecb558ba0201857d2b78baa71dd861742d22be497308da7d7afaba3e23d47243069a321a20b944ed4c40e79f968676c4fa6de733862ef81d7d46cb630f10a194c027818f6cc7153f7de85f23e88beb69fd0393934c6c12913b86b3c2453267c5d0b729ae8e1440dc36e62fb5b619cd86c6e46835893a436b3ae2f9d28b4e507b58b342674bc693f5b01bf97e25892a4da05107cacc04ddf3d6461716bd54e567354779cad5a6fc470369f1b98b24b8bc063fd989f4df6c5995dec0d50dde6324bf59e1e2506855c79acd1d488655d10712b65f671b7c59dcc12e08bebd2fca6d0149209b412e183848053a7d0ad8bcd31b2491cb5b0a4bff63c8feb3e8b36ebd6e06b115bf52d267f4c611b34b9233a1f66eb4dcd513ec5e13b86a6531df6108897851612e15b023f649e25ce6b0a00a9fe72ad0f2075a19dca2aa4695f276832ddaaab7e8ff2be9ec2522e23b87a7f737ce06996ff90ae8b60a2d363c3a46f56b68706373b63ca3b954e42d107a67a5974e40b973fa8d61a69695796206e1ee0b6e1619575edece8b942496344a7a0fa664430059e62a0863e33183484264955b489897acfe5629e956327418a60a79d1c924fb1a1b5d86340095165ed9db12c14c15ae0b5d6122bbf6c63c55e2f7d860ed1c4299c010aa72682c4efe0705253faa46fa6307067644207786ea1fb5c8a5e3cb4af6835b9a5fff1e325f66a71162e77e20795a5e97122ac4d66893b05a78c034a43a403df4b91e29d1e96d77d08d933ccec5fcf53127caeb4f4e15a27d82185e2e7a836413f909c353cfdc3ca6d84310adbf5e4008562260131247d1af8f17c0f239d9494ca4cc378b87badf9ff5ea395d1827e2c83e07cffa1a17d1d32948b806a362d1a8d149d432bf8363f392d774e833449787edca14f9208b8e8d1b815e548fe6d2aafee6b977e5aa0337c308f34782d464057a9a3a90d0d5223d32bce3f27b80b538584eb2a6eef7e97fbc7771237a1c0355c7441c10fce9841e40e7fa2dbdcdb8a13d9691ec7d51107a41ca4329d9fcdfb754b05bc393005fef7dd5e026fb1a276d6590b38484b8a0edd9fcae05e109175e3dd30a2ef53b6078692dec87ffefa219e2f00d1f2abeac84e26ae0f0bfe163782eeb0e7da50ba0c35b41ec13918c6c502b205e61c679a7dc19fbaeda839b5b272e10827ec3ba6519200c3f98d2ceac7c93014eeb8fece3252e2f3cdbf65d210ff795a87b3db97672cd174f1fbe8cc5d445fa45759215bbc56f0381d5dd4a9a9627260b6108c5fedeb94023f9d9664f71c7095835ff1c4f0b2fd25ff44a9b86695bd106df9e7cfd246a2377bbd6af4d94fc9feed654fade3bdab2b3535e5042ec4c3fca47fc98bd5574aaed5db8270e25b9bef313d319e501300c13767ebb316cd29a520bfa68fca9009d41cf425d500eb4d96f9b14fc779d47186c4387e13c5ae5e5670ad6d43f4aa1cb47b8460577bb58798e63a3416d3a7a8e99d3a46afe6c086c0860bd1f581e961b62fb3aee04b1095aead5e8bcb22888136ce804f27590213d983b9d8daff1c2b07764c6c2d0ace8619ed2ab7c87c186c903cde163118cba8eb5850b307f91dfc9dd6bfd324ceb177595ecb3dd7f1570571faafb4f1b22db6972a4768e6b51e73bb57822df95ac1c4b225f2a2db4867d496a74d979c0a002848251074d553b67676fe306246ee58bb4f9e7dbab250fa15a4a64c3d378c4ad4c7c31758c99e5a9f1c0c0b225bc2e6f71f3db39b860a298deb29f45acb490471f7b0d5cef28d54472f878e860e7dcee1414ad132642ac2e8d178045592e8b4bedd76f5b0eddc9876c790a9a01cffcddef7c5bf3266be5d391cb227d69689876734441d2db998d04814267e9481d23f4e77f86d67cf0a4b4968cc9bbbe99e7a909db059b49c4973e7be680368f7dce23a7f27776cd97595dfaf1e4952cab3d1bde1529afe839679375974bd696d3cd3891ef965009a0a0c959462c5485478f73024b05d442a6453ed45dd007c8cb98ebfc6578bac3fb5a80ba659b31cfdbf35a8c9c93153d48fac273412000769e09c67a735d8f2d2a87bd8ca0cdb52710300e34ef00aab3fc938fed276b2cd0a873a199778a46aa5eab05b839dea355e451f96094e979051cfbc35bb5fa247916ca152aad5f615e51a92dc56c6609fd2c81aabbeb7c5669b73f854209fef0e371fdd34be5acc3096d23cf0c995bfc89552f36d9008f00d2f912b2cf645fb6867591e659547dbb5219c0436ed1e92d5e4208c2f4a911a06aeaec7b358424fe4c124faf829fe2186f9a2ffaceadb726fc51114784265ced9d96b3480602e1b67685ea947df94b8e922144a7fd5446ba99eac57d07b643f4186f0786158733083708e6e40c085292671ea1636740c59ca54111e5fc86232df5b73be62dbddc042e1bf4ed1cb99c26752f16d85331cc85f41d4ced270bf3eaaab0bf70749a9ae7e81e226ba3ab434f36aa94e62f7356b6668c221013463cf5c151f45a2fcf9296238b53be2f612f8d421bdb0c733d2c324b0d3f22108d08e933c2b848f290941e84a32c0f912e42baf1ac1fb1b3973bc70f04432802e343c8c31727259b8e37aa14aadd513df0d9436fb9cc224a9a132eeaeff0b8853428658691cbed7871cc55fe86f37ac093cbd7cd0fae8a5f63528de0b93fe7a5a0c89673d5f0c92c83d4450fa87aad8a8796e6e01c733f5b17d28b29ac950f1fd7c8bb0093fa884e8e3729ab743559a34ca9adf656cbe5d05b1de2f3427dc089f60986ed1ccab066914bf0b642cd25f9bfd427b764f0f75268afc8194d07618d55e771d4998643cbea0bf08b6f61e8e0b0c3ae8688ffb58646d524f693478bc02031120b96b05e408ae843ab6050b5ec95823333c558c0ff850f88f76a5104fdb08d14440c354ca34599f976398f18de77f367453273240e9ab7d4702488da1c0dd552e3cf96fd95bb4d9ac57fb0244968f93c0e6459f3464362dda666574a9083622c66fa86d7cbe82d44c17b07994a0b3b3ca11b046e19d4115ce1459a50554a70555d3683510a08f94b01fe264d33206376acfe343401edd4e91f031f69e4c0ce2c5ddc7e86f06cd599b5d8279589322cea43b5b729c6fa444c3778c74eb9a93df99895af662b17a95c2db7273dd478859c24126b5ca6d640afd917027b8554cc0ae31a7ffe1a4120fea764e039ae69f3a4c24f9b56a20bbdd70557eb05f7e064958fcdb12bf03570b64473b52b9040ee946d51ab0d346ed10213ec36107a1ace8c285184c1d646a6f0d08c2174917ccb5b510eab790723ac3aeb0eaeb505d1d8c0a8f1924e1ac793ef59c40ed1b754fb69ba4db5c9ab2e2b462f66c2501384ddc0c9e039ce4995d5f9737dea5d5ce29aa6d2d16fe0d21491c679a3405c658f054f72a5c84af8ef180f5691648a03efc888dc861cef14b6a253454859912a026d83bdfb114735b1720863e574ec9b4b356416a53d438e7d4e2a1fea7bb8c5cf79a48b0e2091b4838fcfa017840a351f6839e3c899f45ea6915901f26d2b7fe6b890156e5d9faae184ba0f23de0605e89f2f17b7160cb6f96d1022334b421f9d33aaf8d8ac1595b753a3b92c6d193f56e55c92910a5027ca10eab7c7502c6c932c3f9432c0ed1f66839e3b36b4060b726e704fa970360e02b66ec200d456cb32e55f79ed4ccc84e5e048774cc69276da005517faba5dd493e1a093930cd8338adf15f192bfdfdb48c600d19bab631c3db1ad88404e543e67f8f275c64b26c2f503968524910b330910f1d45cf798df0f434a48a98d9b3f91dbd4e7a42bbe460adb93b4ac7e0e079f5a8ead8f867764a6bae5b4518913411e0ed5a2dd6ceb9e494beae04c6caaf35a0a8f3b00483076c5d7b73ac53523237caef2065834a8d814e35d16707976dc89d9448fa6f4e9e50afa8fc0b2f57700b603c6e8e64cfc4302d00c63b46f0e442a2d1290f48197eeb5f42910aa7c3a16ca2306ea9b94ca89a96ebc58f1fc382e9933ea819996afb0ea3fc675e6f6e4288102b4dd036f814d9ed5d9aae6c868d5721d6861be55663f585ee6e03d650bba2d49a3ccda3652ca10f70f8057fcea390809c72dfd1d92f50f48b2d7907b2890de147fb357e8cc6dbae0bb23abdc032ec38e3b37550b8a4b7a7b58f803d9c21f26736bf8959702b24a4dbb5c20c659993fb54193a8b0693acfa5fd553cf1c2e2abc6857f4ca7f82ad03e0a56f68095f470b3efa59686195fe4b88d4af5c817fc70e409fc64a24fcbc124e18f83a33036ef7198ea565225fa2ab560c189fb746b7a83002b7d44bc3ec9d4f430f73ac1752a3101ec5f8d78278344fad95cbfbe99f53e0235924481e69aebdd1c3613cca4b6d808c3ccc7dfce287eba54d317989b9e535ea6367dd95d528f3d4fd3351e785a972b353f6ca49c10d0038bbe3bc3cec803e46428f44ee76a76a55b9a3bf969f15aca00090e72cb7c84b82ed7a6875d1efaf15e2d5cc7d64cd62b7fa1444a7829e2e913bdc115627a37bcef7721b92a1cd883a60ef3f308f2f5462ec5c40ed3a20cb65e95c86083c3e2e414e57e2236c2c3a5df7b81d539086bc4d67d90e54958be5ec8f70a5b3844c2614ce1da77110651d544a526fa33695f4e966da109a323fca75a8d78c879d982c63e64ccfa603234a10b2d467cc0bc6857a81ab5f4e0d4ddf2b4c9d652c86a4faa9ad75ffecee07320ecb9b1b34eb12bd303c2ad99e42fb0eaaf2f467d2bcf568325ce4ec99f385229a601b5dbe7cf9e4fdadb2aaa30c899b8929bf81bcc25cf3dc7830222989d9810f43412454532c25853af7a6aca84d68a5eb09093c0ab90dd5a1d3a808518d1728ec1e24d4994b888ab0c2e8bf150aa6949e5129e069b63c11583b4c8daeaf72da9fe6427469e677c5fe44e9df3c27cff870b42a67be359261711a2a92d905d24bdc3efe08b7fdd19fe248bc87531005b075b6dcca41555d3d0d2127a810321eb97b73960a246979ff46ba677e5780191f77a9baa3ce9422c114cc4e7a70676b9d19acadade6264414f8a6bc3360ff147c0e28b9da8c867098edf3cd1c1c39dbe097f894acc6b7b8588062eba23017e13cf6eb3388819814c337b3ee09801e17f6815ed26b77e0aa23825917465c69f162a81c0023ec2ddfefd6382bb0c8202fcb93ab8c288366ba04e96caf645a3ef5d10482054d81faf371f3608702390fe71822e585435e387df1e4e4f03034baa055fc20956730c154a13ea1ef994200bc52c20e8aebb9217229433c092ae38171824d37d6caa43f3e35b852495196cf40cded095942974c75dc4ecec34fca4a027f685cae8df13b13f96887e4d5678d207c9f36ef4f2fcf63df99af2638fefc2436c0458b3d20c0ed381fde418272b88bc48340ddca379113cea7902f6791263bd3fc2ea2abe06a58f837ef77452913749d551578a622e941323e59144a2a3f1cf3713f735d31023ca69fc89b407bcad0e62f815ca246f032d71c66ad034f573693c792338cad9be30e23e74f4b5ca4926bc772b71784c5727aa1161a63f1e7447cbcccbc0a4df8b3731b3619b4182cf35b292b143a7cac02f78ff58d15336d41ee6991b6696a2531afadab168666e7290e77217720bfcfdd64da4139f88bc5170cd85215e1eeb6a9b1fc5256d370c15d1b80855cf0cae31458a426e9d104f76a82234b85cf0498a590de4878c5dcd0bfa2f657bfb084097058347804c5fbb8bca43623d5d7e2a7ba99463b216674e63f4f197454d52d7b1d5ff1657b9bae6bd6bc17e219d64e3f60bdc21c6b165c448a1396021255f5e85871e37b3a043d29eef908c85bfec6290c7c9de8a9e371cc5240baba3b1502d2c4b4203549837ffe9127c7bee5b28a9c4db6c648230b62f9b218bd269b2305061247c2850f4894486c3967859e413ea0c31246c513367aebd483b9f4099e596cce3d5c8cc97da378cd3bc5013625bb03e4bdba59b5c4d71344803c15e9cb2240a91d598af29460df91edd0754250c0620c7ac9770803908650acce4aa998998e6ddca816be5bf68868ea453c8e96a01bf30868afb88309f4f2ed8144b3fb99268cd543a3ddc20087f8c2dc85f8c021ba4606b342a99dcc002edf3e2e3cab49f22f3a06e639d242a2290673c8a11b581fe6d238a8bdc077d02e4d4f3d40677b3a0559b9b05dc962391d2ce84f3a9f0d25d340e0c871c148a936f20dfb110b929ff82d2c367ba3a2f91af9ca40dc98d6b0254767539438b81a2e5a63ff2b9261b64cfdbc52643d8862d0929c5088328563c50774d11ea87a4b83f887d06add2e40514e712fee8a77d8dbe73bcd92214ac80f9ab779a8049a53dec04b58184fccf20ecf213a12d591ef572d6d45fdce6753a73acc12a332b232d8731d4afc940d68147d2f24a49ce33a7e7ae6e7fe366fde330c8c334162dba53913fc8f58620ed2436b6f51f7a70c4a5c18d82f61a19e538786c47fd707de509e4d0cc25c64e40c548d49fa1fd2acd3e1690309f6d62b76b925170618f55e3fb21fe83745e98d670e1333e12b665ee70e455a082aa54cfbba1f6afab26eb0b6637ced9f48fbd5af7e55eef15af48e830f9d0a404d5ff2bf95bcc6bb9ca77d1c81acdf11562d3abb86b1813e25e820feee8a8dc8c927b5b13ed15ce5d07c85d9beb4bdcb8028bcf6b2a58aef7a6fcadbcd498cc8a9754a4d170c243716e3f636a811041737e4d942ed98b32d39dd0cdf0f188c9ed87206b3a9a36e39a9a1a402210709ddaa1f3373a9d144671e3d43304b4674e40b2ff24d1093e5fbf08eea4669b8fb872a4e6c821f7475f99451fda95f311ec88a4f74923998334290b3c2b9b8d9c6f1cc7465b210198607f5215cb9eeadce7e6b7483e58088e0bd04e54e25bcf64dd7a3ce6c218f313eab326f2d1cd3b32ee994f638476f957f78c5629df8a5298dc3874c22efd4249fc455bc55fef955ec2443500d53494358e58df6e502246e42304097b5d4d1e85ecf09ba12635d5faec4c6af23e19daf662c7829e97a860e145fff4cdd98f4b0a9741374862f34bb9265f8d260f7f1393754434fc5af7992963301f97d32a74fda2b950019c6a7740c6da70e88513bf448f12a1002a2928433aed8c668beab9c532d9ba799cdad5f355285dc9da5f96688a7c416d510c20a55b9918fab7d6dce3e347d6156bc945cc02bdef48498659b139dfc01ac23168859f0fc68c15e82cb6f35e31f8a8c704264ebeb11ff3553f2ffcfbe85b5822b1e5b950ced63fff110a716d65243cadd099b5db5a1afd8b7dddb37f6b4a65aee66b428692822eb9e771e85ab79d17d0f1a4efc9be57f5aef48b73e0ad98c87c9491ab1b7c90393055f1e687cc083a8a5f94d48c9fb06219713ee733064e95701fafddeee41486f31ca5c94c145837baee06135592be645bb096bf6fa1934136df4c70c0801b78634a65029fe842e829d69314de7aa1c705612e603114892c1a76961cacb5bcdd4aad24e21fc6509a13ca0e8b56a0dc38c74c9527cef327f8a35ab0676ead4d4bab9e8b1bfb4a702c5dec731250cde3b9df1e67f848272158b3f2602e174cd7d43b743f62f739360b0b94e92c1d3bd5e74b5ec079497e66c86728034ccadaa89cb6fe2ac28343207572fb2d4c666e4d70c046542254ce23647cbb6e9dc92308071a1b92293a4ae7118220e9ac9d0a31ce84da94ebf3b4adef4daa75254dd0aa28e5e5776f040bb296676dd31583bc5a60d6e0bc7c9f6e585caa3adffea26f7621a93fe2def00a6ef4b7592687db234c6b6e31a64a4af6267944cc889037daefb61202fffdc7f2f1686b4f01168bdf6603c51bff805e813e6d6c87e4b263677e55dbe689a156a8f0df67fc15cf2c87015d7ed222bb41e3566670523d730c8cd7b73af7d90059f57e9453ac847a3fc6cd8a33f8e62c5c2214e2438a1edeaef1456105e2143786766b3cc32f106b7bfc1e6af8cdaddb6222aae6ea9d8178bb004aef2c4399508d686a3791a7916471784ca5119e1c0c7d9e97960cab429d5d3354f48ad525f9c8043703a91dc7bd491d10617978c5670c3a81e2a5dfff273d9c0945458937571a32fc8517304387baf6f00974200a7e9a8c8adb8db8bc8d847f99ba6739dc7b7223bc90eaadd8502e8b0c74f96203af9201be6ee16d97546a8c9fbefede00de5bae25b75726bef164a4e0f8200de0030065eafd1aca9bb1fc440a830d502f0a8953ee72943376ed054b7ba52354adccecfbdff52cc9cc373477921f35de09d3996d71095a252449cae3a8cb36107e1522d97f7932a309114e90be39c8776ee14d52411ee382b098140333ae16b29e6763ce7bd5f81c04bc5b676ca08bed0d9c1f57808aff56592b1a542a277d3a2a6115bb3c1aba2f4e7cbc284b0f51b866ef6aa1bb9b049183f7776ac4f9ca2117c2032b7ee943078f412f0a0552bacd5f426d78c2f9fda62068431287f242f03707bb64bbbc36a0103496130822497e16aa78227dc91f2c7cb6741d4932221d8d9847dc3a8f4703e21384a64ad4c7cc44bac83227d1974885324d182db1a40f505b27ce71b7d96600d35bcc9a90c49909b522a34425ea38bb435a06f3284f12d3c6433653a72b4a625e26ef01d0cbe3242bab815764f50a74df05a49293676a28fbdabcd7399a5569823500dc37134acc83da04a1106cbf70ac5bfdf195d015c34a79195736a6bc6509a8bf26ce2558295c76b544278db3db14b4455bb869f3fd73bd1027abd70276abdb69f1b50d19ec52d48034dc3b399738c19bba06586ced034d0291f4c60ea2ee6d32617fe4a475d4183f84080e1ccc23845aeaa5e0ee5ffb7ae0a751958d18807b48a42b26c5f4de6d5aea24a493959817ffe83c6734b78416944cbb5c8a32fba6b78ab423844b116f242e27065f008c2fdb3b76025fe7205d842c53a267ba5971dec010f76120962a66427f2ae301fb5ac9fe7ff4a75b0b67ec34598f4192ef12eec9afffd8992605e2473ad6fa10adb2e7dd2005b6745ed32941b15a541bcf10529ac2f509b6ea7af47f2bdb27409864443179995b675c2b521f8f8ca38b0e37996359053c6a66c3e20678f3083beab4cf3dcc3416459a9b9ee74b4cc1e85ce43633a513f5e9edec91a0f60658245fe02631a4d504a9daa3588cde698204123e1f5af4d45d43ed48491609b3bf95beba8333c7812201943d06aa4ca54264cc56ae5f2c355f4e2933cd725643cf08111e269c99d0997130690e4f484e60f6afcdac7740e6a57c17f593d14b9c78e83030c4f03aa8fadc1a54de775b8b003fe52ee9726c00b1b8fe588573450e2cd5084f2a1bc008244fa2623ee87d5d252a44c689ff7f83fe57a87b05d048a523ac4d1707e96b09f16641d4bc5fad12debcd2f6c076916fe085b1342ec18450196ee7ee52da4210acb113550127bf9c0f0fbe03fceae8c8bde600644a9e5f8759d34e50dcca2267ec1f80097ac2ae4c02da7c7b99f560fabe5fc64118faaa1bb22969632304e5fb0b3fd5c78d1dd61ced4442d6f670377ee4e37e160e94ad759dcd47d459b5acad98729113293665d13b086f520d56515f05b07a8ba43716fa4feaabaabd6da87bd456899f01781d904efd70e2bff6271cdcbe3f5e3d32b33e45752e81d48f7c7ad8f2c5b62f3fbf807714d0b582f09c132f97c4045cf9f7028bb91d71f9782c6a01e0e40db8514761789e818d96946b8f13723622d137635c56f3a9766fb66be13ef8b1f93c730964958d7155765533942d944692bc1314ae256dadf27ed19f4fa57d719cebb74c853fe1b276fe5660bace1eef873609de09d9a06fcdab30ce33882520679c4cd82fddcaa38d0aea97723d5828068a01133e1b30dfb160319b6545322702634c05cf3ce3f95de0d4fb8482668e55efccc71f0035011274957bed5a97c6da59da10ade117ecc6e40e43818d9ed12d28cbb7cb4767e26d07559d818a1df81e20339a818b896e7ffbbfbbe3c1d586f662b34f4e0f518de1e0ee93b321dbe5a547fdde02c4fa7d74ef2230d3e8f67e07c2e0ea48fa3fe0680becf556ff5d01ee3649d41a6539e76bf34f4aab6a8ef2f61d124fe7bd32406f382a2a130d07687804f9622bd98e158e29266c4f395b72dd4206f7e187b32ccb0d57fda77ee5bccb2a1e8b5acf505af2dcae3760dc071b76c4c832c03ee7d8bcd3b60ee8610bca4469960d5da4d468a5f4a8db79980f8a30b135ec5e0af0bb130d4942029edc6424f2b587f89b4cc96e9113200f7ede88c53c1c70f5be2f9dbd1e38960f40c4b2c2926d6480c77b939ae8055c2a0d89d5b8c70ea420511ed214f1c6ae051130a627ef3ae5949ae3c88d04059bab5352d7f5ea8c44b1245a2cb1bc8dcd07f32add07d1d42530c586b554367800bdcd0592aa908339a7152a0f4c85cc3cdbaf5c403f4c296861dc689ab26c876a09a6496ac9e1f8da285bcdc5a9ae572bd7f7ef2bbdc06042bd08561181f16b9551e97905d14931e82dba1d55b3b340a4b2d44280fc6f4c108922a133e7350188e10d643ca1aa1d10b1806a4111afba51770b3ef5fcf47e81482bca938918a7cc54b569d4485746bab2d21c90c46e17dd4cf2c3be8e7c1d842f894974c1715cef7772d930148a3a1c3df6b1c6bdcacdb38ab358f2d495228c619a51d2745f3547f40b9ef6e8f6a507c8f71a527a6754d979ced0c3bf6b814f4830c0e2f48e74ec5189bd8cc50df9a860a39e11faa97f37ab68439cf342be8730db9e9102c3bfb10741b5d04e1fb34cf4fde9c4d3e27f77d259e4fd7cbd197fd25cc8625da2ce34a4f5b7f043dfe30ed4d066ff681c4f9f05fa2463d716705472bab78593d423751597d89f39e4d69bdba98ba80183fcfc786cda0ca73dbdbf1174943beba82d3c360425d58f54b0b61e813ece3a5b8fc738b05fe81505f65d3929e9b740350f1865843686effe400e1bb23a46e0997573087d22b6da46f7c2000dfedf8754b2e252e6057905b6409d946c357fb80d63183212937be11c65c22834b469eebb1f17148fcf6676c9536a7768da21d9ec0cf64e91d38cd1dd3db9e6fc9c66e6a665670edf6f49b91a67bca5a3a5100917d2c40b550a53e1d0195ad88fd47b149e09626fd6542bafd3c06a3ed7a4dde7b445494700b708fca8ae10ee63c2c17bdda37703f82b7b8509a5a0df538d86aeeac16d10e788294dffbba1328cf0057a9cb45611580c72cd5b3a1115bf61999b085de4c1ae9aa4b44a0f9473221927629781edbde7749b55bcda9bfbaec01bf0f87d0c7c5e8dfd5c7031926dc7d5114ef91477caf603be1bb2cf5d4e3c79a56b3aa58e3ba75126840928ad8aa7937b9550e0a7adf0139ec09e1945813a382250f3e25f2aa057217ed977d42ff723a28d327d877bcd427e971ab09429dfeaa1434f742d34ca044510e13a27ad6984710c919115de685f111c58326e2e722f9f8658cb21220de2f9ebb3749bbc2d6a2cefcae6f705a0ee42b09c2c4d7ed2fb496c438bd12de14023c45f226dd46baec5d959144fe7a5decc9a350c8b315833fd69435b75595b11689c3f06f9e385060b603372e0e662e139ff77392e927d9e7773cdacfe493146334bdcd851ba6660d1a7f687bb63b0a93de273e265ae1ee831570773a7261fe4054e77b3fede853b523dd47239e6383beef5db8f51e35841e2bbe71f67b1038054a9f22fc701553f9e9c6c4279189afc3522fc986053ea03020f47f0336319b43f1cce85ebf61e6cb0c2d1c304b6742366d26ca3b29b9e3374919fea8ad3fdc0fd988b551ad8a8eca5c7116b724163b13bdd6ee0d6ddc47123329b4c750868376cda5f68695d7d140b8fd148c0a6b35407a30bdb67b9abebed9e4e522a32a71fa8b76da42b164f18ac33fccd60cdd3989070a954cd183e4a1996bdb79085f29604b7f821dd4b990cf9245758c9ce0798b996973d3d905810ef4b11cfff0833df7692b5c76a2e141d6ec290f70cd30cbb0e4ee70f72fee091069b83215a4fe684a9e6ba97a1a812ccec0f758cbdcd85100db4f30dd5b4d52a2a9c2a91d10012aa9e954025b52b7cbf184b5dac0a97b172faa6931c2795895a8d973e7aa467db6648c32f001b9029e6f4b9faa4b0e53fb5672b5ea7dac54c4f519be6bafa402889a0145cc2fc1c62080ab3e170b5109b28ac67ff8d8f1d69142cbb026a8df7b1491f923bc37c97aaeed5186e816dbae89658179da2e36a1108a57262d13d26fb45f02ed07ba8e9fd3623abbfcbf76c5c6c94dc9cc2dcbaa5a9faf720d24830b717885089a6040ba424ccb5b57d81b1ed7e755825b1c033ea8f9809cca155a2c0642df89379c3b165420df0f5a35810b005e6a5d4f4ee3cc8b12fd2671f06f4d68f7a31f7c96578aed3c06171e7905918b437ee4db410c04e4e4c4b61a3e444cc92884bd969023b296a6576330ee574f0747bb679f9fdbf1bb3f5f6e8efbc52b852c01771e43e665a0bf6460a0e9025d21d201fda96540e77fdee84d67cf94c689172e8b437d14363729a024811ef16309dfe32eec7cbd9bcb8cadcb0bbf6f5456958e490fd922c8d9907f60f22e02cab3259231da3d3af5ac02d4eb21779cd9cf592b5f53d41082f52a9d909881d596da5097de1e4a58b49a268aad257732abc7d5b999f73b5d666f1b9128224b070cd753db44adb5676ff30e2a40630e730b0163b269858468db2ef8c428bf012dbfbab704f0725b4a6f174919b92737c39919e997e86444265f403ea4cf664e857d90e937944ae4428da957b1464cebb7382db62a276348eda4487be3a99fec5668c446d2921e4c2f293bef59d611c424e02baab1fb8b35471a43fd4b2190c758dfe92660f8dccc447c4afa3f757fa4ddfadcfd749474865d55fdcfe6c037c78f48b73dfd255d021df8f68cf5eb2fd42dd9dab9c9b4885b1405238d1292c96cf0d561cbc12bf19be3d6297945bb51d7cc720a2d3acdd4f18cd10fe221e43794fe961b7bbc0f23d7f8a66bee775008f353417dafdcd3bbb46799179efea701437d905cc494b7ce6f430a2e102de2e706178c3235ca570976cfced978a291fa89fb6faa52752362c3b4e5fa354c27f81ff9db3534b79d127febd079b35d41313107059ce08a65d9255f4ecd1c46bc2fe6477b48b9a31ff4333d0ffb9e66494f6b47a3bae38be722584fb362292ec06901ead834d6d5c1b39a984b391c97ec9dfa3e119f65152b3b0b3fc7af8744d8d2f817d5a302a55a0239f077fbe59456e41b90ddeb85b77e8b9229c75a8ad1fc2836f804bea30eb7f2c90d5beea66942b68b75fab12fd7f8f53b75dfde713b9ed15ee6aa21533dcb185aab09579c6176985d1c4d14b29584e1843b8696614c2bdcf58f1a38fa9c7d6e66d21f08e5cb1f19106c54f4275153c912ab0bb52e2449dece626955b24be6591fac247e76dfb2a068821734961babf807fa9f3bc33eb8ccbb239928e38d0b46c55f4dcc4b8b1bb90ea4cd59594fdc7710938efe7c7b0dcd66fa352f9cd52794fcfd3d0bfa2d16d366d8a0fc50cf8d6a01438af95519874db3a54b437b681c78558e107334b6bf921834e78fc23d10fd807cc77744418f8b7011a84799f2954caafef868ea9d7cccf3af23784d9c25b708ed1f85b8c841e37ac33babcdf6f9457cb46bf6b20216ea5fa3564b943c08d6848fa8c406a4cca9d1ef445fe1e2021307125aaeb849325f31c8a6650e59651f1b2c45f159ae6820131da5db2ad73f6963b765d9de95b05521c777e0f219e6fb4355d493a1a21a7553156457c012698f0fa0ee1597c899459cf8516a306c21b8a55cdbb244978f7e408179aecdeb2cc2bbabcaf43baa2c8aea293d8720c29058f530db8c14718eb353910c7b390955e988c2eb66842c34517e8950d309fc153ecc05455229fb29cc130686af78e9c5fe8c2898ea69387c38575efeaedceae08f94c948c3387c1e2d52aab4bd480a3a4a2747012dafcae63e8ef877a88d5d697ba17acea47537b0e05a511368a1ad4d39347935445f83a487cc668efbf62128c1fc429cb6e1d658ba0f684be702a90698aa274e462a3a872fbe3362322fc28a6e717512cb041767e5d1b72fe2c591a9cb37bd6c1db6f278772905cc01356b97375264a278a19a5700ff0e44c7120e912620ca7399fe58045595336554a31e4f4b506cb2f033ee559dbc5f2f7dadb5ce8cddcddff181fa4f134b17b2669f77ca56aad12668599ccef64677cc840eef388f0c43aa6827d64aa456320495076e2bbe810810e1e3e66405206e06adc54bc9c7de0e308fc8f5ee556f36557f5e4ab559c145e32af14e4790283f32e513841949d95f3d2b92f1cef2ea83d6c3b53453d38688be35131e8e591f42b823032d8a1afc222e81c30e8a7323b0b9b18a8cae8252293c0c88b3e27219c8297045b8ae886d19e69d33f95c6dae355cbe5ec01703fc7c6fffe61e28672dd809f8e6b9ac01e8613402f241104b96b3691676c48778c8273558b534005ff1dccac237bd71739fc415c54f9b61d0c0a1aac66010795cc69fc074f8633715aacb57e60a89d0fc163fff4b5a3690d503dc6fc6e9252d75cb1a99e8bfc072a0dab3ab7ad5f93893e6094bdb328a61f450dfdc722e9e69c1cd54effda16330851929a469224deb82db5e2295996f9572eced3d5c4b858acfef5ee595e046fe054bc77666fae1901b5bc3dc7a986bcdf2e6f9b664ca0aaf09711a0afaaf69a87c9c7b3734fa0a5173c1acb7cb5963a4bff682fb5fd23ea2a3a5d4683af1d5639a6656361ff15898a09752ad097a6d24e6d4b1438c5e89bff9303e8d95f19c7fc688036f0843fdc7b6d7628d13782b7ad9c785b2a063bb617f14913d17dedde18ce39ae85ec8d3ec6a1a8ad6e919e3fab20028b98409610c3eddfc07c0ec2b08ec64da414d255b5a820cf7c18a7689ee7872659544b7029d3f4d93b0d3e077cebc047638021bee822bb7efb7136b7f4b284e916bff76a30bce49f1dd90cd29535160b10bc6f8b6e3fea8ffb468212f7de95dda313c4fb772546f4a560e979408e039c9d47caa1187675fbd377fcc5b86ab6b9ab4a4a1af624b3ef0c0b6d29d36e39261adcc1ca903c1520f089a9633c37c021a4f68ab0d214a44ab532a7b4a0bb6741d2b2379862bfff38132cb2d0f4da07483f97aa6a44f37420b2c45bfc0e49cf791530acb9e21024160db4a99ee41ddcafda47b08202355007bc5b9c7b152463daba1a9f34bc2f149c781f1bdc7f4792d65721e170db4b20d8ebd24b7ec94b2afcdec1394d12ff2a8b0f10bf45c3b296c327803738f160e14f64e5359fc7c3c32faccccab8a0c5e0b918b0864261ad6a90b0ab2799e1e4b89cdfd32a7a8030df5bff8236fed45dcf74be8139a4ebea3fb49495c26805b57e7bcea75c342cebb12346cb6f592b04afdb9fc57de12048e2cb00a090a69b87c1d5a1b69c2a38f57cfd8138d275b1673f524e03b135740ee0381933f244d5af6289f8b46f1284c6efbd1b14d6fc2ea516bbb3beef901bb60b4149b0d710d9795b7c5dcbca025ed2f2b30255e09370809f9978cce9a1e2c1aef91a9c2414adde6dc1b61320ffc21e734e87ade1a3f24c5c18fde8f2ae10184aea1cb9863f01be1d4009594e4521067c5f579b8bf6094619f693a9adb6db8850a6399fdbea53d33e621d11dcaba2d95681ec8a563acfda936c972836cc6f38fa3734b4283a59282f71961b45491b34dd64e255a592dbb40702f31912406c0eb31e4e017155450696a91f3197c4d300a894e4068fe1b0932cbd703139ce4f8f99641cb13a27032fb0d84a80c334599d470799a80835107e184e0cd26f78276f4040711201289044d2ec261bf282518e98943e913e1bcb6c0900d7e1dd581a23355b3843fd5cccc3e9e5fefd157eca747f36a7e28f57d99b180bf051419fa11a29085448a8424aa9cc17c3ac83f9f602bc062469506bbe8c8200522eaed0c10bc3ff4266dabbd47e3a94611ad2818cc924707284f4da85dae43fbda14a21e096971b7d4d0b742ea07313fa2383f5f10da96c94b2324ed0c60b53cb6d2f42c5e9ae8cee8c987f7208217a7c4ff18bf1617c5f7905f64cd8bbc0026353ad967bfc6137f94e44afdc9cf52a158f51033d74c2c4742367ae297151e582cfe8e2e97ecc5e7a8646d1f8acb1deb49370c3ac9f3c7fb7e58ef10be88f29a0389862e8dd27a2364385989d672294ab270d438d788987fecc712fe4b1505d428e5211687c1bd3af79e432f590e7a1c44c772f6e64705140383971ff71edff43c898fda4666823d44d936d156ff2f364bc32abc2dbad6040162a50cc0ec58700de2c1f0cca730cd63102cd07fe5d65c9861cb558ea13d24ead99ecb720d408e0afcb64c92f42319002e6d2298fc831b9e86120bc7177b7ed2fbe0344de4ae16c3bbd83316e2f1bc958ad1c5714968ed540410512fff88945d2862b631508114c276e4776eccb97329aec4339ff9a87a9c42df55988e4d51334acf736f926ce734f86ab5e9ccce41b84005783428235130a0f0d37064a6160249578270e53e3a6a7ecd02654a3df5d41295f88393a76b8f359b69b9522b55fa86fb646747ba2fdbfa3f1a40cd4c7410629da4dd8b29020a07d4cc427f036677b691c79e3635f7429573f27fb4aa98d6991982c8626bc9d7de98794d684367ed17294af025f3a0274c64800b027b62619525e9684768ee0af88868e34ec18cdaf9a107e6c9edfe32ae61120b656d59215aa7e9662e73303005cb33abd6ac092909d823045805561c863cbec4b54f733de42691c5f03385b180f5f306551686c042f2c24f8ab74bc48a087663e6044fdc92bb7fc3e362b4b284a090ac81ff1d4ed5e20dfaa37b4902694be0ab5c39d007bbb8a57f06ce5cebd9869baababc5718662f18dd61187a4edc07d8e289b67770c209e31b7a148e15e94001df04e3c721d22311c1ec9647c4da6b5adb2afe30be0e0765d778fe2a058f07d0626098ad3e3a07a1c7d811c225ca515bbc66d9c18e6739569fe4d51d9950934c5f8a9ec52353ab21f362d7f483064f3ba2cad0a07b606155a61022c7e8d763e290ff5624ad4943e1eefd0dc1408ff8722ed19423bd939aa1950400821d883d9fdf62e3a9159afff2850a7982ea78e256fc508b59d9cd7e7d6221be89fc19856f8009e3e86acc52d5c19f4bcd776c309957e51e5fc97129d02f44436ba2aff459aae12fd6a9fe531f892cc1cee46c4abff66843545f0437a5a65440fa585ce5383aac26b52a75634757078709622a2570c452f31446b012fa49093bdea737096fe37f2cdb820d12538c6581be6f5a26f22624c57425701c24f128544817604ace97ab4cff4cf2c46a60180ff108349eb1c25411a2154508be0c0c277ac5fc9b6ca4a457cacfef6d43486b2d25fa8b6b26d34e9168577d2b6d9f3a61bf88b35b35b12c1da0c7e2ec11abd0fa4111b7c87761708295e44be4b2ef0e56c5de56c9221b5ea073169a636c823c737a38860170e1e12d5ae856b2086b4b24766970e507afb5b2080b27035a5e892eb3f04cdfc3319cd865a630949017a1cbc37881b0df7139412097984c7f946aa3500e2b74f4518018e1aaef80cd441bcc41d5fbf6bb36105ba93ed8eca4d78f389c152eb8ceab91c61a22099f9a9b8f1b891ffc25910fbe04c787c4a0cfff02ea3196bfbcb81363065b6bc2757a999493d44a32d3cf41cfe7c9d4981cb3a6db325f0ad16c1483c5cb8352a37dccf928e424fafa465afd412d4c3f4c2caddce82b04cfa8b8f0f451c17180cddc028271336379956e32da6d39829fbd576c8457b7b67456c405e12b19748fdde672235d51ec0a2bc1672ddf1935256385bd9a7bdd74f7285b62d1323f4c20f5dcbdd1d95983427d1bdb11732c66c9b62c27e7e55c83ad81332b47030b48a77673366e35054792c1c6ee37841479b5c0f2ee5dea319c6e656a210c4d016a35ff54f4b2ba2ac072da145bfa22e9af85215c5473a03bd75d47083a2e517e988157de7401bb3cd6b62660d6aebd308f11493a92c65831a016a3808c7dcc7d2db3006ea8c5338b000ec46f2a04a922741ee120c818d966a502d868593d7ebf2012ece35793b7aeb6e0a3c9057d470f2a2a0e2f3f184baf7c888a416e987729288f90bec052e2cff1cc584225756245056dfa434fdacf293e74ef845858b36178141b0baeb56dda7ef8933c401ea2ce969d0a541614865724e343cd0342e7dd86f7994513443eaac72ca4b0aa070a321788caf665965deb7cf256a685d32d49b9069d8c3907df77e18af6c63d8ef7274b067d1c2195b0f2fe2b9364288d9bf41d7d28742260783a52c4ab5cbaaa4497b798e4f8e754d57b2e75ce735de31ad92038824a51865e27fbe5a4fd856ec5923789e882edb634afc0f8ee5c4694368ee0805caa8c1fc7520d66e81fd5a41f0714fedfbfc6743e8f3e22b1eeac942dadd7817177fc12bb08342b6461baf8ada9eb6b26a87d6a82f97334f519c208afb104e24834b875456292aad9b9f60623af079fe6c540ba074a87035b2c515cfb51fe13c0d3eba1a4bdb321f11e8c60ced7510eda8168b6eab0ac338fb6ab4d14b7ec91d1ab9ff90c85e46af2714a5104a6c9be06f0e3382ab5e12587457547c7aafa46b96322fea3d3d59fee4920b04a2241e830e204e091313b3ffdbaf95f14e5e89eeb83085357aa268380d4b1f8e46e2116458f2c813ad64feefa8f3dde885bccd6c2230f41dfe662816e67fc5513aebc2dbb43d312751499b87e92dec64d87e61011d77b4cb06ebbf65a24fb76a8b7bed7290ee4f5ea4f9184b9acf01dcb29e542188fa2e1c2ad104c0a29b5171577051e0d85026133c521d353fe491e04edb71232a0f29b709d393eb8212af7720c932045a736fdc3bef53691f10031bfeff3db9fded1e0b32b9222997ecc26347f613e31d2d878bfe494606720a0758c5e1035984d4a265a16776fe4b699c9a1a01324c2cd37033cc9556eea18eeb5a0174112115eff6f790a8b771b277df8ca1d6fb1df58da59d94baf578a232f0c76813845eb1d5af0a2ec3ba5497e2a44d08f793752356304850876ae7dc35b6ac7551c28cc03592ebdda628ac40d790dc6e76e112564928ec87dfb1a6149f2c1e346f11ee36aef9eb29ebb5d42b587838d169c929af796bfaa1b4d9c4fa5eb1260a31cdd5dd6cee2b50fa86d951cbcd243207b0d9e7d3b36f008773b2587dd65583f986c186c191d88e67b08902aadf5a43b914e6e6a55e72390e210a3ca600f771bcbe15fe71ab605e77b61aa8bd528743a6506409319611784bf9a50f5a36e7032f46159965134f9f21e51b7bd49c3ce3e89aaa15edf1dec05171739aa6357a832a43fbfa05db62967fa3bfb0a65fa8aa49a1e17bcd6aed0d42fb958a7a4346a2c48854d6c556ecbb4ece173998fdea994f5c9a7a7398890f8131d0b37abe49f640339d77369b4fbfd1264e29fa6252df98f6b23215fa32035644f37aebb7ed9252b8c87cbb24c09aa019e736f868716001f16006822b6a9a6ed9b97bd546bfacd6c10fbec70f034833fb40267c6e8ee318746e9474c783962b3afeacb1d3ef3010da1090fe1e62a133d4d133ac24e60883a542ec466b0e153502707ae40ba3a7ceafdd8c44f3cf1b65b442603ad1f3f140d07bbc49cbfc615efa1d4581be5736e7c427f377b55838b25dd6d070b090ddc8a9d6523135881be1cce11c929f3f4249dc36c3b8d0e98b20d2e206b91ee2ac686180553e4358b2e3de24549efe9c9aa88c2bdefa2f70998588f9b49f340c4c0be439fd9efd3a046a6abd323da67ddaca2657ec98179b60354dfbe3b769e0839e561196ba10a1f6c66286a8c5a16f8a03e9e34dc5893a3a3b8f8e192c93067f33e485f6d94e647e60cc00dc7d56397e1e04bc9cd7cccd71c95607efae78d48cced7b07e86aae846f177b89ae1d3127be5dea383640df2a660df2aca91ab00e273847a11aa275d8b4543b1269dbe9402008cac37ccd25ce19e2d51359ad61e4667676b2a4a72c0737f84d4402fc421da4cefcd301fba586c3bdabfc366420ab5a267d6d58d74af21857c7efb0322eb37ba19286e21344e8d87e86991e3d0eb2d944c4b8c015b37e437f1b631d18c3593f60214606deba8bb8fddde0562f651ddf724df8acde274cfc05871fee7fe616d0b77890e322c8f77aea949b04eab62ce37a723a0ee53e31926e6fdd473231a6afffb3ea6858bdaa8563818dde9769281e195d9478cd6f50ae751b28465a29701be6c7358fb51ff2b21a470bd93f0f34807e5e6d6dfd59ad4f7b06722763b1ffc76d975441d0ec20b1b2800b1f1594b7eaf7077d6226a2489be8fca6fa5aa93fa8172b078eedb2d666cbd48956bb48131de34d38e7dd38265efb90299b889788366690acc03341b3a131fc40995a596a05907a77a3e3bc3e90558eb6ffdc3193e7d666ecc0a67c63ec4b5d609fbd0f26369be147f9a391f81694a6f2d27fdbd0f99d555e3d2eda2f77402522bd83d11d930feb87562befeae90284f2bfe92bde7fd383e1078ea6f8d9fccca668177dd0e9fcdfc8d52add3104654ce314cfa67702f7dc71946cec5b7a047c222516f241b65adbe8e30a8b4b66aa3b4c58141c53f6ce7d0c9d2d3094373139e3fb996638070397592da5a9f6edcc16125da69063179d72b1877291dfdb9016d343de6fa84b43462873cb89d2dceda4f69c220b0e54d9cbe15ff2196eeebeb12029774fd8cd25448338cc299559be1e1ff3afbc40f32ada4b71b10d1b9bef8ccfd18aae78f999d28e050ba6efb9e24b81d8dc31ceed817574de1b13c2c41f2cd52d191bb86e6a837f856da6d9d51bdf1549c144a2504148c6bc21a6a1d572d83e043d2167c6cd801f6450f61ab35987990de9476111700bcd4bd655781862f90a90fef951bbeabc88b33547d8cf80ba5883ae2337d4f6a36d51b4080ebe3619ba5a19b32f1246530da3e6d80466cbd864100b7e63447dacc7e95163daea8129435e85fcb314f4e0809e65c56e008ace8f6c303063b0ef2f5b2afb6c1c6ea1093a99d5bf13fa2758587e424c9271742ed5c82afa7d0fb1cb5c2750c5fe8f923e95ec6463fcd5fb4af7972dff5dbbdb1b3323a28a4e04818e9325f31f922533dd5b51bce6f5b79bb54942276577d2b2aac7edb4734cc44515d8276b46c6e094be9587b73a47d4af7ece4fba8d5b7f28f70447dfb098a12e3a122e0a202458f8739f76fc0854ee9b74b521e906233f77550773026ac3bbf76929a858c9bdf323e85f5baa6ddf483e26373554cb08860dc85fffd81b560bfae0fed64837f1b2b5372c304e52854f53c98d48c4d518d79d27465b52cbd9b79d62d3920bf713734a86fd9abd45c080d6559ea4fd5dc5ffe3e0bdd6c32d85700017dcc386a2af85f065bc72cbbe82ca658a006e3e6321ab27ce4845fa4fdd7b0b669580ab519c6cadbf9977d45844c806d6a102e6c20a4a57246874c66dd43c99a682ea3e7e5e2e17b6e9720992440e04062c51430caa71f9f1d59c2f7f00f4dbf7624c29c531a1f0a34fc07ed2142c5e9e2056d51e150699458ca72d9f1ce982faed3b6df043128d9e0b281721d01d9cc9c9d6e689cd7b8f2e306682d13d1083f9b3d95753bb3d97b887641e136b38a47a1f077601793a542cf95461274a2a35d1a9b9b2c41677914515d3dd1e3292ccefde1ed6234c11cb91bd6c2b157f1e705de32fd7f6bc3e1d93ef0df1647b73ef51c47dd47c5a37a88a9290bb457ba180c3d4bc33a52d674751abdf6f24b7ebf3f87c41ca841c4e1497409b05c5178988c8ccfb99d7e14d9056e6877e8028d6d1e4aadba2311d171da697855317054d5424ca7e0d6a8765e5e698a4758d76314e6af996c72211c3f231fde1bdea0977daf873e52278aa743bfd984f5415b8bb82478736ac59f487fdad0fae97aaca503d060756f2aac97d36c152e8d11c06d99560553d6d8836c1daad990710cec3105293d6f6a69715e59de5524baed59614d937f1aa000a5c3d816abdb3f553ad5670df6452d096546012c3967f838af76753e0b07edfebf6662c9f47f9480cdeaf15e95a000272c489b3bb47fbc76d64f3517a50477e9dfc443a46ee3151c3819c1086a452a94e2096392961a30650cc22073fb35cf21c2e4df75e5fbe2547a8b346ca8086475c21ad0059209080bb98c612319ba5caea42f2628737bd8c08130c8c2c17ad281ce38601b057fa5f30a05c351e19f4e4cdfc16e69d04ac237f23f0304dd6ec466fd1b149f3843bb13eee582a4df1aea9ad802c5058f72744e181025f746f2c019598c98d149e001d3dfbdf291cea66b292dd804039cb5db56a1ac659eb262f2d4206a85b9a7f2be9452a079bb16649d08febeb6a4f880ea5146c4b20d6a761748e3b5310862cfd34bddc84c3aaa4c213a8a1d10ec60b17928f532e8be894d91594c8f4740cc6ebe6fe1951b4ecd06c9d2f074f1ae0a2191ab47fd417170a9c12ae1465af24f6fa543b60fe486065bd89d7c2a0baaa21ed07def15dc57187c8662d0a066e0203eb8a1d9bcda04716bb006ac1bd86b9df23ffe91743203452b1ab44e69d26d4c5b3a77bcc1c51c298beea821231da5bffc82700fb4f5ba2aaa9b9b41b1b76c7245f34c0632f5bdd35a78593c931786236a1acb3e1c68724fd5585653381703560d1ad0180ae26fa4b518f62e89d0df0ee598b121b77d80ead82f46c76a2acefce982718e893564b0b507e3fc0a4e569fbace2e72f8dcb93f6c91a3593b9d472ef8f9fdbc867ed9666edf2657790139f51633d48524f25f4e620169f90456ab0dbb4d87f70ae09981e9d0de9f60f7e00fa8aeb57c79247530799ff8542bd8dedbf02fb553a11a6dae1da85ef4a3b3195f2e4ad45817b9c3710041452cd6d2ed2d659d37c53721200bc7cd46efbb073779649f9f01cf92286f98543975d97a0439c57701170482242dc419e116f9927556f08b8d833216a667cda41b565f9abe04b2c4168308e1a57ea4ddfd7662bb2b4c5ef100d929f2bd0d0a3a3fedb0b6a57cdf6de5d3842a525fa87c41034e49b4a671dfe638889459f3db6117c4888caf881999fc81260240bfea83d28b0612afb51be63211abae38f8a106f503f714d16162d541cc7382b556f5503fad71c1c64dc1be4dfb77de7f4412b0f65f186f196e464795f3d39ae654427fd9ba2d270d84ab5e98e4f3c45ed7f3feb40aecce7dea85b7543c92dde465c8692cc7be2b4ad2d16b623270bbafeb9e9d80dcaa77a11b6f08d82908507018aae645491e03de915b5cca7449137cbfcf7f59f4b6ac948f81b986840e7998189bab1ebf479109b3502eac6ec0bb625580411555993adebcb0ba91c53afbd035eb2da4add70c5d18e617b1b10c01ec97f9ddc5c84ef0882876d97b5cb7fd74e0e433c0add6bb0c1e2fcf7d065906277a01af0a00842737a5877ef3ccfd31a75a5ed3173367b872aa62965b1a7794234cf1f45a2c51f44299d1fd567382976fdead66de5a80d6b002f8953d2b94c358d93924346f4edb8fbc8fe5b551dfad3236279d829b54e56931d1d1766c8c4bd760615cfaf3de66e947ae34c3501f73d08a1c1e4289ef4df8cd99525f091fec2bc5e24b6d3a36712429dd8f21f64f36e14c7c2eed9f3d58d15ad8b4794ae13504bc73477bece0b3bec8b1c7a259e3b5cc82aecffd729bdab32faf882edddc2dc79cdf93479a931c04599bc114d12bcf5a1056531d87f657489c701af9b8799e6038d781ac7941576217bd46d7eff724931dd7d43ee9a4f183a932485b470be8d7809c628d1d04cc43b4a11fe228be1af96a2932ac3ad62b20085066f65c419acb1bf7e0a582e7919836f026f76d7ee0c4b124d2965c497a34ebd215a4299ec5de081e411d41373a19b5c8cc5ce38527239819a29bc76d80ba9584e7393bc79779cdd990f8eb31606a5be0a4572181804ef525c6f9e6e537d3680440579a6e27c633243618c46ea949832d6f39cb3c7dc497092277328d369d4aec4da1e009375355b6abffab1ee864f0ddf9e200a4298db0042aca6b11d4047eb03869eca6c7449699ba95d4d3b272bc0ef4962831fe829dbc83578138bed1c6d6e8b399c060b44344708845cc916d5cb79e6042387674187f318fca77e944668b0b3f830c8af27a570c0b4b9e611953aa6652be029f63c4653c77c51029b943f115e3d49662b2428664de5b9c7381c71290bd43495ffcd23dc2c54ab759558a728ecb9264ef7074be23cbe09ea4f0bbad4697d443710e95ed3572daf53a32c0aad36850f18605f7b5a9cea4f52ea7b1bd6f747f0f70091970be75b50e54212ba63e620b742e29f8520f680bd5d28ab6098f74c58bccc5a49066d61c93e30c8507863a4053ad06bf5fdbecac9c64ee86935915c37c8adaac906d28ba8b7db041f0baf699f6c9a3389c0554e507a0fd0777f6c7ed435c58d0ceb3d327dfd17287fff23362d0c0672bd38cdfa4fd9c65dc944df36cf68438527cfb6f0f9125665883c8b9404e42d9d731f106866ecdb2857a4da7ab1ff864cda0c79294195ebb2068dcb4af4055524a476df8ffc4fe8c90ce4e533e89ebee2b91b513f00f4e354226f24166dcfd9df0489be7e018af833a050e02d819edffecf75e37f8bfdeb0af6556e0d924fb4ce25eca361d3def19a09181a5e1f95879b46fbaaf4392f5cee2babe1ba20ad69d7c322cd9120d9c4d8ef22305a8b1a22e2325b41a0b73e5e522a8ad2003466a06cb1544969596616384b6173becff8385b2f34909c1fc85e4973c7261b949c99f7b799eb1d50f5314708bb34d8071745f398c13e1a39b9a963ad6185c3609324ff6c5bcd00e5f2887f04674c66233df1a9d51c4982663b3e7489fcc68f275ac52aaf54ed700606ba9ffc1a51a2d3d874898084c849077ba023c53930596220d8b92639d8c6d6ce83f1d5ab8a1a211e50bfed87608b53b8b2efde56981b7f40f043b8b148a2542be1bb9f83c004ba8a0aed05e750dcbe7e38f388d36063387370a9de5b5d962cf713d161429fb87e5cc9130f2b204959fe418db63748fbb0ca45385cadeb46a8a751f01b0198481121ca8c3a8e6d16ef61b8cf14576b95082caca9ba720a959fa50cc48c2f95c406ed94ec8bb0e124708cdee7073effcc5ecca64ca65b3bdeed369c0b000eb19255c4c46eef1e1590e40773bbe50c2d0a0a3ad0c938126daf43be91f37b2802ca8f514920c2588b884bb1ea189ba32e3ba40802418729e24b88d803b1bdb93f93f462bc42c334f8d15f4166828a4cf2abd8f03252a6ed4a434d4d791d3c682f0c133bc656f7babd3c43f87f54f7d0087e19b1076e7831122dd326f66ae60bcb3ee42bb837f48a05180aa0754e0fc51593736468c85eb79c6efb9d97e39099f7829f023513c178d38d13a61899ca7e82b6aedd10c87c799be2071965f349941b3f9cd5fb86b7dc482fa00bcd6cd36ee2356a8a5a8ae3f9eee1e1514ae8dd6c0904e329e86add1bd6d25d279d538b37497908a9f318e812a5c0a77c6a69ce50b851f6aa7713c3a8431b66e50dfa57486e7a3df4d4d73a2ac72888d9cd7db74b8bd192206aee9552adbf5e6bbd19f2fcb2c9407ebed84fc740ec703fe3a3dfd9fbbe65c68b5155ff0c4d4c5d230055ea285c2339370e8a3e401e05fd9effd15229e65031c9e25de897dbbec5f8991a3063ecdd24b791b1770551567891a125aa809e5255b077eae4bc9780509b6e711cf40fbc35640e5f37c55bc50cf2386d1dd4f2fb621e7b7bbd116dbc76cd5a71da31ca1a73317f6749fab03ba5e99b7bf05361e7b03388fe50d0c863598052edd210008215ff45efc525c04587a9273629e4576b4345750580c5cabb62cec07215608fd48f043829ad8dd559b8ce8e382c7ea72d55c24d1c936436be3b4a92f5f1f686239d42669a4974adbc21c75965e5b969606289f397af32904d1dc2baa7c3d5a8b233bedd975ac89833671ff8ee2790fe3e71a51eda1ab982f2cade46326f9d09d38f4ef52dd951807bd43ea0d7ff894f2d0209aed4f57a6402cdbf1d92246a1983c0f71fbeaae02799d259550fbe9e0c86366e3efc9eba72488d77e1db5a2c803f315b6d81a592d905b0f0d0ac9bc9f13997e04109f2a8da6f47dfda31f77035845e180aebd515a12ac88cddca0189dcc2aeee869b7df64d4349f28a5ab9ced7767a42c4c497926bc1a747afe28eb4d6081b5a3cce8cd257274a4a85329bf0f5245b0725d938f7759fe0813bc909ec1d2e9a4d2373c35123f79e5da5e61a88ddefc363ed939984130054331a9ed32956212a54352c4970bcf9083d690f032e983ee2d98fef55198db6e432d9e7137ec585ff8ad5ee14ade55373647ac4307e88ccf5032fe4fe565002b0f169d349147d09cb58bb2a2aa36a9aa4fef301a5dd0b7443d50c0c3bef27a3f4b80731fafdc024619d447020becf9c62f6769fef8b063ead9824965654d9d2bacb5122f61ea8f22e901e5c6ff784799f940bb3fb66a7dcf89d29418e5ce8e6d6ffa8ec80d5b6d798daf9bdb86ef139a5327ab6252e6d2da1781bac729a27cd3acd32f11074796db832107d5a5859293326a73802740aa0e8ec077719da391aa86aab36ffa5b069cfdc90d7fffca535b538d0d7c2d895e55050172c4714e567ea8b6db6aa674d9633a090a6cb1ea84e862c2ac8319a5d195e3a1ba0f155d1ec8620fe566097b8d98110099c20fd8ba9bbdec1eddd97ba20ae874540d231431625de96c527b958f016d681ebd12d598d29f2b4e334022c8eaa5db81e719142a5f9ffbff67f5c803cf8708f509a8e2d16bde1efb72d0459d83418e21dfdc6ef98e79f67c9590db06b7f2b5f70e33b0410003b961ec5205cca158bc0f1613a399e7515dc7003940e67b55a7c5b8970cabe68aa424f4480f96202cbc6c037c8ec5ea420c9246740f9a7e46250f040f5a3b26f5e6cdec9f3201e2e248fc57cdcc51509d553bd85c19bf0e4239ca6fe80e0513e13474225193a106a535b29d25a6c57dc20030e692222f7d87a6fd530a20873f678c4f9d9ae3efaec5848bfe31a25ff5c3d364fb70f529db5e1849d7191af01f6b5ad233ca89cd418d122fa8208f2e479bf8f9ad229ec6a706f344848c9d8e626a6479cad35ee212426e3234774214825a77deb053146e512e3d7378cc29db8027d4a985497f8b4cb634049b8248f644015ad9547cc5f1a4fef3b03015777fe1df929af0a8897e781ce6dcb0bde1a38a276130b902e36026b76baa24f75d64264292ff05af3fed886a95a483f54b88f5b730d9bb7ac0cfe74bf2f284f1c33f1ad13d7e59addaa066e6b67c2cfcd77b36728fdbb6dcf3299ada2419e4db10905cbbb6ebb2e7519be0d46825e70f280869d61b50971465eab9fcac0021986a134105ecbb5e435c78ba14de737c298a79a90b55e611766684249253687e8b856dc848a99c1b0c4a47a38dd50e60ea05a1389197b7866e1d5332fb08f31b02f3e2faffab3ff06464151e7ee0530b22946e1852f218f115db97d9abec15f1c25ecda83e2b296f5c35e4c9766415318022a21fe59954346601407e1e9142638bac23ec8bd69af34275f61ae6acabef77c17680a912e6a637aaee0e3f27cd7c36c152e1551fc0ee1761fd7fef5bf0778efe63b583f95f362cc28fab959fc4bae49497dfbb91851e068788b31127bb45094b48c00e4b9c05de44e8de9f9410c51dd75d83e2595eada576fb73906fe9a7e29d65e3d3b8e5483d0f2f4550c7e6d8bdac32e9890b9e8e3783153a8873b731b16b869299b78e57a0813abb8187b8d684976b76b5f4854ce972e9200ab00c8f3057f6e59fa938de865cb6ea4d528a46b65a8605b24017088de06fa2b8dabec8f4e5b35a8849b3b57683ab6661de70b3f3aaf8ba7748657b2f7db9f1a95dc487a7aa6906ccede3327de16e2e8b381ab3c558f66700d1f4f33759f74a77f65cfcf7940fe8bfe24101f54c39c53d90562737735c50b6920bad7664102f65bb05134edc727d3b53496afac15f89f9897545f585f4c3a8f81e2526df7c6fa75d936ab62ecf1c85542f64ea31bd7198442ee4a2485226d1c40a1f53851c7934e3051e84201acacca3da3273cf7c9c56dfe224b1b621d9a3f59f8b106938a130265396d0a5c00a393741bed43beb6dbc8e877aa305ebbbdd3f918e4a7ee82b13cb37ae80519dd8e22362016ff31546197df6560e6cfcd014b670344b7eda42f933f03ebd4caf525e56324c0ea211f21b98fb99bf950a784099b3ad2c53903b07cbf0863c757f83a74234775929d7d943a3d26144b9c3f4f6ed7eef2e1993adaae73b7fe7e95bee2decfddb2faac4ebaf01aed343451ee4189bd511f186a4e35fe433ac14afdc8a95fee3a50ed4e24ccb4f7515b680b8ee384c42845b0619c9b4005f4e8ef4cb24c541ed7b3f8f3747415afcdb95a5d8f6de4df97d228642564cd267bb5b2d10dc40db351f25a14f4cb242211a2ec4539eac5e9b0bb3e8f650bd55503929313a03ce695f5e4df39470e378c7a4e3b83bb93d150cec7e2841e00384dc0ef5ce1a09058dad812ba4773820c847d78af7efd07febee21cba8a6eb00cfa0c74aec0dd8b8eede9e58f28243d6c0b423037b451df5f5da290223212c3895b7dfeb2e24e139f0930e945f641e63c1210a3b625bc4fd599b081a195848c1783bfb4367f15c13b69aad97105609d9977bd318f15f25b427f2402c4fedf1a6baeae8d0e3bfcd84ad00803940040e931fa978742397a39f4d9385f1d395ee916af7d70a109b3ccb1421cc01dea04ef309e14b3a998730c23c5d49e054714a0aff02b08674a2ee74412e57c3a35d39fd3749c9cf93b0b859c5ba4c685231ea8b8cb5b466661f4f81c0eb4f2a52c90a24e94478d54ada7fd972d4768e97f5bd91642974b1231d07780f7ef43d8ddad4364937aa475c447ce0813051c0fd6a753c24cb152373430cea114e380d3d6453623415dfa2d475fecaa63f1ec6cd737ee600746c8452ad3523e86ad6d5de77c065f7572a8ef9bd68edac3c6092a464c986dbab62200d5574b45077f6f5321d280f116db1f51aad1ddbe49843336a06eff5b2fbace8a0d42635c60c9d254616236d3eee27de1a0880ea5e37c5603ddc60114f52ca1abd09241426a0206863c2b1be513ee35ed87135573479702e22c1022f6e777dadc0461d60d9ed99e719762e333ff3c7b7aa3fd1409f0f9087b76ff520453b44e0ccec66a21bddd84723d368b601730240df7e7f895f83ab55b1f6c7785a7f3d089508bf52d749ef0337b8d37f92bfc453dfc5d82b3d7311dab6d54ac1b88b6d6ccbe58e2d00e2a99e50c0c386abc53e4b7213c8b474d55a74787f533a5d4a911e8bdf548bc02a43e0e9580209d7e266a6e34f25529480409bff679964116510d74eeb9af79606744987a75b1ecd1578fe0819bf5d9e87f37abb99500552d1519aaee512d00a9151f25bbf46e4c2d66bd8c06425a2977a729b2486e401afee82bab3aa0fb4f1ef41218a73384213809c16145cfbcd45477aaa9495469f53bce79501cb39caacf168a18d8bb6d7c8639e2f04cc4dfcc8b0fbc7f169691f8873318284aefa252cffc798874649e1f8eaab133eeae0b3f306df43a5b909015c74bde90f8d18c1b7399e49549197c682a0249e4d360a7d0b1f79129735bb1d58d383ff1f3912a538f42a32c3b80bd087369074eec078f3609de71a56b2bda88dce6d8b0d48d23dd520a7b3c53f364886d0562bc8132b06385040cb38ab13bb57ef5b2392336e07adfe5d60d84f6f9f9ef23c0f06050593548a343de7d7d346b1f643c3f9c29510caaf582494877a5e7beb145033d1d93ab4f06502e35dec4557560fd67b14b41492b41cc9750f104a21a0ab471e3ae8f6f7dfc9bddccb510e7acbc7569a341858ab3449c918a9d64bff637b2dd5f236b44731946a5d0b550ed8fc8c705d07fea0c391b99e269e901ca8eb1b7905342ca3002998f268f77e74034c0c8595a2775460895f726d7e7b98c7e0461f1eb22230207cc7f3dfae4dc3a32998288c582511dde11d4fa30534e3fb76ddd3ec50c5acf0f50a2073722708dcbe8db4c4001c53720c92a6cd36271822c969c61e4cb983b0f85a66b749a11fbd3436faeae2ba80709b136e304ff86b36f59697fbac495e5776b21728b2943b2a6eb7452a63143f9f5e472c50ec20d5e8b32e54ab242d74124a99599cddfde01ff8e87176f4da39f1f33d91a929fea6d56ad0c18b99366d9d3cd54cf5025875e708da09723dd92a32657d680b9cc9b097d3a6e5623496a6937194d7843bb5843395e99a31c18727e5df367aec19b519cd5751b6ad297e44938eecaede195721da422d4176a124faa9115d08b5dd8af0711fd6a73888f9157d4cd0df9eca2d3e7c07342d518ed756b3629a15d88d5c73005b93d5dd7a310fe717be2040c7a473abaac3580c613164b5b974f3ab1471b298dbd34a35b8e7bf8c392e08feadd3b98756045a2fd2ab95a1a30ff42bb1de2280f0030df9cc31ad55f297b83fc0a864ebf6d7f8260c74dfcec5ae280f049b03a6e4848ba87d187a62faba2e922da962e4934f69bdf7b098e6ea40d12aa564e43ccd61c6cc0baf8c756cbd9b947d5948d645154b328880f422ab0840a4f42ebd0e4e58cd2babe0a86e3a9194b52db0fe888a0f40a671133440e922cec1c2f1025464f258e6dc348d5dcb73cc99315c12ef39e38a982ce0e8439ccfabf9cefef7ea701b372af687367be8ec7728cd5085a526811c191b4c9f4399c60ecd38154e1e7504912fd0b91891a23e4ff783888cbe88134bafc50fc19f45b117ad5363ed72ed354fb556f2fe26340e422178db0fe79b1f2662b2ded91a3f98504a41cc475badf6d1367efb8d0b1c48a250b74895d8001ab171ed7e6e1d67ba6a4b6b283fe9a925d5825b69279646dcc3b5fbd4fa48a22d73f2efa26dfa3ad615fe010ad489d78c0caed55be66c091d3c45d77f9802a193b4984fa13b7ea70e3344b35ce5c078608235c75b02b2d486d1271731d11a09b54cb5272465f14a1751ccf148e7f4caa8ad25b29bf802c6ebd5e29a0a79b244569aaf8e7d316594632715e186048779241d2c709e635d539388dc0f0de074e5214eac72b900ddb770ece7d5b8da539357216b306e70cefcec8c1d95fecac7e24205dab0d3ed05b149ee5c2a99e953112573321e2559a3f513c0a0e8075dae0334dc6a6ce7a09ef00ba394fb2035821846d39e4951ca5093e060696cdb123e17b924db303ac61287de37da1724e8aa9af0d71127271bc04d28adcd6703c041503ffd7e3709a052fab4e19771e507c5d60b24194a98f7e2dfbae77a6b8658944ba4ae13371ace32e802b6252e8cc10717e2d749b2af7115c0ad3445aa871734ca5f584054ec9dbaff5904210ac0ab99754bae8ae39b0dfa4a0c605c3b0bd1f12e291045024f32701ae91b779018908be22b9fd5d842fceaeef0e720a9e657a41faf0d8846e8cb3c6b2e516a0a29c3b53ac527f07e5e0ae56cb1e54c881f68be0beebbddcdd6654c765beee6eeb675523d302fa420361bb9ad069188b6f50fed0307ce2b15cfccd183af06e4c05eb15d6896089c196ceef9abd17703adc9394e345dc4e11afa63ec31d2720154340959174cc7b26ab568fe95d670165487cdb25bb4061dd813d60f810fa5ae3cd78d0acf1e4f88a90237bac4be20c1c900cfc9dbfb8d34d857b97ac67967b4090d1744d78350991a3eee6fe8accfbcf84ef89bb0fb8a59cca5df452b4137fbb10830dd6e58965b43d70b5765ec890918af808fbe72814ae002cf115eb3543a62ce82559959f6694ecdfc913aae399a91cddfc9e672bc44b97bd88a8f6958f4b377874c15e98858c520acf869e91b6121b6e8cc8a7a808661746c0bd5efa929cc8e4a3e7eee641e00382d4c4140b28869cccc521d13bbf6a9e25e16d3165adaa5761f20ec60f4b3a9876a203858a981bc6b7fc7c3e5876b8421bc1b140b55f2600015408b5f044aa14ae840c717022545494d2ff9df5676eec14fbd40a634d5618e23a3a9f9c2b1bc85f2265a3f1b6dc672854374b440c403875a53a63d206c8546895e49708c154b8d92ca9ab4eb88ba40087b920a372b83cafc7f4e7a60fc642d682db06970e14c4155ef1016ed7ede539fd26580a12ba991e87621911162f1a0b312820d1c7a731c44dd1f65df30cbd7e39d14686c334c99bd86d40ccbc621a5d3e0cefb5d9360a67a5d43604b32553b4dec00b4faae002e8ae1ab3ce81ebccf3c6768fa224792c86f9741eaa0335fa028a4c6943b9f59ccd73fe1f79a0fcda4e653ecbe7dd6797f86d04909762dc222bb777d1b1f41e6ae37610100e9113549ba10530dbce75a74480dfbda7e88076f4cabb45ef324609c423a6bf18b1cc45f9c5e7e50c00f1eec6d6ec80414e731fcabc0a5117c50d17baff3e52e50f6bf3151f7a19251f4c947cf42a129dafd8c610aee426f142e47999da73d65e5aa486d1409da877ae72010067212f4b683365dafa3e48aacc3ad4a210087d67ea1c92de6a9e6817e9484ca0f5cc9138751c9b66039e18fad78d28ce9198a9dc7d0143b96eb81ae8a75a3a79671807102ab63261273b95fc070d540d386260721ae15a64c758cb6cf3110ea29ea48f51ad17ce0c52c07ba03dd985d22bc036f3d30503ef410884acc0be97db1c895208be24e85db964cb36065d6bf2dea38abcb7f5251c46179b8fd85b8f26a441e47ec78566fac0064ccc515004be1eeabd009cd4b4b42e78887fb442649685ff71d676ecc8e86daa317b2ef70cb5dd1eadb2daaab877a5bc7f9890d7ebf5f4ed4dcfd375f80ac139a9f600fbb30a735ad9a2c61a703f17a2e13bc3d9d278b60ac8b8d4850ed15a0dda6a87d42cc93980f805b243e9988a926c8f7c1371b8ec74144286ca6dde35654e9de850014fb1a5e36ef69c195f0e9fe11419b4ae21bc17eb5fadfb0dbf16b1b96ca1319cf0637e423dc4c9d84e76f945ec23d63ef6ae685a99d8f45cc1e79ad0f7991b56cd6ee146e6638b1706f21c627bfbf3e548598ef227bb617d77ec8cf5da0279a0f326a85f4b160690d7e33aff79bec45e83be55f62e8c678a1ce854e3dfcbb8cf23a0549859a63388608700db886df355d072e434bed047d596e21d20ad587090b7390388c3d290ba1621ae86555c1c6ebe26e0a49408010c5f47baf8a7927292f7d206feb0aebe37fef43fba3fc038209beb49eee9e8294b98e9370f5f7a4368d85b6b0af4b30c60c41444513b6477ddc300d923cf0c2fede7465b26dd18efcb1257b7797d5b7e00b2c46dc72960e3fdcd53ed81f231ba4f71a825ef5d392131d1be6e92b4bd8d3fc9a3a5207a0b844b8e41aeeaca80c9a842808a8ae454c2f04060e3daaa2feb13bf49e7f94198bba4314bef631cad6e21744f00a421e40cbbaee64fbb54e44ff1a90439f6badae5b2dcf5eee38a09c075fbbb9c3208af3636c85bbafac240209d0091328a6b03b5132e9b67cf4f2ac6a16e74d259fd25419d5db1412e2fd474b4abc645b18e6ac8d6109af2ce522f2efebdeec3450ee99085826db7586417425d3e73aa6198d1fa853d9d0cda9356021d828660121802f325a64ddb1fe5c95c0a3ee3f41a9b42de718a33ccd4dcd839f522079bab616857cb09fae4846a7febcfcfc65d9cb9fab571f010bf9e952206a2241b9e21993ba3bcd43630434dec04f2fc525cc53032720674e460094111cf30f001725477cb1997cb608290ead285f607f55a6c5b42d19a714cc4b533371571c2747897b0f917b997f3a95f8adff5fef5ebfaa1154ed458570584fed55cd0d84e146091d56d334c45c96c3029428b46efdf6e06708eb28a0c13d5fcb2b69f08c959859eb743c462a163b2404795bf81e19aa2afdb5d5036cf71db5ab12d8c3c05aa256be58d0f9072670f207434c1c4ce06f204175596bc6bab9240d7bde4a545015aacdf2077b08574c4d1a2d306fcf7e9c8f4c16a6d1092130b307906f711fe6e32e2be1c37c5928728c7aa194609f309840586187ead2672e36e4b842bbb1e3290d1ae97321a64d0c400d98cab802b24801cad5c06221c0bbab54c05a7a7c58a06225b0ab7e04539fe20e8c2a53406adf28e3628887d12d4f34fcf2b465695234e3b0315e821027e70d2f767f02195a62e2d659f0c2abf651bd108323ff43e7822e27886ca3d30a5211eb459f9f9ab9051494befd71e751f05950dbf120fe3f9b98b78400df1de45bfc67f8b409fa00b2bf1063046a5256a6c46ef59aaa3d3be239fe006d1011f48b7c218ad1f596790dd4c6776c4b0bb6c025ac8c99bcd4cebd3d9c8de12673a867c87239760c27641c67e34a4dc8d67d8a531e0aac28c1b9df6fe5d68a7a90ac209e0d3fc4bd63a269558937931a297df3cf16979b879a95102d5b3f4940e6cfffe454060d6bda8da827a671e030598a4abfe76d36fe82019d1ff8bc2d2ec9e6100358c8be725da4a10719ae5d432980e6237ec73920e7f283d9468b1a54f28d2b5fdcc01346c1aabbaaecd46d9802bc9feb3aeb95cb92768d2b1f6ba743afba2cbc1c0ed5fd90ce04827ae78d98c3dbf14ab353fe3ba106b26ac7d8db19a797210e8aec9770c6ec83e36aa24b7327bd2b08738e27b632ecf4612125dc0687d641ee7ab8e02c67862ac863444e6eb0aa2202819d8c3d8c762072e5e9c37cb2b66efb99e446aff254dab21cbfdbce5f752aa9244c3785c184801f1e3c403f813e4022bb0c48607ab3b47f4f09477a76939efa9582414ac2ed834fbaf7b659c78b117f4ea5b01815c43e5100560863214965cfa9846bfeb18162bf414440d95a5e7df82360f7b9df850aa7d477d01cada2b25fa62a008d82dfc3d7ec1b10a65e5d19130eb6cff88027e7edefc2a8ee29e5b5277178f214018c8877549db3b88bde9caeaa64bc1938b38fbd33f19addb25fb4b92e61b202b9a1214123a90b1732122bc9e7796db3b1184d19ae28e39a5a7581c197671cd9900d4dd4bf2694f03db7fe128ddc3f5c134b79ffa0ebb638e62220df2eaf16056dd6b47862872b179333627c33183574657461bfc65ecbaacc13ff6ed31ffde36275b1886d7042f44016cfc7eac08b1bacf9a6d13ecd8abb92f44a004d09ddc673d7aa54df30b1488213ef7ea9ab2ddba59e7a24ff2522f0654aa443ea22f21524cc7f6a72c7ec42c41f5169c394b86d80b55e5f339ec03aa14c2efd6e7eb30a93a6788925720653ef3e958381d5597d00d8f114122f273a7415d2a32cee669bb5073582765a986c05bf9115c6e5203b8a6b5b3d1a7c5fb750c964648f6ac88ed392b20a854dc5a3f3c418e3c3356802f9da4f86dd46f9992dd101ff638fd25d9a3575d3f98f1dabc97256e376b00af21efebe57fbd0e36d8fe45206195e12684c07c3ec0f2776f3910de91da3f1925a7a95f8a55d19dbe96a23976869a619ceba5124f304619f0cec4753426e3f899cc845a5326f7525904ea89632b1a2bb3b719337755d256c22565b4e155092b3e3ef9e0b51e63433ce88cfda5803c054de928dfbd8775632547f8c37f3a626f88ef845d7a71e34e8c839d30e09aefb678ada0f2ea5c9a8c3d8241b010b4dff21bc70355dfd8545e363a8db92299b49c5a75c3e2cec51e83853c418b37b231f6fa4a7083ac57c705eca7de016df2d39914738c301fe6593d00d470253266ecd9062b560b32f21138618b9056d67c358215c7c81d02926a3462be2747b12c20ddc85a45760a8a0a04fd61f13029655ae594ef5c6007da0ec6a8ad13d64b41648e37cb4d754e076794e01aac9837246d8c16a9668c1eb12008cb483a819239ff80a3ce57616752210812df6200f3d468c6a18cc2c037d48d4f230b05e2ef5027ea4f697251b4d6faa6fe2a290b2922b396490772c67ed7a38cb37c703fbc68751bbb2716931ef13ce49caaa50e3574394ba7d8358565e05062eefdbf0c34a3d2079adc54c70fe5046e2163d2f22be93ac3cee79d3c4b36c08b043f0cd7c371d0e9a6507ffc6780f4f49bfefafaa16a2eb73ee74bfb362a402c52ad96f49eaabb5bbd7be7767c96ef928cc93c3687f7ac4f3b48405f3e59a43c0f0b577ec4debbae91f78f6891835299ee0314d7044957d4273f6d5f0b54217b609a092fb7795a346760b9b6ff3586716b8aa398c327b641318533ff1c5d975214859423153b9f3a21c64e1255206f96cdc914699c51e32beb3f5525c3765d3e1867e58be4a4a86b8b83b23f9fcfda2afc8a2810d58408ccd6d2bbdfe378df22aa790019127350039fc7bc8db67b9c88e62f8003ca6d7dbd24181ccee57022cbdb96b16a0e500aa50845e17488f262cd29846946c1b0b7b35e95a2d6a0fd758ffb948469bfb6ce55a90377668fc123d19ea96d34580de106a625648f4acddfd76da8551250ab2eec7f42f4e0d95f41e5bc0f385a709106ff2b461f6693f243fb75dfcde47d0821b23b1887d9aca55d3151215b527a4643e276b36d9cc278981150b230ea62ac6b85c70dd1958c4a66e637210fe19473fe185abda182c59017a9e34d88a1578c337ddeceb3f7f51ca82164c72eb902df4257979adc09ef9ed4927e7928d0b38dce5fa99e76f30a2fa0f51888230892aaec3d14292ca2adcfd915e46074f51cd4e7dfe4c0fb6f34987b8b80c8480b54916d4f73d38e83d74cb1e6ea920f1248ef5645d3e0e04e2664776c57aa963173d91127fcf1d53eaaf0117a070593e5873d5d0a1afabe10e0cbba9c34e87a990ac8cfecbd2dac6c5f68f267b8b01e5a248dd74aedda304c379f5a8b8e08fc564d0cfe5e368024b9afc218439a7e1d794281d3c8d1440be7e9e24733c3b79d4cee8d3c3f92883d8839c3d056e66b10c3caf4f9c335954b27676c374f360738a12ab56415d918b97df428a72fbc239f24965bbf5887c8c3113c4d90637abb24e767eef643603bcda1e21c360252c8989d497ea3e0dd3aa0f29a1c9b3cb3c96747a682385ee1f0ef09b4fa2ee0501c9f7e401c104a572c8259338e4881c6e36a41fe47edd81fe7c79f61c9bd691fe89abd9d885251ed4ff7126d537eaf2a586386b512d535bbbd30eb28e2e80c0c65b8c19d9b727b00f4c5baf3ba2b164d237251125ce496e960228e2d9b4df61111acc0999c25f0addc52f210945899e68983abf87f1073ae14397cfb1d496e7818ec7f7c16bcba0949ebf81da30a394843e3b866a60597b2397842cf10464e361941e081bca26235bc8437062a2aed247b4292d6181c81902bb74a6061c8a1a345ebac3b96aa7b89d6bce10b2250954c5828a8056322d23c03277e459035076eac7f662bdde069677894abd3f14b425ad3c3d7efbc2722d4738fc3f919b0d0ae1f3a456d3fdb31ba021b69933a6ec23357a0c4e823f7d6e0fc98c782d87e6fb07380bea5246e1cb04f85a1a5308bf5d0aab3f61b011a09921f9527cceb2cac5bc2f1a3e4605ffb61385510d5d320234270136f5108f9081ff0f669093f23aa459c1d7f271711f0769621149b989de4ca42ebc3dcc09b57ab043daafe9ff0b65923a019a149b90815444fbfd284868ae9c62e483d81eff9a512dc3234af0150d881acea19c9d13bc3a1cd9f9529c8584f3d3ca5df54c39fade698f37e4431f9e4f0d820c8afc19d6e89d022c71b7957ca7df7321e453655127d23c9052fd98874931f0643445781933ce599ab4f4c59846b02fe54f0a61b44380ba3f2547f84135ede348add531ad20c5cc69376c78d3c6942435cf030ec4ad8a299272fff29aa2641b8d72e4e4e71b9e4a830e4d7ff850bb8be95d7a476b22ff2660a3e6dd838f100713409db34e1da5e431a0df83a05ea71548a21847260c115256bab23ee3cf5e2cacdacaa2b19a94dbe2a33ef6b892104b2ce3e40cdf39ee00d4b12d5d681e19650f8592cf1bfd6d7f65959082da425b10ea00319b1b478a831a7f700e8749afd8e346572a4d1ab4f19e95af0362aafe8ec758bbfba4552e5f76670f0167d9915f0930b018dac7fc1ce85645faf79c5a2bad3a1ac14502696b0366dd88198703d88fd050e0d38f8bf0d3b08587783b886802b0048f1c2444a94e3e7b401869a8844b84d8f1b2364d6174f8584cbd7319b854a468a86bd95ca7f98cbd15338a236276c1b304a5301ac48937837ed800b0fb847c575e01872a865acb3908f10c7a0cf3b04dcc9c6975d849456b2c21313373aadd97772f0d90ceced8b682f3c88d6cf33d00f30f3488206657f2d825d9996b20aa08748841eb4edad33fd247f52af278beae99fb9c929cce1772d1b2eaa00a86489c8311ba0adb592f23d9d692d6e1cc9994575a1ac85b4406f69af50f181c61b012320554f59690d3252c1a977d4dc93acb86427c568acf1f780b7be22316613ee789af341ab2355374c1f01ad227f4f90a83db4680c09c51cc91c690a37bf8bde38d57a7930c18f33d8791248bae34ebfcfcca21026126af552cc07837ef49dcabf1e618bddfbb61a7e75f22ba49b17254f08e5d4b8f44ef34ee66b71fe2cede32f9ce2e1514273ffd735c6fd14cdf130cd5698e34511175b1e2be6b8fa6aba9b2a9fb3e43a4bd1198994d39cfbe1c848efdff60ba77297d8432c22dc4c32376f73696b945d21aba8628e4bbe8bc4649d7de955cd88ca3307dc8261cd8be4f8f9d2f6fcf793fea33db23e343da3a44e376cd394e85a715b2ab3ab92d9f417bcd6b26808eee12d01da77927bb4b92df3b22fe7c00a15f1e6db7b9d7c208c42c550773f6d227a97719f2b4fb19b409646318c97be5e26a320bc6051e20965066f59853a861ae953dec0253c43210f7ea58b4db58ef4f4ff54964bf6c8ab8c32ce2f4e899a44a8d0e6c23accd9178c1cb316d180be1bb309257b9470ef1a14708c017bd2beb8031f899724fddf43753e2be4c70b3848cdf764a6b8eba931d6a7815f53f740ddeeed80c288451a656442e877c82e04582b9ed2f07ef821293f6ab75d0411515af2d2a7ddf3e374dcebb34a6de574a85b9f588c22e5e4688e168b0e30e9f449c535f37a0980f6d35f3001e7243aabf02980785518491be764d08cabf447ffa7ecf689d5a9188a4dcb9769b58462bacd918c67d26951d085cc844a220c051b32f7a0732e311a28fed5a30ee51a1ed40c595d53289ad91c10d4532b9bce9b0d0cc0314c336bf6b735315e4cffdff20213be543b7c7eeef21ab7d2570567ed8805554ff87c6b26571d70676fb953c9c9a41dd4482ef3e73ed46795600728e3aed014ba7fe21c6ce1a5ea15a9b3c427e7b1b6e1a6f97bfc0a4007e974bbee3e3cb7148b19b8c9a78e29d7c6d2a02af31b85453971a690fb38b0de194a6e5b65a71e3f2335b7a14c4fd4ded6c3a0aca143903bbf1692a4455302c058ee26dbfe7daf11c9a64767bc8227eee619e2139f1c1362b7d513b2b9f14ea070abf57a7d364c8043897d3fba4f1d649d56e7abb5c0459bd522a1651715c79edb1deacc80dfb8d8bad2e1f9b67fa9d194a6652dda13c71804f8b2185064618b829e5ed90c359a339ed31dd352f667c1c176d85cc29815cadcbde131b967c4bbc7cefe688cf79ea33af43e7a9b2485da7685778e3484ca5ab0dd61111c0689710c63eaa8f55763eea34131c0cda8e298de3bb28631849cc72f3458b608aae28cf95663adc134e81913acdcf8a5be3f4ac3fe336b52519faca5cde64b68c5846315e1a710cd1a4a904705904d1065283e73760a1e57b9478d416d5a2068ad68cb3aaaed414a70cb4b386e01cd3b0d624e33b9501da374527bcd17a37db1f1f7f8a130228383a96932c7e9424635a1510db92a262e78fb479e356421eed02e40f52bd5be5a4621f35daef0d85151707bcf20365d985dd48a9b5a943ce32bf9e0f3f646913126c28658a854ba921aa7cade7fcf08031ee5d0d5b4e7125f949df134ee1d7ab34f81cc39ffa47d5f6ce7c958150b735239f4b1e2afa6689d8bd150258901144ec5bf60fd42c7c14f11be7234a937f83ad84d0279fb8a275316ac7cc79331e04139f9e6c6ffc7755bf32b1d8a2e9628c1df31fa8b40c112d6abf554e5bf9f66a994cf6026c113eb82b759a47f06a9352e47f69f766646c825281a2f938049eabd254392e6d0d6ed2aa322864b65c3c71d3314fcbeb07974affdf0fafbc5a9dc4bf307b24816779528b01da7524247802b8db532c17a22beb1b0a007d6ceda52c419cc68c525ffc3ea6ee5f916d29a1607b5c1e763ee6f2e01852bcdc041f4d78c4e998121ce67236ab24ee1625ffa1bf14ed030b8968b4eb85721a779aaa93354ed8a6a076c83b906a9ce407c679bd9bfd0819a9f3ba4622eac8658662a71cfe370ec4c77b414c7c28cf61bf8082fe50e44ffda7219a9800a322313d4a970d27d3d0af18bc87b4dbc8673053e7cb9f60cfb77617b6b208d8ba0f70eb3650fe0daf1a4920e6afa0a01fd710a8451a0c36ea35cc7a98cddf4154883323e4ea1598f6210d0363597a6cdefb2d822825909bce19186b5ee0568bbf03d0b52f6460e7345008f0d541c6194b4bf7b0cb165f4b04897bbfdf8319406a9d5c37ab9a3be8d9333813271eb8d6332289751dca39f50bd6148f503fe919c74c259e78ff2c01b1536cde12a6f40eadb9ad1b0365775a15150eb6b142624c3d01ae83276b9a66450ed7591baf79d6372389d8435e09af42c2aaa379fcf71e77100e12aa82dc0d15a7ed08d01ce2b421e3a35801a8d966d9d8b1b919e7acba0a5cf1f81cc9c94b8fa0d74464d028d4b76b5d9f2c36c7eab6a17ef598f4b4ce2dc85f109c6e73b57073372bc11911452819dd3b4db86756328c1741b92fb4e461fe7bdb19a11a131fce7788359e262713a0d91b93c5a4677e25607ad70eea02503777a351a8f3719cae08b08bc204939e18b1236ae0d8c5f781cf93dfa99bd7b070c88e4cd659e832ae3882269fa2ddce991d62d64212e9d1f2267fd692f79d863cdfe9433dfe1a61ed6606f7eeb821173a5daf7d40422942f0f41d18df95207707c8e9ddc4ec3087dc4ea839dfacc6fca51b0b6a04c1eb1ebab0d2f3812f53f69fcf6939ddf845542140d9ef1cc5ce859cb065c5b14cbc5154d293917bc1d5f01d202d47d60502fd43a90462d828379e8d81d3b59125fbf4f7dea83a0e19ebe739b585e90ce7f560b1e4869172e7b5b16d0d4d1def70fe24603025b9d76f378ec204ad584a4e2d315df0a56d74743a25fcdbdcd1bcaf5250bc814147c74c7dbf4b29618d544205cc4647f6e3bade8cf5baa1b1fc37529ecd972094a9f0cfc91c2c4b141b0ef3eaf089dfc6363e2740dfb1f20bfe4c17ebbb9ad4df8d5cde2042912d8bba1280d1c63449b2fb25c7ec7f221e3ba944650b6528913dfa70b5ed8abb869d274a7a39ad8ae055dab588dbcd9f5c30c9a200d2c8f56ec9208581ccab849533ea2324f6e889dafe04e6ba4047fa1de731e69066a0894ece8abb64d9fcd54b7a3fa2372bc54cadf69698c8541d4aa097dcfe34cc6dafbac5a4e082b4e5309501d2fadc326b8c4018d81b51c7c41635f6931912a7223d26eda705c10418839835e4c8525415f3ed0443c463faa6f9ded847f6e5e052458176e94dd8a71e7aa6d57c11c73f13e126ef5de5df6bef0e25cb0f47acd0b372fcf0077ed02d33556d682567c5e3e657f380b907088843c41a0595539474dd56406ac29a51c5a9105d0b08e0f1ead6326bd1e5cf0d8aee5e84a9e854d899aafa3310b9108e6c166ff14826ef8630b464debb217cfd0d21a5c859027f5663217c026a6a0e6d2864397cbdd4fbdde9faa5542c43575b2c65e4e564e8f7998258d0298d4686bf731351ad4b9ea0ad5249e0a7468cc33c09010ba558f8ac20029c3984ea8ae1c6b48e1947432a33cc7a1b9d6248b538f48e02be51f8c6e4006dffa6d042a2fd6fe4f506f7522e8b3fdfcca75844e045cd558e06c4eb0e6efc0946aede7a5953b04dceb99c7d3c35e37aaff3ec589714aca7c1f696bf88040c8e199d21f8a4a4088439f65c0c12f22f753441cfc269ae4111a0335983933c398c8e8df64e3f06d82669c2fe54a6db60477b5bbce99ea6b47f9b28374c99e08602f188bde948993e3576a203ab01e5a84294481dcab11ff4ffca18a34a4fc555ea729ec7c72316ea45ca8989d4dee565e21d34beb2e9df5966a1afca9e1efe8ba2bc4f83f40993da6e0b7660e73c388734d2b7d302aa3f6cd082852a40ff7ff3f3aeb0e94bf446c42f111a863571197a75faf73c3b96301e27867dd036809fd1572c98408ae00d196f1e3b7b9177d822f70e8afa7558dadcc4b93597b6298d036db1beac1fa0a2e132b98d1a8b31eb730782c2015ea00c1731f4f62e0bc0663d9ce5d216451cfaa27fe367e0fe3963e37dbbe5f38905cc1274c566c08cb71f98e247d96c990294d290471c46800f73a2684d61a31a101d5af9b9fc7989d8f187f493d21fb6d5d8d9bbc3fbeded0f1de96312c41b011427974573e85ed42f8b4730996de222e16889204c60336b7f4ebf753e3686bff1190aaa0c2512a520e2fc0654e92524477a606eb03af6eae69aa123252a4e277d651c17f683bfda11c7a3cc0f02cb473da7648cc73a452073386ee2ed2e2bb0b5b1b2500a02a3c464a4ba8da97e65958cdcbcab7a44ae42014c13e57b473a4cd9d13652409d6fd9f7d8127eef3cb29dfe6cc8b60d6a85765a7fc175bd9b51fcf7f94c8fa46bee5c014ea3ce650ccc53389ca7674ab7d58306c5357d2ca3ddbe99d26978016e13f22bd2a44a1cef63b23c5a3b9756ab98e47eb5f256c963058f2c0197347dbca9b059b5224caa9ec2edaf724c7dcd69be0fb986b747bec8129ed18c564ab1ad0fe97fe9d2cd592b49af7bea1b43be76ef7cffaf5594b9f3ffffe29a43fd3d97cd2abf0ebf529ac3a8bd7e7c8638f7cc631d991a239116617321a9396117459872ce7f030d90b9c75514df1e7d34af5cfd4b8cf6b068d59756e34bedda7aa844d679926aa3c7312b5f8b2b3f9469fd185d66be81d0be8a062cfcda29ff2cc88d213872c43f00cd7d12173d45dffa6a51e97c067d21be512eb1b956a1c2020117d9f320e0c519f77c2e9493aaef97b4ecb5e7bee89ce28a1e0062fb35b9fc9e471ddf209b029aa3538f5dfeab238131f2f2a0e1ffa95a9071ae4ad33fbd2e9c3ca5fd4868d7f82104581e44f5921134324d5c938863839c0dff199a31e3ea9fe5aa37301b4e221140f404952a8ae6d73f2f896596458147f8a5ff652938c949c2c2999e0a32a818b83281dda976ed45c7879c40c8777115a89eb36ffafd5d6d778025f31bf3f0a727c156191e8949b264bd804d5080bbaac12dc13ae86467c995adcb8bedc7e3d9ca45f319d1252245d7298a69cf1a18b272f8216269f6fb0ddf33e0f674415956488e887864a1b770b01bb48e1d45cb9def9436886c53bcf5b8d81bf034b51b1710bd0dadf2da7bcdc8b673cfdfce6f282383458a0fdb001a9b31e2c4be31845f5ce294f32652fa43d2b5d6bb7bde9ab94ad3a807e786f4a757afabc14c83fb2152db5df0c834c2eb2517845d0205b073705ec6478e0695dab7a0e0c84af738dfc5e83ac36b0da486172cbd084328ef2949682a33340a693adbca4db7ef147b6bec03946b88a71c86088076ddaa945e1b827b18661a4b7529364bc69c45e4c8698ccdd7dbf4c4f2b00cdf3818a1e67a2f2ab141bd4db9d47d2422f41b2b17f5dd95f1237158a6d15ac2522682d191aa0e2fa884af0620dadde10fb4575f94e2c0935db20433daa3ed0efdd88fa8f87b7a8435805572fd1a53f0f7bfc30c5871b9a4b22cbbdb622b8a77deef5a38b58ff64777c5c5a2b0d8baf950d389882430e0ff830fb262844a3f021a7a65f5f3ed8de89831d1c5089ff885afff395dc797351b51a09631350542e17f8a0a559f89fd4e026cee96a703577c7bc9852ac4520fc45056d94bf064f8345589a14cb9cc2490b4b705a0987e7b7fe5d85adf493ef4ad70f323b4db850b1ab23008efd7da69047b3183dbbaf2b8c9c6e3699f2525511290ca94ad29b9236157ab8649c1a590ed53367d271951d73fe8fd2670a6579dab305c5b2eded362b13233c93d5806ed1c5d8f65637c9ca1036f65fc91f6a8924cb9134967ef3570bc7c52ab9d18c3a1f3708a171213605bcefac7e256413a586e92db8c4c345fe905e5894c1d60c4b81ec1d636b486f2a8d11df866ea4e7768c884dc7d99e80603336a36af247797dd25e531783ad8161e7b38abd5f454140fdbf335ea9f88eecfd8cc087a27400748bc5c488334051d071ac97486e16e2204ffea778c04c5c90bea41c19fdeb84e002aef1578d9bc4292b8bc33cf7fc630c0993a1dba85628e68f3b28ed20beeed1a4bf46eb7adb17cc6f4b2f89bdb2ec7c068668b86c7c20814583891db2966f0d1633d5fcddf6c2d43f70236c0225f609e5476b00bcd00f919e31164b90686778a4b815f4adfafdcc0f212ae71631f687b58ee1097f8a4de0bfa3dd9053046124b49b06e162cfb6a6c50d9c7144c2a3c864178a446dd5cc1b42d5166468d192f94263861622066062139bde7d7f14df13b905d3160842045e50873dba16fb7419464ac9d985d9583ab013ae0cb73c4ff7dfe39f3a9c25ff85fac6e0ff8b3e7ad5dcaff2fa1372445124c01b9f72a4e1366c1522298d1221227091a91a18329ae12f735d4c624faf926ccd68365b1fd81d0e3b4fc7741c314834dbaffbaa548d0ed194424b5c690e55b6ce4b735ed56dfd788c310054e66da752c5552e83d3bf5c54576c5b7c0e26b1c13afdc0f21f32e401a713f29659378df09a53e48bb95dfc2b2cea7bf7faeff7ec7596209fb387be48e638f9f54a58d6109393eb6285457d8da962481528043548603f36afa22f240a052774a276204c9efbe1932afc9e48b78632c41ab4a84378f26337db6b713f69b02273c6ab4b2784be1a74290a5cbacb9dace2788fa9cf0bd17e10268cf824da3b80012a570df77e257c168fd3f401f82f07e836a22c01cf05158546c750b15922ad8d067f679d36cc8608997be921accb404d1507d9aaeb23994561c06e67156472c630e19a78f4f2a94dd603bf77e4d222d076e13fc6629ce69e9e4aa4dbc07cf38a745660ccc06a46e4e8354e957580e7a78b3f523efcc4fe31f3f3dc4840f4e07b5af9ecedf78d183f51bcbd8a6ff2a217d66b6218940c7725ec2fe4c4ecff1e8681b1e4f1f02c59b9369a27f5cbe1d50c62428c1574586f6dbeb18026d2cf1171d4398832abc7387e67d931c09b298637ef0f83ca61ff32be6a399267a569fdfbfd965280e9dea48692861ab0aa2679b7f84e8d130c3a97613cfbca97f6240e824304da4969dd42502288733885f7091d2d155919d7c2c1d91a833348473747a3ef16e8d1a9c368cfd1de1f8979fefb44f71a00d99d49f1da8ede68717ee060d83351702d6ceb11048f13f09ef3e05133e609c0a37392eff23a46e29cec438d060ce4b018fa0480dc70617f826d07f116144759d2f57b6263a45a09eda6371a55fd8c135bb72a72706da0bf1cbcc15d928e9808bc43a23bee24d86201053b3ec35037a00611dca702eb1f4fb3a4e48f00c84ee6bac86be1c63ed5b96b2d7b703aa49d0f26cbce1b8406c9f02b334434ab46a09a0233b8ed7817f638bf7df0bf259f59431c0b6172bb5e7c6f2cda9c787b873ec204a3e787af1c7b2589217c57e080a53e2897e8632b1de92551ce8ce8eb983e7547d44e95b3a6bbf28f466f04d3bca479fe892a1899f2694368146cae9f6f09a724d81d0f198dd33795e0d29daf65c40398ccb23a4e19d4f8f83e9d295c2040f1a1d8f2d462b5698d5357ab56b82bd7eaefe5e2ed6097ae68d114323c12b6b7f4b13e2d5906999f4f24bd5c9e43a9d57c6948ad820d212565c7418cee84ad4ab9ca0f09cba28c02105d0e9892f48546647095ace4f4be9158ea197ce89502b0ada63894fc77c977ebe45ffcc042be682db107b61ccfa270562c686912a8d599758f01b8c230174a59cf20bb555e0d82f33a9945acddc777573ab2b75e8836731f6f8768e0099c6beeedc7d2b2ce554d2d200520dae186e25816659a685062619098a15a07aba00987f7e762916c35f69c02623b8dd2bfcf4ca2b1ecc77799988cb1dfb509dfdfb7e41bbae1e1c83fb707fe393b3c7cbb78dbbf985b5e840fba14dd7daa0e7ed08f380a9a6efc1793a5921ef1985a26b5c452cfb2e445319df877f876027bd69d0bbc75dcf03546b4b094595507fb1489467d057ca6b10456c0b8aae0bc1df881b49603dc9c37512cb9134f5f8b6b3b0d3a37c37cf696a0066325fbcb41fbf07dc1f5e6e66ca601445eb4c57bcc1655fc2297cab7795948cbd3237a7a85d96be663a3ca6a4167c6fa00b541a20c86fda290443a3ae51b244b4c84dfc1bbbbc7981f07ee150d788f6322562860c4e5d7d96f819c4cd01e3ce4523f9ef2e147705c9d9b0e95224aafd9afafe0d2a1a3c418ad4b5a95be4558873903ee062f94c6efc685e357f797c3fed84d8bdaef7dc606058f4cde6b577159f64f7e6c2a996a0df7920d14ff53f2c33298b034a6ca255684a812574c720aa8536f1faf60c1e73662cd50f49b3a6fa9c1d3847b9478501982fe9399058516a838de49837d7152b4e886b0a4700e3fe667866a6894832031d576f1c9f047d8b4c98fa99536002a2e619aab912cb5ce2b52e7b6a6a27feaa214b943a5a6b9eed8a8d084ffa7cb4d8794f395ba9e91d878ab7cfb8113a682812651e4787997119568ecc240ae38803e59101bcd302258cb616bacaa6de0d6600a42412b22d2876d5ea05885cec8bb0ee4d071b3c42b61aac99ec52c4f8fb5d9f8d3951ea96f718075dfacf812a0135ba3c75220976498fdc81664990b7ebd4019df19bec3118980e3475d653c7bade200d443cab6542e4a49c25ecd8c4296f1c532f490f63f15b9b66bc66f08a7219450e6d94e1067c521e9f4a93451a04a5902be053a8c39ee4307fea29d40eaeb8162c4764cb7514bd4acfe2ea3c6762f4dd86336715a088e99e35d0da23ff993cbbe393b0b85a2508e4b8ba2111360e05fff4cfba6c21db180ae850e1c077f27d3c2a0131935ed62c4685ce3143fda05325e4438404426be2c51be30f965521441942901b5c5cf74ac02bf1942f1731580ab84065a0281a59ac4590e8ab7633e0c708936d8fe0e5bb1e2d7ed60dc360020ae20e282bc3415e21c940417b9202c623fb98941fe224553d53df637d3040c5a30c3ffdcd9396cff8820e8c4604078db300e4dee6e770b7466b298e1317a6a2b3188e5d022a1e2ffd387247d766345c4d007ab1cf14cefd043468837a24f89a247df9e44b16647d22c702ed177da2d9d31ffa6b13fc755a6cdfd23230130fb4c4d05580d3327dcb4fdfdf31a7e8edf76e831adde4f9f940d3f4df388d472f1af0992261cd637242331c3c50afaf3fd6d02e61886c43a2a096a866aea75aa14fdbf7b4df051d1219e802f9619e389dad139468911a235f74f1d6997a8242f736a6b35f9f129370a168576d092b1bf2632725290c1b706792aaa43d1c17c674191bd63a2cbceb78952ecc2489e437b3d2f093d1e71f8864b72f49222049a8280173228145e930f00115d7b07c016417a55d561009e822cb616e2d599417677bbce15198ca7fdb3e6457fdb819d9bfa1167e83b4ea7653ac7aa2abc26ae4fba72799be7309dd31aefede2edd79cb5fe1a47875c20dfbc100d3db2012a531decb846464369b1789bb4291cd0465e35c04dd9b26f66bcd7cfb8c547d0e1270bda1e82cb35d5449980638cfb6f418a15973b383450d65b4e1ab24ee844a35014118a831b99d2e2b363b3540d57dd8937a8ffcfc3a64ded015aa73e4b34aa404a3acb114d97c19daa872b0b404c57a7df1c74e692db3cbb1231b35c0c2cff2329a5b199bdd9d0919701e110d30fe93803b59bf410d00ac4ec3600996a876d772e1920419e13292ba13f2e3ab80429c2b5a9eca63899026fe2fe7ce2cb6342ccf7639c32e47ecf72238365dbe11672ad7c41618d068583130c9c4243ef3bf30d6d239bafda10dd76ddb81222464688644ea2b8ab3b642cbe3b2798b3988a2e264bb693d02f742ddfd7ad081fda5ce9f57483cca5a19232f1e07c1367588f50b8c295d0a3c7b8ac385cb8fa4405b13572e735026ee6ff784b79b87912ce9f50395ea2c86dea0d98df8be5cfd10a05854d61a1ddca64e046e4d8f02f887abfa0b3a183f310698b9f3298b0c6e3785bceabfdbc17b660813732fc40bc167b5d5477f4a41a7bda59d51d2476f709c8b1ad2a1a9e193c34665e4406366bd304efa9b55db0639141fdf1b78815746e12798dbecd48b3ffc6ab76f9730bb010c59f8af7a3856871034ce6478df04c81bc3b167153b46f1bc815f744a4f5cc4376ab30d709ebc66a16dddbef8b173942846847f8f89b0562115f001cdcab5e1cd32b12fdb14433ddedd4da86f8ad1748138969cdd1d44953741d72764d7f6ff6767a7b8588cff221b9239d30e95c51a37f45aac354a3cf26a1c165cf3b5161544d6cfebf0630804b78c0624665e30d90b283feed4c280a85ba57f54a61d4f7182de1fecba5e4996aa0823de2981786ccd75060b8243aec9b27ca2eb1f056adbecf6eb825213e0bd469b54b5e5875af1d5253235cdf3b4cd25921e672ab4fc15b329064e093ce666b24d5b7699d1a729b299a344823a5bc23cd18e0ce1913d0eaed70c20eee5b1c80e3df7e627de55f725f2f80657b61c5ebd0452e2d862dba69cc743a4be184a969dc7ec5327fb324be2e1cbe9e79fda9a9edd58dd51251559cb7d3d3af9ccea5613200702d60fe3c334750f0d1a2c66851ebe87b3b3232a98d6c3fbdd574ff55de9248fe28898804326d104f4c680677cdb6c9bd9a3cd248a632389d16ca0b7bf70eb8131e4d6bb1e1e61e09a7c490161eced323abbed7e8bf9f26be5c9ceb5c4a127a1f6b0d67552e2c8c5f8d68f292c8f75613d5bb43fc0463879348a58c453d310bd0097ea4ecd63354a4927f64da2559c7d9b3f955c62945dd3ae8a4f37f509d70d65ec6500449b041adb55ba8bf5b44bf0594b7f58c1af72ff956b841b68e2196936c1347b0d469b858159a481e96a2a6e82d61ba85d9cf7bf92e5bc9fceeb40454c83863ca97b14c84be1e8d0a775e0217b0bc557f583a991c65f02e81251660acf54a0a08490dc91cb0c76658356de01f6ab20624c62136f359da3ddc79f6abef67cd738e56419c7a80822496ae70380e253d7de6fe797b233c8cf3e61b3bedceb5fb94b52b79011a13cc674142f5650c5647d7b0c9fa3151bc8a77f95c1157006910618dcaf21580a855c17edc22af97b404f645e30eade6d58dafd3a3f1caf5ed87258dcf9aabe0917ed6d0489645dfe1c379c2da23241edb6f8889e3ced7e53d0237b4ee2544ac4af3b8802881f35a4b5efab7a28114a60b7699aab809c47a4203fda837142a0dab431996aa50b6e52970a9bcac95536c859b3e6afd63e8b9c4684c06a67d339313e4a1e295e2c7e048cbdb75dfa10f0df3726d93ba6e643c7637c71c89decb120c75661906e9498c7ed8608a4bd10dbfb6a263477f64a0aa3b8af71c5340db4fc2e346667b8a79c7f4fb4e96671be2071f52a7495abf40cd5e1a460387f7493354be7e421a3b486a921ac2163e0d723b0a3085bb3835ae20282d306784342fbf1e865b9e8b63df207deb39afcb111d10cd4871917f9be15b6567c6a66917b10027d3bbe522bf196902bd5d8df753b3eced8a9efad5d1b474848ea39a9d0d882d6d3777499afbd3b35237c62e1294260895ed4431005217e73f57fc9837849334c89dc997d69dbd072db976d9f6272fb9f5d1e3a4e23093876d44f2abcecc6d713bd9d3638b9325738fe90905fcfd971a59ec5ecc8c07a633a78c88baaf65e50242f5cc2d7038fabc0eeb25797945b5b04298deb93df5bb4bc278814d68ecf827221f074bf89dbfe3f70f4e781d07e96bbe9e2665591080b06236223a89895d84d1fa9f4a23e938163378b62512edfbe28090e6b80b2fb9aa1de446a66f5ab994a54106cc28447a12f60773a2571ee9bf42856f12d58b360a468366ed7da7a1abea9cc1dd3e264683985b5776524d76503a9b1f35b96a10cf2da7f48fab4c1a1d8e97c20206a42eca659f8dcaed1ac96e1bb4a5ea0bde6bfb73606589a988f832b34f533721f9c78b964b76ba42d80ffc26101fe595ed538b0fd5ea960c8b89f5fa7941c87602c53809afeb41d6548bb1d9cade531973aa4f2a40d42a1615e3183594f21b8cfc12559a19bad8fcacd5af0bf45ffc3058f2a8dc7758622184db71aa67dd32a852adda110c69a014022c1750a50e3af145b779e6f8aa2776085c78ed4d1afb9946b5187abca15caa0835786a62863b473b9157c928008fc6f6271d2b3ef199cf3a87feaaf1cf3a636286d95132cc88664ec7cb8a5b6d044c5fa447683edf26b6575438f67107aedb76b3b3cf89d63896bbf21274597249ba7f3e5f7b9da9c8e59010117ae818d74511cffc55905d4b743caa12c992dfb1c8c4c42a37bbbe1622b61e09b20cee6e5410de732c732437adffff88094d9cc458c4c1df0180e6eb40ae4776ce8366975e2b1741c63f251f86173622dcf6785c78ee024a0eacd6de745d49950cfb7eba32e7f7c120521da47777894a4654587702f95b0964978338901e1d65ead4f010328c116a9f45ead50b9d5e1edecb667850af528f462c564e4b2a2e81fa4de99f77002fba94b74d94e426be5cb75a62e6793d4ffd0b67dc21a1456b7fab247d8ef229a9f84b201798701da5cce92487e953eda8af6aa673ec9018d5484dcde7d9f7d26cedd2936e11841e55e05419ad1e9bf7e6389c4a1a9f63f795e633c95eb804c1eb5a46ad4f95b9228044a510f2037c8062b1ea0f3668a804bf5fb141cfe5368e12e79b4125dd2226f7c5b6299c71d2a865d9547a1ad8131097fdda3a0213e16eccc0e8b48837e7003b2f44d0b7808b185b79ceff1aba57dc68b096474d9848edc604b16d88f23628e15d001106fd693df0f38137c3c4e07959a502a7f15fd1ec82dc68b0932bdc8717f58fdf8045c1895a2cc3ed2d2d6380dc9b20e411c1c1201fc3aaa0d8d4897e261a46da2661ebf7e87e563a4900527130fa9b45b03d7dcb68d8e4402b164adab7da0252a939f7d2722a71fc879bbae8cc8a849379b4f39016c326b72cd23d0e4324c1fc12336ccd6ab1006847bc48a3c353c651e83cb90863f002828f38ea0b32741483ccd37ea8681a66ae3008925944dd98230c96ace62dbec84261c224d02eec24b2abc3e88ac4645ab0b7a45bb5f73dcc171140b30435d48dbf1ddb07293cf6a02c94119c59d4e45d4fdf66110a4096e56e90444444f426879c5c7a54f77bf7c9c5a316e8feb35aabe344063257d47b3d1b04216695b881214db1258db9f3089a7be4a87df6fb27d9305db3af937b3996d821ebfafb06f7f4e98dd93271c6945effbeeab303444abd9e11eaeece6f6c8aadd013e69233025f62ff7d36ae373bbb94be30b07c6c36b738a1f4b6ea493e1b7a3f9f77160a374e78c5b7d4e1bb2b791130da562271973180f8c7adfdb5672c0ef50c947247a6e583ea79426982a1c3c4e44582fe2aab09e4f2c2edb0dc88b5706129bf3457c54f4e659e7ae8aa502a90e30a480f7c3ec7fbf95e1b5cb0216ee7658a43fb00531b5f235b420683bcd9a504ff3167f7b8c48602093a0db5cb83e7a8ef932de9b78d8d12f011ffae08cc9dc8cf4e154d096a2e4ac8fa8b5fa2980ef02d67a8897ad278430bbafcbef25be70f4391970a361a5bca1df941b11c4af59d5c13b998f29d2247cede6afc0d0f7d49e83649401934a1db2ff4f6ae609d28930ad08580e75a7b99d85ed12bb0600ca51a43d90c73c0eb7b62003c4e46acf83fb29da2f2d09e91b2a504fb4eb0760a602370edec92ccb7cedb61b71385befb71a6e37737b08bdfce85c8ab5d52fb63becf96230c334b3da6414f4caad122b6691f79203222c56ed3ab6e0260c021f4eab295cc5c82db949c792fc06f52f3c33ef978e0d584cc2c6cb245eee744794d303f58d31458f477881eb8fdc5e12e57411376acdcfb159195085bc550eb9b6823d7ac6df418f78148372e0629708997f3bb56ea486cef620ee04fed6d06d379ed2b74ba1d87fb59e69cfe5f042ce2cbbe972451bf8e294026f36a18e13dc851392aae5b61f2a3a9ef1d554de6ff9633fbca9e54b24bdce5d70642587ddc1717805a2b92659602373b4090e1b163f0efd501ebf01b1015b15d467e117323eeceacdda44dc53f039b5211ecfd116dbb894657359c69072bff6c2c658eeabfae36c865b0fbfb6973e969002b0b8ba8314982353b50856bb2bcad24b57e7b382e2be9e21eecd4d04c28a2b30ce15bb17b6d0a31324c265fe3d5aed1f93e6270e9a897aa532d6e7d827b20989ee4efaa909245d4515c652e6060f148920721d71f0421671ff11af8bea27942d04ac6f7d4bda8b6b603f24ece1da5aac4f93fa992d3ac2ea891ca3207083cccf8b647919e37727108b4b5ee4b8c969790cb8b351470854d6d96db9fb6a8ed0a84ae48f86cf1f747b51313e5112d3325f78be4f091cd5f959de7597890986fe9f623236332792fdc77f09b2a73faad378a00dadf509e706c404ad89d5d6b66f1983cce6ba5dcb48089369a58d02b69ba116a8031a4b78bd3e8d933968278559e4d0daa4e26e13b56f1184434b76cdd200c6dc52cfad044ca6b79764a51bc040005dc56282940a8fe8bc6819fa28f5999080da062fcba0660c9e082aabd50f5374ccd6a474bed71afb0b0abe4a9cbff79f112ff96714cd18954069cb35eaccf445d4ec4748787e01aa1b5488d75479896c511bf5b6dc9eaa6059b0df32401e38f0e87d5abe70749ba401e9e950468957140acacc44137f2916599e675d1c53c1221be78d8694f3791db1a52d4b6c92293f58794e0ef72a34c1d4fe4053b3f7ea6722037f48d806f7d0375fb493513dde5b149df3f59a138f83b63e9659b02b938c697eed1b4f81e54cc0c60f5664c11f422039767ffaf410ce77c82091e932ccae43dddd1eceb551dc4a766f46c62eadabf944cd96f4c64267a3b1ebc879849197b649c9609a19fb62574416811c832c4101839c3d6ba392e2517413dc6bed29eb97a5d883d0c753fb50bae1c5e14c6d04367ca45f5111040a82e406b5c0b4a867ccdc835252b623a39db1c29dc0c5626e91eb73571a85811258abcfe9cd4d85920429f97a84d66ae98b54eed6969f5e8407ae7197628b90cfa1424b37d4dcb02a30e54efdf6e9a74068086ad67bed21181a0d10a85008de3851b4268b04b13e69119247f87d4ec57a3cf0a7b4d8cb4cf51b8af19a9acd99de474a76dec8a1fd324722eb4c5db1635d67f51b7ee357512d4ef58941649a2cf75e22df960a793a1a0f2c67edd0bc00fe9f6559daac101f1e73e3c9ffbd95b37ec150e872d5a97fdea5b76904c14da45f56c341b708b44d2f67f0bdb1b1372cd01bb33b3cffbdfe396dba67de906b8709372ecb6c2d6583468d2418846979f585d813c60aa09f280ab9aef73cb103fcda42f2aa6d88e63f14efea1f2a3f51a34195eb4052cf69cb954b29521deb701890017b5212c0c518243824df0b1df1ee1ea601b70684405432361ff8f760f2278954a4600d44697b3472300ff2239d3b5f44448cea32ff618d8ef0c82ca26d2408a77d1cebba71271883b4dc439c68c03a3203f3fc6182a694521ed81d851b70d857ba10eee9c4acae9780abae15b0535c029cb04dc44f4b02227e0458cb605e00ea6aa97d749af07fd2c26b40f8253432f163d1c130f998b9d675d1ce8a5e8459bc3230b6de0b5b78439414a1786bdd4a21179dedec6bae61a96bfd2a73254a17edd17e88e6d28a3af348bde5456f28b09b9ff1598ba95c367ee7af06bd1c9b995de9d8f0cc18aee18889ccafc74a65a39a1ebdd65ffb58db951f215a65e084f5d553c08d7c69b40efdb90d730fd63dd448a54296d23a6fae0752742fa073cd61db083309294ea16984f9e12c389d02cdb6a0824bf5309f3a5d2ec9be5597d06f7f65a2ecf9423662777dc276a1dee6c7ad031a38651e93811f90aece60d10a01968d916c47e048ad2759ca44c77831cb67edde16aa943da2859b0382c1348f4d9ad8b79241b85f0bac3e1ee6ba171197d34779326bef2e31d05f95b40670faf8be3a501b4363c7aedfd31a757408c076fc46484c24a556bbf15317d6deb99cf7a136002130599a71c2e5873e9ae585ea802c18b69d16559ae07486ea644a9a079f09a66be23ba1519b27181f5f157d48ef713b340c9239bff7b7831b3634cb400d76381336704c83393ebb28dc633f82216d1e788c7256e27b0f2f73cd6a9bb0683099855d2527f46d3095af3c05dfb4096ac9a8c8c855fc9418593092f41001b263b2d9cfff5752e954e51568b9aa5518024425e058fd67503644aa70f4db39895bd6d3c0381fb3d7128695d18a8930851d29f2208f582221de47ea68b0bd380582ad0e4624ef9f649447f47ad11b7a4accbb416fdfa934a0a42c33de5d3278200c571440162ec682b67278298d4eba5691ba64434dcfe08668437a0d325649bbb39664cc6fbd99dc55da495bb5366500dc087fdeddb55310a26303d1239f8d85be5866ea6b4d2aa61390ecb8e549c62ed869b7d8b2246964d96d234861900d3914d8ff0b54af874cf69f447e9699d1f6b00289556034415c33f23caacae0e0c1e16aee42f80553ab56840920674979571785f2d6e15f81ca0a380b8dfd506f5db19f89111c7d74c762848a5017cd92d9d7430a4fcc34331a9239f66491231c574af875f4a920407372cf6ff0e3ac991a5f0ff25f4f390ea47b64e9a30275e9a15d90f1a228e5925130b40e25957d6687ec019e2276af5e1ae5543153e97607d92002b76776229f3f14d77515076d48309c8e6fa403f9010328e429be2d131037f3b1240d220374143da55defb1cf7a47336f1e259937c1d8cecea0fab74fa1222dfcf0b2082d27c8adf1b8b1e10ed1123fc2d148018f1f2ad46b0bc8564cf3e8c19a58592416ba7882b133c89df1c99708179f8b11a84c4db2f138ca047c74e09eac68da774301f5b43d63f2521535eee0059bc0a5ad86cdd075a25703a397c8e7d7749d5375af3ea901422391d065cf1f1eca3ce11a652ff84742592282d3691aef1bd93abe14a4795570ef4ec0082f3eb9506d2e60780850d47af98a15b28f697be7b9b43e024c5d098d51ef83177b9977ff0fb90445371e261f497f19bf68f97033aabda42f0d2384a40b0421931db96afccc37c3089e3773f6b1cee38c82b51b394bd9933c72524cbe5a4dd25a078e6b66de593ac7eab62ad97052fd20cdcc33690a37bf21ad34ffb723d6ecbf2eedadf33195bf0c385cf0a0bdd4ec264af86f3a73a9a9459da55457db965aa7f24f142fa10e106728fd1608f6cd196dd22d7e94b92c13de847d746cc3945d792c22595f4d3e6e3a88d22897def777f0b060324f8f36bb88f8584b6bed165ef81e707284a55406611284ffdc979c6128f5f86b45155c1956abc0ff93a47aa0e52cc32bb607b9fbca7d9de5a79c7d1f497e586a07d5ca7dee264528ae2d28093486181617da44f4d8620cbc827fa20cf618d70a76f95eea5631d73c9de2f93bb79e969533894bfc8b01cf968f8a750ba8198bec38aa486176934c63c8e4cf91890355a47b50def54b37d9539f41d1daea01d9c9f61a9f09066e524126d23ce40512627c16369a736179eef7fb3e6e1d5e5fed26cdd27323eac77654a99fa72f91d17b78a2514ba16e6d6b3bf4c1b063d18635a6fdceed5efa7ae91bd1bd6ef62439bad991532f4c5c61c8c5b7997dc4e5f9328f802277fc9cd54dad58afdbe5bd668a2c4b0dac3cfad238d0af266ed2b4c08a426b76309d8bcc679d351076fcbc7cdf6f7e3a46809d9f75c008c2e59e84ce853f958ed8ae89c10ad40b8f697de0e6c3d60b49503c16ce17ffffd915d95c156a790112c4fffa4108f86addc8727a08789796b8fd15f409cb6b1eec9595c3a2205098d6a4033fe0ec5c98a2eb5bc69d6e3c70828ccbebc0af506b9c4332a5b3c49e7afdca047d4aa83b388f6b34d843b0b4eb3be62882e3e27625ef4b6df16f6a013b8b3360e0314f28075635e436a91bc653a50aea9dde794ba9fad48872974d9074a0d7c2723f1c2a9c4a4dc52cb214bd7b65ae5b1d024e51701689b7c787e0e6430adc62475e60129f07a1186b671441c3f5742c8961ab8f2472bc308ac973294b2ca1b77012747b707d00216b9564662ebcc2bd101202394d6d04a2459a534b8127386dee35e80349d466238d37aef3645c2d8b445e193212b44808f24ec115c75b365027882b4a59e81cf8ecdbf67bcde26b2367cdbe710165bfd475ecf68907ed4519984e6f56c6b20981fb71c2568037f1750e2629044de2f176373fb7e32a847c3dafa0dea64059d6e4d67c41a49db5adc63fe30bb113d8a57c162f815fe010175dd419679c8029a431b0c05dbc3710b6eb6b65140d86ce606b342328867f8d9987c65150aac9bc273069c83bf1ba4df5e48e379d0caf44511c5430327cf445aa58c3d6aa55f3727d5c8953cccd599eb569621fa896930511b0459bd40a6234cdfee018683b0eebf46f9d195bfd79ccee5d6309ce70d2701974883c4f94b488d7c5f3b20ff232fb1639d5efd5c9bceaee69ec32fc83bcec3b66010fad4d4744b59436f0a363f46c91214af564f84c46973584e40ebf73ef97981c2486f263f1a5e77ca0efa88d98fdd206e16feb2096158a1190b5d2b46ee0ee802ef02b99b6b80a990ea0e1812a3f035bd342d26c4913bab488f2ff4b1fb940f70c56d9cc5d493126ef9d9479790c287f899ba05af0bfeff76bcf14e898691ea9bd566cd9a90778d7726d4a5d910e4a4eb67b71a5fde236fd041135ca61a83bc11e21c4b3ae91dafa1fce508e5d88d99968f53d9b2d0971c67e74987d977ff7124919ebe471055eea4039c55aa7422fd5bba187e7e774a99467d780a199bd8a72f983b4541573672882abf79febba05ab907bb211c93ef40f0323a8a5094ae539adc790b88d4e947a69e020f677a20e6b16f6555e829ad1c8d96be3cfe4ddac42d41c9080fa4dbe8a3da0398023c4d36470e548a617741b2d3d75bba97b881ae6073a6508c45428014afade5b4a80af0ea0fb13a84dcc0423c7099e2815c6784ab5c88f58ccdba6f8250c41018448ad224388a4378902bafbef57d8abfe49ca31b0b7e187d5eb703cf6b90ed23fb365048adf60b52ddfbc6cebf7f95f9bf1d4fd70f10d766effca0e65a83c30b9675ef457739538e499507c58f970bfc96363a002534db138611763e1c178440263dec73df26ff4cfbe650a8d22fb76d314c70b2a9bc0fa353aef7dacdd3fd5f6014c09902a9480fb3937c658b74a93d3639c8f03a9d43b97579fc00a6a67ffb32f65ee2fdf7937df05610cf12f91b9ebd099580d9e413dfd7b5a3e0e5ba0f33836813c28ea1ceece3b6b80beb86f5779e0a3a3195ac3112c036e24ebd0611f4f964ae0ad3b5764bb5df6a3b512840efbd9daf059928d4a69c91520a5897a8cca7f2728370427bc6804c60933aa9ab4785a10d2d098b961b5d728ea59d394e93e2a011f50c2cf7468050062900073532afacc82dbed3f7b2ece6f997981dca1ab1be46c42363eaf0d43b33f02d2a443b770497be4bf95df46755aa86bddff8c74555ec536a9fb99818528011f6c8983939ba031d5e2fec08044674983c8215b0576f7f64da4042cba2bba70ab87fd236af32ebdee5a9ae352620c8a8347df57dff4616a150136c2cc0347a40b9d69459d2e1ec9fa4803637aec801a868eb61adc894bd7aba5453eef15b9300251549908afb6a0218a6b9ec59b5638aa43862036effe28e8ef96419119359140ecf97d47efa4c379e27e9b2238c4e0acd9a74bd601f544fd74472858cec5579937787ec1d3f21eed755a40455dc185c60c84143c2c4f1bfce42048f05256ef74928bc4466b6acb719008deccb36b56b956e63a16684e39a5257e355b93837d6bd49dd3fb54cda6f5e70b93b5d1e95c722b9d2a93bc9e56b43eab215bafed4ece69ac67b43a975316e459f276db9b4e059b2363405963769fc8ccecc8ff8191732b2b98548ee52d250c37e2f49c87b505bd976e22b5c09dac95cd4bca1b310e46b63fd26c4ee453686949cf2457bd902a00e038bc70e7c8e0d36482a74a03cbbc930d0c6d208c4c41953a62a4dd49338bdde9e0f114ab099dc52330a49b5988cb16b9389375c0e5f27c5e9dbfe64c7911a3d596a350edcac1b11f91f04c47ca49acfe3719888dd73fc60d29a0c7128a33a8b3e8add80293b78347a1d7ef0eef34922f491c852f20501357cea81ffcb7d4205e52d59412cc1245babf45e39dcb5ae9d4142d93f1c76641a5dfca0c5219d4655be8e9939ee287b82096f610963059e14b95aaa916e7f7ddc4ecd5b63a5a17ec7a86d890d80219807d706279d9726bccccdb118300df43058e67f06a68c3f81a39c56e0d92aaddb90ad527f06f50ab4230172557a61993cfd6a70b5dca3ed7686344c79f263edb752ee0b62f19efad9e4b80f7f4256a757ca9e4e51f224d79b4ef26a045a5b7c554a47dfb2d0bb87faf46dc611f5c15872b9780e6773e35cd2e2fc28d964185e205fbff3c1cc52b270ada540e2242629a9c950c2e7d422caef2e98e7241fb4916a99925c2359b5285e753c953ddbb047083771ae53d9e401c1bd79d46bec36fe5efb21e63d7ace8af427c9730dd2b9a48d1d3ae7d18b3a5a1fdfbfbc8e0f6fb3fe69ddc133aba7b4a07aadd024c7a95686f45604d97386da5d26b556e3db1647651d67ac542a16949979035342756922192d4bf9852218d13c82cadaaf2d344df11132fb68e3af353edda5f5f452ca190e18af75340e61cfa61844c29fe578a20cafb3edea6354589e1b2e0a4b2bbb719c6381f23505854de75a9ffd1f439e342054648a91981a56947faa977d037bff52078b73fbf0a994e6628f16b7c83dc3e0d6bae095895954219e32a820347504fd91ba442ea69be35ba95c30cbf53852015eac3c42cb870f993d158b1de3504906575bc8b32dd6b4a674d5ec30d21a5df42fa0899e91d4ede3eba97c669fd2145fc39fb83e6887b0bd2fc343dfb1a143f47565285e8061bbdfc3cf73c0325e4266fb2b11bd7211f66923262d95264a2ca756fe7a7427e7b244cf90431a34efb3284ab10d9aff7f7a4ddea41088cc1f3ec204cb27f7902a6c6fbc6bc355dcd24f8b0f289523c3bf0eaaaeb002ac45ed33d7dbae54501c3032095454ab51d2593991e0a5ce492c72b32437872029ad6281234db1e44d72eed6deba7fb69d8bb481b0572facc2da5f18162fa4d4ae05979291e831f63f9d3135272af8187ff670de245f2b848d7e9ff13dbec3ab72f4037a1065c9cdfc24b2964e339a9e0c84aeeb926e9693efb9677393515476e6915cda0d2ad8a29cedb9fc365fd59d9da0436aeda047668fdf89ec046b33ef23635e486702038bb061b78b2f1feba5b78e7689a3253922215962738e1fa8aa94d0626d22f0fa0fb09a82e27414207cd98bcdf2406810a2fec9f1b7f11b6b1e642c6fd3070f33cd0de2adcd327077130d47252f2ca978f6175ab6a54f9eaea57d1cd7d67e2baf2fcd796a664944461d4a3593328a962de69ce34abf2f280c2553fc4a4a59570566d0ef01bcfde9bf87b3fb9270d17e2acf059fdf704005d9e93f72f3a1bf38dda9268988eacd088fd0431603a297e37f1921f1a9794c0d3ecd6e9bacef30d8a3e38eb1bfd20821f3bc9baa1d756f8c733d5c133fc63566b7bd60a0654f5ba6e23caaf19f608ca736cae6e658a21d2f7bc94fb388ed9eaa1e39e35f69b023b5ed083ee71fc2f939ec00bac59ff4ddb6354dc7071e07569ec8d00cac3e1c1a3c023ab5c2e047ef928b0c29caec447ef015eb8e7a35b5a6fd39301dd62f5a77d9942a62ff2804ebd23a241aea889908b381544dd99806da1ff5408ccf48b6847469cd63c77471ea7215f1f21f253c9fe6609dec0d349c534fbe87b448e4cd83ed4d225f7dc6a1b303265d18f2a9dee52bd053dee5025178ffafed4982a3d7d1e996b38785b6740e2cf7aaba86ac6e6805939ff7d400629db9fac1689b87588f9e4d206960935fac7f3c28255d4468555673fb15a57801784c328e5d716883da7d00d7d5559faca1467ff357ba1799bfa655a184faccc8c390fad4d8b54c8e970ce81f5550809177e494c8aa79475c41c864029462542d2bc48cf35fddf1bd4ef6786e04ae71e7ad36d1c23be58787d1901d382dcec2b8ae67c8b5db5829e2d98e9a10c256e744bbda8217273a0ecb2b120ae59d7f17cb07f0b66ef5153c682a8d866a055d11cd2711c7d7ff410621ceae74281508d88bc47d2857ff02ef834344938ea44e03c25192a252be3eed6592d6d74973025b4539a991a5bf69332c9ba93c8eed53de8281a95dfdf784a9e00e511fb9a3cdd15b47122127dd31931e8e8bbbaddb89372bc5e4b306dcfd04722d092479b0a749e80e8e0d254b97ba3ee380cf0870ba9dbc42e45ff2e83290d0461cd1a9c24e5fe617a3d641d2c2bb83872293f4cdbae832d7fcc6205db6ccaf56834862e836008a5804dde10fad0ac350dcbf2d99746e28a48ce1c845e438fa1168d29c682daf5ef01b9ee39f2788bbcee789bdfbc03597b2131f2f84b8b473f516066b7ff4b692751d3edc2c20de96e0e765d5b46437d613d1a400e874b637dd2ae5400d869f90d00690dd20f2cc449b5ba9f18e177e9441b9c6a460e6b36db6e41f85f156c3605fc3ce144a24cd3830e3b10bddf153ac5b7876afaefd16344765f92c0e56f278e241108a8cbdfdc904cc9ef3dca6641e6feced4a6d3eafe5a3e4b3e92469809e85ac258abf61832bb32b117197d4e372816e477260cac6b3981946d9627c250a431ddcf0102e7aaf734c5eb18939f62aec9c6e94c55b9ec56eea823f5b6f78ab81a626670d6d35f4a95f966fe21d323ba90f37ce24a9ad2628686a1c5ad0a2a028332e624c4529fc6b2920afb30654e6ea44cc0fb054bfbbe11b092264d3bad410ea3fd92ce9d0073d9926561e7e186c58a9e5680221178e8d2a5b2d9ac7a7a719370ddad97ce80954eb1f81471e10058c2b55d116453269df24528573d48fa3b9e976a37a64fe5935fe5dbd1b091322056681383e232ef1dd3032eadceaa10928b15fe63af1bf52cb04daa16cbaf1c29fa5b430c3b6399ea258585f0c55d4f7fd95c1d6c865e312901947d2983202a1d85534ab9ecfa90281e9341382e2823607bd5c8d953a79954422532b6df50be0cc36d04d22a2ad54ab54c9d30d1d83a4c0ddc3eba445d8327f8a358d6642157a432b00ae6cf5bfcb99cae3478201a49b97c7038626994be878f44b9e0d0a0c7db34fca86ad32aee8d6e65bf165ed64ecd6400386c187282f8e04189e3d41c4afa7db7b370bb2932c6b0968ac39f19898640d0c1a39332a352bf9152cfb82494432b7770dda87e836524b4e00a19f7e099212054a4cca0262f0cfd745e696295793a2173a8e061a573b77f66218f86e563278a4ce0b8be41cda20f2f427a935598a88958299c988d7af31e57f5096d9369ed28ec06162124f73ad0a8c045e0396abc8c27182c614802aa18888789ca1b00bcf0615bfb48bdf981c343e4572a8d7e8a2cece322466f2a34cf6af1960ae7dd0a7785a371e64ced76a4b0ed34147c6421290674d8e6be914fd8282dbaa04d84794848a389328ff1964e0b3efad4f56979074cb44c559bbf51860b5b61eca31e03920cfadf6b72937a641ece25fa13bb4c605f2bba79775366cadd911e820af7e5fe44e7f1019ffca5ab25b784b65cbe1372f48a123fb134188622422bf5c4d0024f79bab867a0acba2b5b16ce12ee9cecce9cd9aa2a8e1c2b45bb30e3623d49b36e53256d35681757cb75c7b4d1cab8e03ef907ecaaabd37fa07b0511158d1c0382e6ea4a927925cf9e763763140400573219168a35c633e8ef10a52e41be4427aa66f5508cd048b4d3aa037524bafa29697384f52aeb76d7f8c5507a91a44cc51f30ef9cd30cbe404b0ce731918866d108d941a4fa4dbe2cf91acd80f1cf772dea45ea2999557f0128196a1bc89696ff7f217478b3e25ead774e0984bca2241fc7a6bd895d2cc67462939799973da005609e2084b015e3cc0455e2711f6929b1d24173dc7fab38d4e9171941adc8ec62017b6127abf9446934bc56823b5df2071e1e9b3d12470aa6d520694ee8474e752906182d0e03160d42186431e6fe0b146f7b48403d968f70fabb7529aacfc2d0b155f795cd1362ad32edabe16b72eb6e44c1f47499c664460a5c2589c2715cc217135b15613f229fb8f666bfb19d54c254f9389dc9bae732f87d0d107980e22cab5f5d3e41301bcb685ae5303cfb220a1e16c6990dda2b1606c0afffd4908d0e2ddabe2c6e2556d20d4b8f75acf70c2ddb5cd335f816affc7ee8d0a86d9102218b5d49fec49ebb5db6d1dd265dfdd97d6c8cccda10678142e5cd82e747cff38bf606dc664c10ffe06802ad6e1b9fcb3a440cb8584da9a849e0fd5c7261d09d0fdef988c1320c08601d75414665137cf7e39825773da83629cd22f545b0a84ba450581409966590684e0d4eacd7217188461390c3c099f8054b17a66e0115f95e76adaf8e9c22aa072dd6f85713af3ceb70965b6f891795edeb0366a596cbfe22e8371ebc2c285c7019e294ae7c5c8aaf08839ce383a7bd50d5b3ee84e34aa573036f87a0b1eb91c922928d84daa737f443ab2602f10806419854b707a853bc6faffdbbb6b8f46f3cb458d7afa046a642703ac69243d2276a9d0133c10bef3aa73e37be2967fcd997f7231f63f3e30336a4d80755562fa70f05bef72da47e9af5b5c8ec35a973fadc8ced5508dc3fdc9d76856495e1ac717c935846d5986cb93b09f65d4d304f8438e094e36bea167edad24fea93b0ddceea0cf0f36ee3269e61aa321194635c4f921dd517b21c7e1056c17b45334619dcd180ce32b3d08b0a140447a20fbf0d7339bc239a13344de8e58e4683e1f9cb4602126f24af88ca5525aefe9d806d02c2a97c02490d3405953ab75977e1b0d4ef3585872cf28ee115597e8a22e6dd166589dead82a056b2f4c72b06e9c34fb021dbc2c1de748df99a88947009927eecff3e20b521d259c6adde845ffe15246db701f4bcf4db277ec6e6a77b2eefdadabcb1f781e510d2566896109b4e5bac6dcd809423102c66a99d7059defd763bfe94ffa54113aace7922e6dfe22777c49714a851ae953a2c16782305f5e4affd1be3d1f67e98ae9ec22e0b8f559323f8e141a6bee3222e9a4d4821f073acd9aff391fbc3d956766047815aab2e8f25956737f0bcdf8ff88ae362afe79853329c9bce4fc6a39bf07be9c2d88d9f83c9cd283d6fb799fc6e8598082969ce0568c3e1f50bc041905aacd37a52e799806e812dce608741697dddb0c2f23d94dec26e2735dd4a9a4ed0db84450ecc71cc8db5e72c69daafc2fcb24064533fbb39f03dc641e114a08631ac203ed517c94e896bff9daeebf3c1ebab2e5c36b32ec199b201a44a3d386d7a7093b5048310d9a0a6e22b9a0aceaa8e85dad3e93447fbb8c2ea22c2e5892f5176d48a983030cf23577ea52bc382d2e095e68423e040b1eb960386cf7e05e4fc7a5602e8c4617fcc7a3817706fae650f34138457350cbbc9d0e06319e594196014b56ebf0ec01e1aaf40cbeadd10c8abf738595566618a2cc9cdabe84c5c59b1cf3fea00ee5557f3b75a7b7bfb48e35d920809ee7282142092e3236c1c95c72a0c227ccf6cd24e42645be0847364949c175df2346731131c17546ebfaa7c8fb40267ccb84ac5f9ad14403a798959d6c85f731cf0cabee6c548a45a888211fd43c9ca964ae897ebd98bfb0bea18f257d5da7cf88a3ac93a0be6f5fa226d76675a1f93a751a944e092aaebb95f99a6168b038e99f21359cd33bb49ff3e49d3f0584b9c378a04951a412eca5f9b6dd1e8ea67ad46625f7b84d83645de4241ebb14da1396afc3407110e493a8f7eb346a3489dfd2badda9973697dad1ff13f35fefc42c9d90106a23183d2773607f20fb82e68a2c4275f5d9fc91efaf37ea5552de1f3be3aa9766655d195337626bdab39732beacc2238de8bbf0e8e69b403ca4830ac9d72435b6e68afa76c166790af3386aec596d1e3af98d44fde597f38d8ae2fc256dc51dd17f1daac123a751f8052e661ed85ddc9eac99c348256f865bbd3f9cf3ff9d47dbb80883ad521d91e5af8ca7af0d816044ed9f7ef2cff1b7114d0b0abb06e8014c51d9b3828d49a2389400431c3587268f0d55a618c03de1b4d472f9a7a7324ae7e55557d839be46fe32fb9113a148e9e6b1ec2160c84724b4fe29ca6332fde6b7260e19cb31e8192c84a21f7b38cb15495498a29f15fcedd0b43b8dc50b4859fbd35dad08a4a42d4158180d708daf4d6de7034808c48e621af1117573fc84f47277b4d4bac66b18936e248c09c8511558b3da8e4304735c2b04a9768b28d901e897908bb695624d327fbc62512587c84ef25bc22d2c544c46af2f7b960079ed02ef333d0256ec1b8c0c190fd4fe5885eda98164e9f1b52ac99e3f856628ace6d099942462343dd04659711516860e90c022644fa94cd9f235cc1edf13313b4bafaccadd7e6cd0332aeb55885edbfe54ff737112af110e2cbd2781858e411e022e2cac1fea91ed1db4136e3ac2bbaf87ee7cbded334626dac9cc1e598eff9c6be004575098cd46e1a3cc9550368fa9ef0d72da95deb8fb3f3bfd7a0cbc938fcf6a847212564a3af9900d3b9f11be0f10b499e44edea9abee7e364fd2a84c2920a370f372e4a84b9b9efbc683fa146011eb8085095a8b67f81195facb522999ba3b162d79afd2410c90e973fa6e2ebdf753f5f5c93d00081474e7ccc01e34e7d6a5a4672e1c11cba75e90a4069c66c9cb314e5616a4af0c81f46bfb4625c66c0fa8ca1672ca84665b5d1433b3adab3a1044672008ec3f21bd633735b4c59dbb43c60af497476f0ff4fd0d752e68663e253bc78eb869279c4bd17b735550fdb847715131a1ad58f2779d73e4977d90010e8d38944aa79841878aeb124a8933bb7e92637df406dcd5874a3d9b65cfcbffca9c891cef0ef90ee43bb2ea510edd9f1fce535ecdbf22066c851aaf4acfee3dee0eb76ea88bc3064ba45971c802a255115c51531b85654a4f59ae98b018d71906a84129b21c2f57f9c5fd8f5b412f0c85c4353177e010292ee15fb7a701a30433f810d4b59b5e2109a38057823468bac7ca78d117e748540d8762bcf47ad82b54fde488a100e156092546b397a67d72612fc9b73e70de158bf63235bb24e7df3fe2e93d1bcd5f5383c56a4ddac12b3f762c5f5fd457b784728a730ffd045c0fb9436916ef21e8291d38027713aa79daf2502f86bcee44c7e7e9c902ab3a2bde8cf3a40fbe5be7df625330aa8c83bf6ab513cbb41c5b9521e7575fbf8484251dd517900fac70a5707ca94eab62587c1c03e87e58ab5a6b83ae2c495c57a67e5835e3d839e33ede290aebd2dbb264e84659bf9ddeeea0bb383ba9431824a51b3e749137bf9bfce98c8cc806e6a22b0e6e713f043239121e384ba979dfa4590585513d63723c254985ee66e38a72ca14658f6f2800386d34fff900e7cb904129568ca3e706610c782ca5818d856f56f7246fc591e5a7c8c4d405b5ae6bc32cf664c6166b66a866b38a040d9bf457f0fe33c2e55be7310e10fc556da04b7efa2470de34d5ff0322bc1ec636fcc3d7423e16764b8ce00eaaf3e7834d4b158790ca0bfea7694aaa0cd1fe7260ca06a5fee76b75c8b3a27a75fb30de4a77883bea0b42e6bfef5c06dd01deb9cf6dd1c05b8d8ed8c7a758e450c4f87a350546e4a86950bd19b47604fbaa855e43b76f9c871cf43b374505c77891f3194bd23bb8d1153b51cd8bce9517a19c70ff4f0d0e602b368f903f9a03555572a5d69f8150d4bd03015643c0a524172a0fce142470693ffacf9710f6175d5a15caedce4958e968ac60a8ce7f2943d1c1cf25c33414bf0d96eaf8ad3c13721eb40e049fd809b3fed50f95cf6b70a5037cefd2837b7468c5fea01ce2c88dd6cd0925c863c76bd7bf4f0a8b9a50b05559f395b5f84c5b84a9dccbf20333583fd6173588b290833b9489702af1ed9ee94cfb32595873dd8d43dfaefcd1be1e6af194739672b14e427ecc9f33e97966bf7dbff83f925a78c2dd1b0db8d782281b656963b4323c822cb11c2fbecfbcbc83c0310c87f3a83fdbddd5bdee0f6806669013f5e3de19ae92142d8328c95846e89b0088ca23ec9613e4742bf135f5843fd978df9cde78f81bf3adb3f3cad8ae8d5e716d01b841aaedea0f5e637f7f0cdc9d18fde45a2200838df46e5f112dd7832f29f1e2bc1ac9208292ce652a7eabcf635af82aa3138fa80a37c747ef9545eb8dc632af0709ec210de6de3823ce33a95bd618d979815e648f94693daf34f39994bbefd4adb47a8506073fa39de1b85a95c5aeb5c267262c44c99a13ab90c6fe8ddf37c5fe00da378cddff8092baabe76e769e3169c4679c81af44a83b24829918e6737ec20d1db3bd1d82f955df7096c85d7464cc0041fa63c6caddb41d69b28639224261293e29a2795dea81b64417a172e8665a006eb990484c801e001a833750832b533d2de68a6aabc56e6098ab6646506a60410614c351cda02ac121061f23fbf1b3230bdab4654021f191d338f068aeb43e6fa46a389e788f830040d2749b197f32b9082fab36a07351e1b9bc864051987cab83c2eeb3206f336bd04c9076bc6b780cd675346631f6f3fc540bb365d54cdf049a01fbe1d70177a659d4d969d35fe8f3de67afa8daa3d88664fa7c66bc46dfcdfc94e1d4a20eaa854ae0c4880eccae50d3438f972c749db1722248f5f435c2989942073d3ca15d92dd3a9c4510a9bcc74969817f8420492b145ccbe4812b6be01b43178bae502840401354e62059a5194fd3d0bf86961243a0dddef2f2558feb0d77cf5a38829248d1de47a3b1e003f527efcce0341384dafac0e18f0adcd6971b1fb7411e21603f071b3b172ff4f2d05685ca89f58c83715615143094e6575c5108cba4a1b61ae630675e64bc4968723ca27ea09944bc9f489b700e6b841d0d06bc33e7dc39058a7e4997580086913913afaa301e11920038de95d5d7771425384bfb620d9f485d0c7a73d8f28b9be861fe1d13d30b52c976be20b573c6a0a585e4346f072bd5376c12341551538a0b93cf58aa2e682dfed11090960a525e42b69bf2f5a4000a55919da69202dc3fda99538f3bdaa51d257d5912de94fdf959469a0d271fd851e39cd32605a00369c27137beeb1ae08d5097241838a52969069dc92a6c0621c245ab4662f18421e76dd68329732f2abf8180d9e13fefb4cb918b056ffcec0dfa715213542e242449b28e2f929ca53276870a39e8a7b5270472a3c1939f80b03d321233618f327b4b5767c34ceac460183cda9525f7951f2b28433de0d60c55e02d4f995d79b8a58ee15befe65697f243039ddd23ce87a1364cb53d5f7f60c106a1160e430e97bc3e21a30e4f643d1989a34bd904418f87461647dd3ba7e10841285d8bffd4986bbbc1647b6e11e35a7e365a442630d491a2f2a2a6c6ef70fbef3201bab5c0f3715b03bc55ee27c1ebb13e0ab294a8ee66f22aa7a711f77a2c36d95626198b7aea6637b5c6b6e58ad74e844c7ea02af6662ec02cd7967435d96219d859983879d3c324ab71013f7571338bd58858e9e3cdb35219a3adb67847f0b714f07467ed9414c3f821a511ab9111bab94e808038435e338a9456267577f4ccfd62857fc7bd18c422dae1d84ca43970907e34f335a76d13e0f993fac662c6a590e2ecddc1c6f2c2ba71fb7568e44f4aa33a2f88a00c2b52b5241b9419b4acb7ce131ca711dafcc45e99c49955a120bdaddcc898fb5185d8646e13427bcb8ef6c822a1cc080e7a0bbbc3b7f154bd2b0a967d2caa9adb099fccc5c42d09d545929e5d8a84ea68805a9c55a20ba5882a531c5baf495d098691e70dfb4f590557686f2257e85e5cae3f5c3951b0591883f5688e67698c5e2d067cce89c90a2a7ed15fba966d82a5d595021a0bb548a88e03d8f70e39a5489dc186d25a5142fbf4aa7ddad6b4df5c1a5d66f4b19ec9805bb9616de5d20696136e512380c7208437196cfc05d88328fc105b3f322551dee0044042813cea6b98780b73748827cc16d80b97dd597d106ff2d4f3464d4855ecdd300d5f0cf64a64a26b937fd17afb7fac684f4b4fba033b796a8f8d683101168e12451394dad8d3bacdeebe85b082d12e4c79196e07417b4fa570b5d8f60d3d839dcc1197a91555c02282c1d119bdd073c8d1a99e1d75b46d06bb4b8994bf404bec432569e14655476b782769b9a921886340006040270766594ad111cdb9e46c43ae9cd129b084d7179ae8168ac8d3bee06fb76b84583abfcc1138214605c72faa242bbddda2ed8de15497a4e3b065928156e8e881b070da38468092b4394344ac248272dbbb33a2396c1240e1c8ea00430d86ed8387f6cd0b77ecf287b1f4477e4545fc2913d262ea8d5953267b31350f325adde5edabceafe78af70dcad3dc2da0430e5feb96e2289ec9d5001c4d7fbf820d85d09d1481aec27e85d192854a39a9c7404f9b8904d5be50c56e3d41233f887256397ab7da65b753a46dddcd60308d3e44e972f11786cd4a116378377d6875916033851bd2dc7bb4571c62aab4bf607b0655970b4b706dc8b1870ca2affca462882628891cba300db763d81f08b271b2fd4dc6c99f634a0e24472f2d4a20b7afc6205d750eda7216b4fdc598a845224d5ee3b0a8c9e6b3179cf4cc9cf12a3d4eb62081f9b3556a5aabf9cf33f86c7e6b9afcc92e0c86c3669629dceb5884253ea3eb90228546ce367a547d98bf4aa5f856b185e097959cdb04f2f07499f7798bc7be7515385d2f2e97dea69a781e10c0e2b1ee1b26c7e7bf63b184bb710696995451b192f3f3e6afb68435752565bd920a93c648fb78afeeba625dce83592395b440da4eb6946370507c12060ed42821cd214963cf753bca0a6a2f6e0c6302c28ef7f96d764c4d17f87e04f1dd3a8cfe1f8bb4f8613da6bd04b76cc49fd3</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 私密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反思 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 感情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github插件推荐</title>
      <link href="2019/08/04/Github%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
      <url>2019/08/04/Github%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo博客插件"><a href="#hexo博客插件" class="headerlink" title="hexo博客插件"></a>hexo博客插件</h2><ul><li><a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md">hexo-blog-encrypt</a>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">尝试着想一下，你写了一篇博客，但是，出于某种原因，不太希望每一个人都可以看到他。所以你常常会为这种文章设置一个密码，其他人需要输入密码才可以访问这篇博客。对于 emlog 或者 wordpress 来说，这很容易，但是对于 hexo 来说，之前并没有一个类似的功能。所以，Hexo-Blog-Encrypt 因为这个需求而诞生了。<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 资源整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最后一次对话</title>
      <link href="2019/08/04/%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AF%B9%E8%AF%9D/"/>
      <url>2019/08/04/%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AF%B9%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="82345101830e33620e07253700a9a9d41071ffd26463a55ff4216463876ab3ad">42fdbcd89563ce618169a95c5bdb398893db78e214413b808f1a555fd2c56a642191ea20472b5bfc3492c0281ebff3804c8ca7e576e0997494b2898a8f1a27cb18d727e76d40d0eefe1ea7e69983ee00660ec92d237783519cbfdd1d9143138a9042c501c28efd701b0409b31e9acc639cec2a8be94df81a8915cf91a38ae36e68d3e730f702cccf41048a10431befe8f7c525f11ede88110f86c758b3fb49f48aee68f6a4bbc3d7e5b84d1cce9845a87ca430efd521be3719cb10e84bc735103ea92d59e6ff1b44bf6339ebf4726eb265300d1913f8eae3ac14221188e09607c714b493b284c0d84700f584b4fc7ad54e6e0bb48267d6df6a1815102c3ab6a4526c62233e2ab0b10b53c18e860c60ca2627b03b503137304522dc647b8519d3d7d79a2e4000ffbb3df1d3b5aed72beb4303700e7851f6791ec4084a280d8b9924c5967bebe807e5a23230f6ded3f9e51df62e7fc9c1d18ec6b9e99d4b1fc3deb1c240b07b2ad55eac0539600014467cd862572ea7f3a2f75f715e40248a3c9fc9aba1d274b9c79fbd004857e1a00efb</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 私密 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown文字样式设置</title>
      <link href="2019/08/04/Markdown%E6%96%87%E5%AD%97%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE/"/>
      <url>2019/08/04/Markdown%E6%96%87%E5%AD%97%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="修改markdown的字体、大小、颜色"><a href="#修改markdown的字体、大小、颜色" class="headerlink" title="修改markdown的字体、大小、颜色"></a>修改markdown的字体、大小、颜色</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;黑体&quot;</span>&gt;</span></span>我是黑体字<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;微软雅黑&quot;</span>&gt;</span></span>我是微软雅黑<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;STCAIYUN&quot;</span>&gt;</span></span>我是华文彩云<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">red</span>&gt;</span></span>我是红色<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">#008000</span>&gt;</span></span>我是绿色<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">Blue</span>&gt;</span></span>我是蓝色<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">size</span>=<span class="hljs-string">5</span>&gt;</span></span>我是尺寸<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;黑体&quot;</span> <span class="hljs-attr">color</span>=<span class="hljs-string">green</span> <span class="hljs-attr">size</span>=<span class="hljs-string">5</span>&gt;</span></span>我是黑体，绿色，尺寸为5<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>效果如下</p><ul><li><font face="黑体">我是黑体字</font></li><li><font face="微软雅黑">我是微软雅黑</font></li><li><font face="STCAIYUN">我是华文彩云</font></li><li><font color=red>我是红色</font></li><li><font color=#008000>我是绿色</font></li><li><font color=Blue>我是蓝色</font></li><li><font size=5>我是尺寸</font></li><li><font face="黑体" color=green size=5>我是黑体，绿色，尺寸为5</font><h2 id="为文字添加背景色"><a href="#为文字添加背景色" class="headerlink" title="为文字添加背景色"></a>为文字添加背景色</h2>由于 style 标签和标签的 style 属性不被支持，所以这里只能是借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色。故这里对于文字背景色的设置，只是将那一整行看作一个表格，更改了那个格子的背景色（bgcolor）<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">yellow</span>&gt;</span></span>背景色yellow<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br></code></pre></td></tr></table></figure><table><tr><td bgcolor=yellow>背景色yellow</td></tr></table></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>论文--中文版编写</title>
      <link href="2019/08/04/%E8%AE%BA%E6%96%87-%E4%B8%AD%E6%96%87%E7%89%88%E7%BC%96%E5%86%99/"/>
      <url>2019/08/04/%E8%AE%BA%E6%96%87-%E4%B8%AD%E6%96%87%E7%89%88%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h2 id="22Al的β衰变谱"><a href="#22Al的β衰变谱" class="headerlink" title="22Al的β衰变谱"></a>22Al的β衰变谱</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>我们在兰州RIBLL1上开展了一个Al22衰变实验，主束为28Si. 半衰期91ms被测定。βp，β2p，βα，βγ的测定使得我们得以更新能级纲图。通过Geant4的模拟，我们进一步精确测定分支比，并对部分质子峰结构特征得以解释。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在过去几十年里，原理稳定线的奇异核一直是核物理领域经久不衰的研究热点。原子核的诸多性质诸如同位旋、能级宽度等一系列物理量随着原子核向远离稳定线延申，产生了诸多奇异的效应。通过这些特性有助于我们深入研究原子核的结构信息和衰变机制。而在其中，通过β衰变谱来开展研究工作成为了滴线附近原子核结构信息和检验并完善壳模型理论的强有力的工具。<br>奇异核22Al是Al同位素中最缺中子的一个核素，有13个质子，9个中子，Tz为-2，结合能只有20keV. 1982年第一次被Cable观测到。在他的实验中，22Al通过24Mg(3He,p4n)的反应生成(110MeV)。Al原子通过He-jet技术被输运。在衰变谱中，仅仅高能区的两个峰(8212,8537keV)能够被观测到，低能区的部分由于其他核的污染，无法进行观测。 这两个峰被指认为从IAS态到Na21的基态和激发态。IAS态的激发能为13650keV。测定的半衰期为70ms。 由于实验条件的限制，没有确定绝对的分支比。随后，Cable在另一个实验中观测到了β2p衰变事件。在那个实验中，他观测到了两条beta2p衰变分支。基于能量的考虑，这两条分支归到Na20的基态和第一激发态。在最近的实验中，Blank测到了betaalpha衰变，通过将Al22注入到鬼探测器和气体探测器。测得的T1/2为59ms。精确的能级纲图以及实验分支比被测得。然而这个实验也受到了污染，在Ar36生成的次级束中，仅有30%的是Al22核素。那篇文章中还进行了壳模型计算。<br>尽管Al22这个核已经被研究了很久，但依旧有一些不确定和局限。 由于较强的污染，部分月前丢失或者被污染物中更强的分支掩盖。此外，先前的实验中也没有观测到γ射线。实验的目的是提高beta衰变的测量，通过不同的方式：更纯的22Al次级束，更高的统计，带电粒子测量更好的能量分辨，gamma探测器来辅助指认跃迁。</p><h3 id="实验技术"><a href="#实验技术" class="headerlink" title="实验技术"></a>实验技术</h3><p>实验于2017年11月在兰州RIBLL1上开展。主束为74.27MeV/u，80enA的28Si14+，通过K69 Sector Focus Cyclotron和K450 Separate Sector Cyclotron 。次级束通过将28Si打到1581um厚的Be9靶上。RIBLL1的主要设置为筛选Al22做了优化。Al22的束流强度和纯度分别为（）和（）。次级束粒子通过ΔE和TOF来筛选想要的粒子。通过位于T1、T2的闪烁薄膜探测器给出的飞行时间（TOF）结合位于T2的QSDΔE1和QSDΔE2给出的能损信号（ΔE）可以建立ΔE–TOF图谱鉴别束流粒子，双重ΔE探测器的能量和时间信号都可以用于进一步提高对束流重离子的鉴别能力。本实验研究的核为Na20，Mg21，Al22，Si23.<br><img src="https://i.loli.net/2019/08/04/FOLX5uAalzvMxPw.png"><br>探测器阵列主要由三块双面硅条探测器（DSSD）、五块四分硅探测器（QSD）及外部五个Clover型的高纯锗探测器组成。经过上游铝降能片降能后的束流具有一定能散，目标核的射程分布在三块DSSD，即DSSD做停阻束流中目标核的注入探测器，并对注入核的衰变带电粒子进行测量，硅探测器对从内部发射的带电粒子具有极高的探测效率。每个DSSD x–y像素格都可视为独立探测器，这样在连续束、高束流注入率的条件下各单个像素格内仍能保持较低注入率，衰变事件和注入事件的时间关联仍然可以建立。三块DSSD的厚度分别为142um，40um，304um。Al22主要分布在后两块Si，QSD1用于探测DSSD中感兴趣核衰变产生的β粒子，QSD2和QSD3位于束流最下游，用于测量束流中的轻粒子（1H、2H、3H、4He等），反符合去掉穿透DSSD的轻粒子在DSSD中的能损信号。DSSD被五个clover环绕，下侧有三个LaBr3探测器，用来测量γ射线。</p><h3 id="分析及结果"><a href="#分析及结果" class="headerlink" title="分析及结果"></a>分析及结果</h3><h4 id="能量刻度及注入深度分布"><a href="#能量刻度及注入深度分布" class="headerlink" title="能量刻度及注入深度分布"></a>能量刻度及注入深度分布</h4><p>重离子能量刻度通过将实验中任意两块DSSD组成的望远镜谱与LISE计算的望远镜谱做对照，调整刻度参数，使实验谱的中心与计算的de-E线基本重合；随后通过应用LISE计算得到的能量射程拟合函数计算注入重离子的注入深度。<br><img src="https://i.loli.net/2019/08/04/BeTNhFSp6qtcxYv.png"><br>质子能量刻度应用文献中给出的质子峰数据。采用了※，※，※，※，※几个峰参与能量刻度。（考虑了弹道亏损效应。）和（β叠加效应）。</p><h4 id="质子探测效率模拟"><a href="#质子探测效率模拟" class="headerlink" title="质子探测效率模拟"></a>质子探测效率模拟</h4><p>我们采用了Geant4工具包来模拟计算质子探测效率。质子的注入深度以及x-y平面分布采用了实验数据，在Si内各向同性发射。我们每隔0.5MeV的能量发射100000个质子，绘制了E-Eff曲线。<br><img src="https://i.loli.net/2019/08/07/HloGSqhK7sBWP6a.png"><br>其中蓝线为40umSi的探测效率曲线，橙线为304umSi的探测效率曲线。</p><h4 id="质子谱"><a href="#质子谱" class="headerlink" title="质子谱"></a>质子谱</h4><p><img src="https://raw.githubusercontent.com/mission-young/Pic/master//img/20190901152447.png"><br>这是最后一块Si的质子谱，其中蓝线未加入veto条件限制，而红线加入了veto条件限制。<br><img src="https://raw.githubusercontent.com/mission-young/Pic/master//img/20190901153304.png"><br>这是中间一块Si的质子谱。</p><h4 id="Geant4模拟质子谱"><a href="#Geant4模拟质子谱" class="headerlink" title="Geant4模拟质子谱"></a>Geant4模拟质子谱</h4><p>随后，我们应用EPJA2006文章中给出的质子能量分支比数据作为Geant4模拟输入，来研究β叠加效应。<br><img src="https://i.loli.net/2019/08/05/WMw75niR9zBVlpH.png"><br>上图中实线为实验谱，虚线为经过归一之后的模拟谱。其中实验谱和模拟谱均未设置veto条件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假家教记录</title>
      <link href="2019/08/03/%E6%9A%91%E5%81%87%E5%AE%B6%E6%95%99%E8%AE%B0%E5%BD%95/"/>
      <url>2019/08/03/%E6%9A%91%E5%81%87%E5%AE%B6%E6%95%99%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">日期</th><th align="center">起始时间</th><th align="center">结束时间</th><th align="center">时长</th><th align="center">科目</th></tr></thead><tbody><tr><td align="center">2019-08-03</td><td align="center">15:00</td><td align="center">17:30</td><td align="center">2.5</td><td align="center">概率统计</td></tr><tr><td align="center">2019-08-04</td><td align="center">15:00</td><td align="center">17:30</td><td align="center">2.5</td><td align="center">概率统计</td></tr><tr><td align="center">2019-08-05</td><td align="center">15:00</td><td align="center">17:30</td><td align="center">2.5</td><td align="center">概率统计</td></tr><tr><td align="center">2019-08-06</td><td align="center">14:30</td><td align="center">17:30</td><td align="center">3</td><td align="center">概率统计</td></tr><tr><td align="center">2019-08-07</td><td align="center">15:00</td><td align="center">17:30</td><td align="center">2.5</td><td align="center">线性代数</td></tr><tr><td align="center">2019-08-08</td><td align="center">9:30</td><td align="center">12:30</td><td align="center">3</td><td align="center">线性代数</td></tr><tr><td align="center">2019-08-09</td><td align="center">9:30</td><td align="center">12:00</td><td align="center">2.5</td><td align="center">线性代数</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub管理Hexo源文件</title>
      <link href="2019/08/03/GitHub%E7%AE%A1%E7%90%86Hexo%E6%BA%90%E6%96%87%E4%BB%B6/"/>
      <url>2019/08/03/GitHub%E7%AE%A1%E7%90%86Hexo%E6%BA%90%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>hexo发布网站到Github之后，可以直接通过访问Git个人主页。但<code>hexo d</code>部署的方式并不包含博客的源码，对于博客的迁移、更新、维护、多终端编辑并不友好。<br>在网上看到诸多同时管理hexo博客源文件和发布版本的教程，看似很优雅，但分支的切换、管理比较繁琐，同时一个严重的问题是，源代码的权限想要设为私有，而发布版本为公有。因而决定重新建立一个repo来管理源代码项目。</p><a id="more"></a><p>在Github新疆项目Hexo，权限设置为私有。在Hexo目录输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">git init <br>git add .<br>git commit -m &quot;add&quot;<br>git remote add origin git@github.com:mission-young&#x2F;Hexo.git<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>查看Hexo目录下<code>.gitignore</code>文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs git">.DS_Store<br>Thumbs.db<br>db.json<br>*.log<br>node_modules&#x2F;<br>public&#x2F;<br>.deploy*&#x2F;<br></code></pre></td></tr></table></figure><p>已经自动忽略public目录。由此实现：源代码私有，部署至Hexo项目；发布网站共有，部署至mission-young.github.io。<br>同时编辑部署脚本<code>hexo-publish.sh</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env sh</span><br><span class="hljs-comment"># hexo clean</span><br>hexo g<br>hexo d<br>git add .<br>git commit -m <span class="hljs-string">&quot;update&quot;</span><br>git push  <br></code></pre></td></tr></table></figure><p>从而实现一键同步Hexo项目并发布。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用Hexo搭建Github个人博客</title>
      <link href="2019/08/02/hello-world/"/>
      <url>2019/08/02/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="搭建Hexo环境"><a href="#搭建Hexo环境" class="headerlink" title="搭建Hexo环境"></a>搭建Hexo环境</h2><p>访问Hexo主页</p><iframe src="https://hexo.io/zh-cn/" width="100%" Height="800">   </iframe><a id="more"></a>执行上述页面命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g<br>hexo init blog<br><span class="hljs-built_in">cd</span> blog<br>npm install<br>hexo server<br></code></pre></td></tr></table></figure>即可完成hexo的安装。### 安装插件：<iframe src="https://jaredforsyth.com/hexo-admin/" width="100%" Height="800">   </iframe>执行页面命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-admin<br></code></pre></td></tr></table></figure>进入[设置界面](http://localhost:4000/admin/#/settings)：![upload successful](/images/pasted-1.png)勾选显示行号以及拼写检查。随后在blog根目录添加脚本`hexo-publish.sh`：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env sh</span><br><span class="hljs-comment"># hexo clean</span><br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure>随后执行`chmod +x hexo-publish.sh`，之后在`_config.yml`中添加<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">admin:</span><br>  <span class="hljs-attr">deployCommand:</span> <span class="hljs-string">&#x27;./hexo-publish.sh&#x27;</span><br></code></pre></td></tr></table></figure>修改`_config.yml`配置<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:mission-young/mission-young.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure>至此，即可完成hexo的在线编辑及部署Github。### 配置主题本博客采用了[ARIA主题](https://github.com/AlynxZhou/hexo-theme-aria/blob/master/README.zh_CN.md)。按照该作者Github配置完成主题配置选项。]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之博弈问题</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>title: 动态规划之博弈问题<br>author: 远方<br>tags:</p><ul><li>LeetCode</li><li>算法<br>categories:</li><li>LeetCode破局攻略<br>date: 2016-01-01 19:20:00</li></ul><hr><h1 id="动态规划之博弈问题"><a href="#动态规划之博弈问题" class="headerlink" title="动态规划之博弈问题"></a>动态规划之博弈问题</h1><p>上一篇文章 <a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E7%9A%84%E6%99%BA%E5%8A%9B%E9%A2%98">几道智力题</a> 中讨论到一个有趣的「石头游戏」，通过题目的限制条件，这个游戏是先手必胜的。但是智力题终究是智力题，真正的算法问题肯定不会是投机取巧能搞定的。所以，本文就借石头游戏来讲讲「假设两个人都足够聪明，最后谁会获胜」这一类问题该如何用动态规划算法解决。<br>博弈类问题的套路都差不多，下文举例讲解，其核心思路是在二维 dp 的基础上使用元组分别存储两个人的博弈结果。掌握了这个技巧以后，别人再问你什么俩海盗分宝石，俩人拿硬币的问题，你就告诉别人：我懒得想，直接给你写个算法算一下得了。<br>我们「石头游戏」改的更具有一般性：<br>你和你的朋友面前有一排石头堆，用一个数组 piles 表示，piles[i] 表示第 i 堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。<br>石头的堆数可以是任意正整数，石头的总数也可以是任意正整数，这样就能打破先手必胜的局面了。比如有三堆石头 <code>piles = [1, 100, 3]</code>，先手不管拿 1 还是 3，能够决定胜负的 100 都会被后手拿走，后手会获胜。<br><strong>假设两人都很聪明</strong>，请你设计一个算法，返回先手和后手的最后得分（石头总数）之差。比如上面那个例子，先手能获得 4 分，后手会获得 100 分，你的算法应该返回 -96。<br>这样推广之后，这个问题算是一道 Hard 的动态规划问题了。<strong>博弈问题的难点在于，两个人要轮流进行选择，而且都贼精明，应该如何编程表示这个过程呢？</strong><br>还是强调多次的套路，首先明确 dp 数组的含义，然后和股票买卖系列问题类似，只要找到「状态」和「选择」，一切就水到渠成了。</p><h3 id="一、定义-dp-数组的含义"><a href="#一、定义-dp-数组的含义" class="headerlink" title="一、定义 dp 数组的含义"></a>一、定义 dp 数组的含义</h3><p>定义 dp 数组的含义是很有技术含量的，同一问题可能有多种定义方法，不同的定义会引出不同的状态转移方程，不过只要逻辑没有问题，最终都能得到相同的答案。<br>我建议不要迷恋那些看起来很牛逼，代码很短小的奇技淫巧，最好是稳一点，采取可解释性最好，最容易推广的设计思路。本文就给出一种博弈问题的通用设计框架。<br>介绍 dp 数组的含义之前，我们先看一下 dp 数组最终的样子：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/1.png" alt="1"><br>下文讲解时，认为元组是包含 first 和 second 属性的一个类，而且为了节省篇幅，将这两个属性简写为 fir 和 sec。比如按上图的数据，我们说 <code>dp[1][3].fir = 10</code>，<code>dp[0][1].sec = 3</code>。<br>先回答几个读者可能提出的问题：<br>这个二维 dp table 中存储的是元组，怎么编程表示呢？这个 dp table 有一半根本没用上，怎么优化？很简单，都不要管，先把解题的思路想明白了再谈也不迟。<br><strong>以下是对 dp 数组含义的解释：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[i][j].fir 表示，对于 piles[i...j] 这部分石头堆，先手能获得的最高分数。<br>dp[i][j].sec 表示，对于 piles[i...j] 这部分石头堆，后手能获得的最高分数。<br>举例理解一下，假设 piles = [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]，索引从 <span class="hljs-number">0</span> 开始<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>].fir = <span class="hljs-number">9</span> 意味着：面对石头堆 [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>]，先手最终能够获得 <span class="hljs-number">9</span> 分。<br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>].sec = <span class="hljs-number">2</span> 意味着：面对石头堆 [<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]，后手最终能够获得 <span class="hljs-number">2</span> 分。<br></code></pre></td></tr></table></figure><p>我们想求的答案是先手和后手最终分数之差，按照这个定义也就是 $dp[0][n-1].fir - dp[0][n-1].sec$，即面对整个 piles，先手的最优得分和后手的最优得分之差。</p><h3 id="二、状态转移方程"><a href="#二、状态转移方程" class="headerlink" title="二、状态转移方程"></a>二、状态转移方程</h3><p>写状态转移方程很简单，首先要找到所有「状态」和每个状态可以做的「选择」，然后择优。<br>根据前面对 dp 数组的定义，<strong>状态显然有三个：开始的索引 i，结束的索引 j，当前轮到的人。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[i][j][fir <span class="hljs-keyword">or</span> sec]<br>其中：<br><span class="hljs-number">0</span> &lt;= i &lt; piles.length<br>i &lt;= j &lt; piles.length<br></code></pre></td></tr></table></figure><p>对于这个问题的每个状态，可以做的<strong>选择有两个：选择最左边的那堆石头，或者选择最右边的那堆石头。</strong> 我们可以这样穷举所有状态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">n = piles.length<br><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt;= i &lt; n:<br>    <span class="hljs-keyword">for</span> j &lt;= i &lt; n:<br>        <span class="hljs-keyword">for</span> who <span class="hljs-keyword">in</span> &#123;fir, sec&#125;:<br>            dp[i][j][who] = max(left, right)<br></code></pre></td></tr></table></figure><p>上面的伪码是动态规划的一个大致的框架，股票系列问题中也有类似的伪码。这道题的难点在于，两人是交替进行选择的，也就是说先手的选择会对后手有影响，这怎么表达出来呢？<br>根据我们对 dp 数组的定义，很容易解决这个难点，<strong>写出状态转移方程：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[i][j].fir = max(piles[i] + dp[i+<span class="hljs-number">1</span>][j].sec, piles[j] + dp[i][j<span class="hljs-number">-1</span>].sec)<br>dp[i][j].fir = max(    选择最左边的石头堆     ,     选择最右边的石头堆     )<br><span class="hljs-comment"># 解释：我作为先手，面对 piles[i...j] 时，有两种选择：</span><br><span class="hljs-comment"># 要么我选择最左边的那一堆石头，然后面对 piles[i+1...j]</span><br><span class="hljs-comment"># 但是此时轮到对方，相当于我变成了后手；</span><br><span class="hljs-comment"># 要么我选择最右边的那一堆石头，然后面对 piles[i...j-1]</span><br><span class="hljs-comment"># 但是此时轮到对方，相当于我变成了后手。</span><br><span class="hljs-keyword">if</span> 先手选择左边:<br>    dp[i][j].sec = dp[i+<span class="hljs-number">1</span>][j].fir<br><span class="hljs-keyword">if</span> 先手选择右边:<br>    dp[i][j].sec = dp[i][j<span class="hljs-number">-1</span>].fir<br><span class="hljs-comment"># 解释：我作为后手，要等先手先选择，有两种情况：</span><br><span class="hljs-comment"># 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j]</span><br><span class="hljs-comment"># 此时轮到我，我变成了先手；</span><br><span class="hljs-comment"># 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1]</span><br><span class="hljs-comment"># 此时轮到我，我变成了先手。</span><br></code></pre></td></tr></table></figure><p>根据 dp 数组的定义，我们也可以找出 <strong>base case</strong>，也就是最简单的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[i][j].fir = piles[i]<br>dp[i][j].sec = <span class="hljs-number">0</span><br>其中 <span class="hljs-number">0</span> &lt;= i == j &lt; n<br><span class="hljs-comment"># 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]</span><br><span class="hljs-comment"># 那么显然先手的得分为 piles[i]</span><br><span class="hljs-comment"># 后手没有石头拿了，得分为 0</span><br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/2.png" alt="2"><br>这里需要注意一点，我们发现 base case 是斜着的，而且我们推算 dp[i][j] 时需要用到 dp[i+1][j] 和 dp[i][j-1]：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/3.png" alt="3"><br>所以说算法不能简单的一行一行遍历 dp 数组，<strong>而要斜着遍历数组：</strong><br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/4.png" alt="4"><br>说实话，斜着遍历二维数组说起来容易，你还真不一定能想出来怎么实现，不信你思考一下？这么巧妙的状态转移方程都列出来了，要是不会写代码实现，那真的很尴尬了。</p><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><p>如何实现这个 fir 和 sec 元组呢，你可以用 python，自带元组类型；或者使用 C++ 的 pair 容器；或者用一个三维数组 <code>dp[n][n][2]</code>，最后一个维度就相当于元组；或者我们自己写一个 Pair 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> fir, sec;<br>    Pair(<span class="hljs-keyword">int</span> fir, <span class="hljs-keyword">int</span> sec) &#123;<br>        <span class="hljs-keyword">this</span>.fir = fir;<br>        <span class="hljs-keyword">this</span>.sec = sec;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后直接把我们的状态转移方程翻译成代码即可，可以注意一下斜着遍历数组的技巧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 返回游戏最后先手和后手的得分之差 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stoneGame</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] piles)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = piles.length;<br>    <span class="hljs-comment">// 初始化 dp 数组</span><br>    Pair[][] dp = <span class="hljs-keyword">new</span> Pair[n][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; n; j++)<br>            dp[i][j] = <span class="hljs-keyword">new</span> Pair(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 填入 base case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        dp[i][i].fir = piles[i];<br>        dp[i][i].sec = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 斜着遍历数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>; l &lt;= n; l++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n - l; i++) &#123;<br>            <span class="hljs-keyword">int</span> j = l + i - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 先手选择最左边或最右边的分数</span><br>            <span class="hljs-keyword">int</span> left = piles[i] + dp[i+<span class="hljs-number">1</span>][j].sec;<br>            <span class="hljs-keyword">int</span> right = piles[j] + dp[i][j-<span class="hljs-number">1</span>].sec;<br>            <span class="hljs-comment">// 套用状态转移方程</span><br>            <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>                dp[i][j].fir = left;<br>                dp[i][j].sec = dp[i+<span class="hljs-number">1</span>][j].fir;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j].fir = right;<br>                dp[i][j].sec = dp[i][j-<span class="hljs-number">1</span>].fir;<br>            &#125;<br>        &#125;<br>    &#125;<br>    Pair res = dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> res.fir - res.sec;<br>&#125;<br></code></pre></td></tr></table></figure><p>动态规划解法，如果没有状态转移方程指导，绝对是一头雾水，但是根据前面的详细解释，读者应该可以清晰理解这一大段代码的含义。<br>而且，注意到计算 <code>dp[i][j]</code> 只依赖其左边和下边的元素，所以说肯定有优化空间，转换成一维 dp，想象一下把二维平面压扁，也就是投影到一维。但是，一维 dp 比较复杂，可解释性很差，大家就不必浪费这个时间去理解了。</p><h3 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a>四、最后总结</h3><p>本文给出了解决博弈问题的动态规划解法。博弈问题的前提一般都是在两个聪明人之间进行，编程描述这种游戏的一般方法是二维 dp 数组，数组中通过元组分别表示两人的最优决策。<br>之所以这样设计，是因为先手在做出选择之后，就成了后手，后手在对方做完选择后，就变成了先手。这种角色转换使得我们可以重用之前的结果，典型的动态规划标志。<br>读到这里的朋友应该能理解算法解决博弈问题的套路了。学习算法，一定要注重算法的模板框架，而不是一些看起来牛逼的思路，也不要奢求上来就写一个最优的解法。不要舍不得多用空间，不要过早尝试优化，不要惧怕多维数组。dp 数组就是存储信息避免重复计算的，随便用，直到咱满意为止。<br>希望本文对你有帮助。</p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF">上一篇：动态规划之子序列问题解题模板</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98">下一篇：贪心算法之区间调度问题</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之四键键盘</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%9B%9B%E9%94%AE%E9%94%AE%E7%9B%98/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%9B%9B%E9%94%AE%E9%94%AE%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>title: 动态规划之四键键盘<br>author: 远方<br>tags:</p><ul><li>LeetCode</li><li>算法<br>categories:</li><li>LeetCode破局攻略<br>date: 2016-01-01 19:20:00</li></ul><hr><h1 id="动态规划之四键键盘"><a href="#动态规划之四键键盘" class="headerlink" title="动态规划之四键键盘"></a>动态规划之四键键盘</h1><p>四键键盘问题很有意思，而且可以明显感受到：对 dp 数组的不同定义需要完全不同的逻辑，从而产生完全不同的解法。<br>首先看一下题目：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/4keyboard/title.png"><br>如何在 N 次敲击按钮后得到最多的 A？我们穷举呗，每次有对于每次按键，我们可以穷举四种可能，很明显就是一个动态规划问题。</p><h3 id="第一种思路"><a href="#第一种思路" class="headerlink" title="第一种思路"></a>第一种思路</h3><p>这种思路会很容易理解，但是效率并不高，我们直接走流程：<strong>对于动态规划问题，首先要明白有哪些「状态」，有哪些「选择」</strong>。<br>具体到这个问题，对于每次敲击按键，有哪些「选择」是很明显的：4 种，就是题目中提到的四个按键，分别是 <code>A</code>、<code>C-A</code>、<code>C-C</code>、<code>C-V</code>（<code>Ctrl</code> 简写为 <code>C</code>）。<br>接下来，思考一下对于这个问题有哪些「状态」？<strong>或者换句话说，我们需要知道什么信息，才能将原问题分解为规模更小的子问题</strong>？<br>你看我这样定义三个状态行不行：第一个状态是剩余的按键次数，用 <code>n</code> 表示；第二个状态是当前屏幕上字符 A 的数量，用 <code>a_num</code> 表示；第三个状态是剪切板中字符 A 的数量，用 <code>copy</code> 表示。<br>如此定义「状态」，就可以知道 base case：当剩余次数 <code>n</code> 为 0 时，<code>a_num</code> 就是我们想要的答案。<br>结合刚才说的 4 种「选择」，我们可以把这几种选择通过状态转移表示出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">dp(n - <span class="hljs-number">1</span>, a_num + <span class="hljs-number">1</span>, copy),    <span class="hljs-comment"># A</span><br>解释：按下 A 键，屏幕上加一个字符<br>同时消耗 <span class="hljs-number">1</span> 个操作数<br>dp(n - <span class="hljs-number">1</span>, a_num + copy, copy), <span class="hljs-comment"># C-V</span><br>解释：按下 C-V 粘贴，剪切板中的字符加入屏幕<br>同时消耗 <span class="hljs-number">1</span> 个操作数<br>dp(n - <span class="hljs-number">2</span>, a_num, a_num)        <span class="hljs-comment"># C-A C-C</span><br>解释：全选和复制必然是联合使用的，<br>剪切板中 A 的数量变为屏幕上 A 的数量<br>同时消耗 <span class="hljs-number">2</span> 个操作数<br></code></pre></td></tr></table></figure><p>这样可以看到问题的规模 <code>n</code> 在不断减小，肯定可以到达 <code>n = 0</code> 的 base case，所以这个思路是正确的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxA</span>(<span class="hljs-params">N: int</span>) -&gt; int:</span><br>    <span class="hljs-comment"># 对于 (n, a_num, copy) 这个状态，</span><br>    <span class="hljs-comment"># 屏幕上能最终最多能有 dp(n, a_num, copy) 个 A</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">n, a_num, copy</span>):</span><br>        <span class="hljs-comment"># base case</span><br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> a_num;<br>        <span class="hljs-comment"># 几种选择全试一遍，选择最大的结果</span><br>        <span class="hljs-keyword">return</span> max(<br>                dp(n - <span class="hljs-number">1</span>, a_num + <span class="hljs-number">1</span>, copy),    <span class="hljs-comment"># A</span><br>                dp(n - <span class="hljs-number">1</span>, a_num + copy, copy), <span class="hljs-comment"># C-V</span><br>                dp(n - <span class="hljs-number">2</span>, a_num, a_num)        <span class="hljs-comment"># C-A C-C</span><br>            )<br>    <span class="hljs-comment"># 可以按 N 次按键，屏幕和剪切板里都还没有 A</span><br>    <span class="hljs-keyword">return</span> dp(N, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>这个解法应该很好理解，因为语义明确。下面就继续走流程，用备忘录消除一下重叠子问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxA</span>(<span class="hljs-params">N: int</span>) -&gt; int:</span><br>    <span class="hljs-comment"># 备忘录</span><br>    memo = dict()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">n, a_num, copy</span>):</span><br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> a_num;<br>        <span class="hljs-comment"># 避免计算重叠子问题</span><br>        <span class="hljs-keyword">if</span> (n, a_num, copy) <span class="hljs-keyword">in</span> memo:<br>            <span class="hljs-keyword">return</span> memo[(n, a_num, copy)]<br>        memo[(n, a_num, copy)] = max(<br>                <span class="hljs-comment"># 几种选择还是一样的</span><br>            )<br>        <span class="hljs-keyword">return</span> memo[(n, a_num, copy)]<br>    <span class="hljs-keyword">return</span> dp(N, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>这样优化代码之后，子问题虽然没有重复了，但数目仍然很多，在 LeetCode 提交会超时的。<br>我们尝试分析一下这个算法的时间复杂度，就会发现不容易分析。我们可以把这个 dp 函数写成 dp 数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[n][a_num][copy]<br><span class="hljs-comment"># 状态的总数（时空复杂度）就是这个三维数组的体积</span><br></code></pre></td></tr></table></figure><p>我们知道变量 <code>n</code> 最多为 <code>N</code>，但是 <code>a_num</code> 和 <code>copy</code> 最多为多少我们很难计算，复杂度起码也有 O(N^3) 把。所以这个算法并不好，复杂度太高，且已经无法优化了。<br>这也就说明，我们这样定义「状态」是不太优秀的，下面我们换一种定义 dp 的思路。</p><h3 id="第二种思路"><a href="#第二种思路" class="headerlink" title="第二种思路"></a>第二种思路</h3><p>这种思路稍微有点复杂，但是效率高。继续走流程，「选择」还是那 4 个，但是这次我们只定义一个「状态」，也就是剩余的敲击次数 <code>n</code>。<br>这个算法基于这样一个事实，<strong>最优按键序列一定只有两种情况</strong>：<br>要么一直按 <code>A</code>：A,A,…A（当 N 比较小时）。<br>要么是这么一个形式：A,A,…C-A,C-C,C-V,C-V,…C-V（当 N 比较大时）。<br>因为字符数量少（N 比较小）时，<code>C-A C-C C-V</code> 这一套操作的代价相对比较高，可能不如一个个按 <code>A</code>；而当 N 比较大时，后期 <code>C-V</code> 的收获肯定很大。这种情况下整个操作序列大致是：<strong>开头连按几个 <code>A</code>，然后 <code>C-A C-C</code> 组合再接若干 <code>C-V</code>，然后再 <code>C-A C-C</code> 接着若干 <code>C-V</code>，循环下去</strong>。<br>换句话说，最后一次按键要么是 <code>A</code> 要么是 <code>C-V</code>。明确了这一点，可以通过这两种情况来设计算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>];<br><span class="hljs-comment">// 定义：dp[i] 表示 i 次操作后最多能显示多少个 A</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++) <br>    dp[i] = max(<br>            这次按 A 键，<br>            这次按 C-V<br>        )<br></code></pre></td></tr></table></figure><p>对于「按 <code>A</code> 键」这种情况，就是状态 <code>i - 1</code> 的屏幕上新增了一个 A 而已，很容易得到结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 按 A 键，就比上次多一个 A 而已</span><br>dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>但是，如果要按 <code>C-V</code>，还要考虑之前是在哪里 <code>C-A C-C</code> 的。<br><strong>刚才说了，最优的操作序列一定是 <code>C-A C-C</code> 接着若干 <code>C-V</code>，所以我们用一个变量 <code>j</code> 作为若干 <code>C-V</code> 的起点</strong>。那么 <code>j</code> 之前的 2 个操作就应该是 <code>C-A C-C</code> 了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-comment">// 按 A 键</span><br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-comment">// 全选 &amp; 复制 dp[j-2]，连续粘贴 i - j 次</span><br>            <span class="hljs-comment">// 屏幕上共 dp[j - 2] * (i - j + 1) 个 A</span><br>            dp[i] = Math.max(dp[i], dp[j - <span class="hljs-number">2</span>] * (i - j + <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// N 次按键之后最多有几个 A？</span><br>    <span class="hljs-keyword">return</span> dp[N];<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>j</code> 变量减 2 是给 <code>C-A C-C</code> 留下操作数，看个图就明白了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/4keyboard/1.jpg"><br>这样，此算法就完成了，时间复杂度 O(N^2)，空间复杂度 O(N)，这种解法应该是比较高效的了。</p><h3 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h3><p>动态规划难就难在寻找状态转移，不同的定义可以产生不同的状态转移逻辑，虽然最后都能得到正确的结果，但是效率可能有巨大的差异。<br>回顾第一种解法，重叠子问题已经消除了，但是效率还是低，到底低在哪里呢？抽象出递归框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">n, a_num, copy</span>):</span><br>    dp(n - <span class="hljs-number">1</span>, a_num + <span class="hljs-number">1</span>, copy),    <span class="hljs-comment"># A</span><br>    dp(n - <span class="hljs-number">1</span>, a_num + copy, copy), <span class="hljs-comment"># C-V</span><br>    dp(n - <span class="hljs-number">2</span>, a_num, a_num)        <span class="hljs-comment"># C-A C-C</span><br></code></pre></td></tr></table></figure><p>看这个穷举逻辑，是有可能出现这样的操作序列 <code>C-A C-C，C-A C-C...</code> 或者 <code>C-V,C-V,...</code>。然这种操作序列的结果不是最优的，但是我们并没有想办法规避这些情况的发生，从而增加了很多没必要的子问题计算。<br>回顾第二种解法，我们稍加思考就能想到，最优的序列应该是这种形式：<code>A,A..C-A,C-C,C-V,C-V..C-A,C-C,C-V..</code>。<br>根据这个事实，我们重新定义了状态，重新寻找了状态转移，从逻辑上减少了无效的子问题个数，从而提高了算法的效率。</p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%8A%A2%E6%88%BF%E5%AD%90">上一篇：团灭 LeetCode 打家劫舍问题</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE">下一篇：动态规划之正则表达</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之正则表达</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/</url>
      
        <content type="html"><![CDATA[<p>title: 动态规划之正则表达<br>author: 远方<br>tags:</p><ul><li>LeetCode</li><li>算法<br>categories:</li><li>LeetCode破局攻略<br>date: 2016-01-01 19:20:00</li></ul><hr><h1 id="动态规划之正则表达"><a href="#动态规划之正则表达" class="headerlink" title="动态规划之正则表达"></a>动态规划之正则表达</h1><p>之前的文章「动态规划详解」收到了普遍的好评，今天写一个动态规划的实际应用：正则表达式。如果有读者对「动态规划」还不了解，建议先看一下上面那篇文章。<br>正则表达式匹配是一个很精妙的算法，而且难度也不小。本文主要写两个正则符号的算法实现：点号「.」和星号「*」，如果你用过正则表达式，应该明白他们的用法，不明白也没关系，等会会介绍。文章的最后，介绍了一种快速看出重叠子问题的技巧。<br>本文还有一个重要目的，就是教会读者如何设计算法。我们平时看别人的解法，直接看到一个面面俱到的完整答案，总觉得无法理解，以至觉得问题太难，自己太菜。我力求向读者展示，算法的设计是一个螺旋上升、逐步求精的过程，绝不是一步到位就能写出正确算法。本文会带你解决这个较为复杂的问题，让你明白如何化繁为简，逐个击破，从最简单的框架搭建出最终的答案。<br>前文无数次强调的框架思维，就是在这种设计过程中逐步培养的。下面进入正题，首先看一下题目：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%AD%A3%E5%88%99/title.png" alt="title"></p><h3 id="一、热身"><a href="#一、热身" class="headerlink" title="一、热身"></a>一、热身</h3><p>第一步，我们暂时不管正则符号，如果是两个普通的字符串进行比较，如何进行匹配？我想这个算法应该谁都会写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-built_in">string</span> text, <span class="hljs-built_in">string</span> pattern)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (text.size() != pattern.size()) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; pattern.size(); j++) &#123;<br>        <span class="hljs-keyword">if</span> (pattern[j] != text[j])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，我稍微改造一下上面的代码，略微复杂了一点，但意思还是一样的，很容易理解吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-built_in">string</span> text, <span class="hljs-built_in">string</span> pattern)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// text 的索引位置</span><br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// pattern 的索引位置</span><br>    <span class="hljs-keyword">while</span> (j &lt; pattern.size()) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= text.size()) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (pattern[j++] != text[i++])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 相等则说明完成匹配</span><br>    <span class="hljs-keyword">return</span> j == text.size();<br>&#125;<br></code></pre></td></tr></table></figure><p>如上改写，是为了将这个算法改造成递归算法（伪码）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isMatch</span>(<span class="hljs-params">text, pattern</span>) -&gt; bool:</span><br>    if pattern is empty: return (text is empty?)<br>    first_match = (text <span class="hljs-keyword">not</span> empty) <span class="hljs-keyword">and</span> pattern[<span class="hljs-number">0</span>] == text[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> first_match <span class="hljs-keyword">and</span> isMatch(text[<span class="hljs-number">1</span>:], pattern[<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><p>如果你能够理解这段代码，恭喜你，你的递归思想已经到位，正则表达式算法虽然有点复杂，其实是基于这段递归代码逐步改造而成的。</p><h3 id="二、处理点号「-」通配符"><a href="#二、处理点号「-」通配符" class="headerlink" title="二、处理点号「.」通配符"></a>二、处理点号「.」通配符</h3><p>点号可以匹配任意一个字符，万金油嘛，其实是最简单的，稍加改造即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isMatch</span>(<span class="hljs-params">text, pattern</span>) -&gt; bool:</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pattern: <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> text<br>    first_match = bool(text) <span class="hljs-keyword">and</span> pattern[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> &#123;text[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;.&#x27;</span>&#125;<br>    <span class="hljs-keyword">return</span> first_match <span class="hljs-keyword">and</span> isMatch(text[<span class="hljs-number">1</span>:], pattern[<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><h3 id="三、处理「-」通配符"><a href="#三、处理「-」通配符" class="headerlink" title="三、处理「*」通配符"></a>三、处理「*」通配符</h3><p>星号通配符可以让前一个字符重复任意次数，包括零次。那到底是重复几次呢？这似乎有点困难，不过不要着急，我们起码可以把框架的搭建再进一步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isMatch</span>(<span class="hljs-params">text, pattern</span>) -&gt; bool:</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pattern: <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> text<br>    first_match = bool(text) <span class="hljs-keyword">and</span> pattern[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> &#123;text[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;.&#x27;</span>&#125;<br>    <span class="hljs-keyword">if</span> len(pattern) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> pattern[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>        <span class="hljs-comment"># 发现 &#x27;*&#x27; 通配符</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> first_match <span class="hljs-keyword">and</span> isMatch(text[<span class="hljs-number">1</span>:], pattern[<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><p>星号前面的那个字符到底要重复几次呢？这需要计算机暴力穷举来算，假设重复 N 次吧。前文多次强调过，写递归的技巧是管好当下，之后的事抛给递归。具体到这里，不管 N 是多少，当前的选择只有两个：匹配 0 次、匹配 1 次。所以可以这样处理：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> len(pattern) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> pattern[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>    <span class="hljs-keyword">return</span> isMatch(text, pattern[<span class="hljs-number">2</span>:]) <span class="hljs-keyword">or</span> \<br>            first_match <span class="hljs-keyword">and</span> isMatch(text[<span class="hljs-number">1</span>:], pattern)<br><span class="hljs-comment"># 解释：如果发现有字符和 &#x27;*&#x27; 结合，</span><br>    <span class="hljs-comment"># 或者匹配该字符 0 次，然后跳过该字符和 &#x27;*&#x27;</span><br>    <span class="hljs-comment"># 或者当 pattern[0] 和 text[0] 匹配后，移动 text</span><br></code></pre></td></tr></table></figure><p>可以看到，我们是通过保留 pattern 中的「*」，同时向后推移 text，来实现「*」将字符重复匹配多次的功能。举个简单的例子就能理解这个逻辑了。假设 <code>pattern = a*</code>, <code>text = aaa</code>，画个图看看匹配过程：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%AD%A3%E5%88%99/example.png" alt="example"><br>至此，正则表达式算法就基本完成了，</p><h3 id="四、动态规划"><a href="#四、动态规划" class="headerlink" title="四、动态规划"></a>四、动态规划</h3><p>我选择使用「备忘录」递归的方法来降低复杂度。有了暴力解法，优化的过程及其简单，就是使用两个变量 i, j 记录当前匹配到的位置，从而避免使用子字符串切片，并且将 i, j 存入备忘录，避免重复计算即可。<br>我将暴力解法和优化解法放在一起，方便你对比，你可以发现优化解法无非就是把暴力解法「翻译」了一遍，加了个 memo 作为备忘录，仅此而已。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 带备忘录的递归</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isMatch</span>(<span class="hljs-params">text, pattern</span>) -&gt; bool:</span><br>    memo = dict() <span class="hljs-comment"># 备忘录</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">i, j</span>):</span><br>        <span class="hljs-keyword">if</span> (i, j) <span class="hljs-keyword">in</span> memo: <span class="hljs-keyword">return</span> memo[(i, j)]<br>        <span class="hljs-keyword">if</span> j == len(pattern): <span class="hljs-keyword">return</span> i == len(text)<br>        first = i &lt; len(text) <span class="hljs-keyword">and</span> pattern[j] <span class="hljs-keyword">in</span> &#123;text[i], <span class="hljs-string">&#x27;.&#x27;</span>&#125;<br>        <br>        <span class="hljs-keyword">if</span> j &lt;= len(pattern) - <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> pattern[j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>            ans = dp(i, j + <span class="hljs-number">2</span>) <span class="hljs-keyword">or</span> \<br>                    first <span class="hljs-keyword">and</span> dp(i + <span class="hljs-number">1</span>, j)<br>        <span class="hljs-keyword">else</span>:<br>            ans = first <span class="hljs-keyword">and</span> dp(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>)<br>            <br>        memo[(i, j)] = ans<br>        <span class="hljs-keyword">return</span> ans<br>    <br>    <span class="hljs-keyword">return</span> dp(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># 暴力递归</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isMatch</span>(<span class="hljs-params">text, pattern</span>) -&gt; bool:</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pattern: <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> text<br>    first = bool(text) <span class="hljs-keyword">and</span> pattern[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> &#123;text[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;.&#x27;</span>&#125;<br>    <span class="hljs-keyword">if</span> len(pattern) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> pattern[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>        <span class="hljs-keyword">return</span> isMatch(text, pattern[<span class="hljs-number">2</span>:]) <span class="hljs-keyword">or</span> \<br>                first <span class="hljs-keyword">and</span> isMatch(text[<span class="hljs-number">1</span>:], pattern)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> first <span class="hljs-keyword">and</span> isMatch(text[<span class="hljs-number">1</span>:], pattern[<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><p><strong>有的读者也许会问，你怎么知道这个问题是个动态规划问题呢，你怎么知道它就存在「重叠子问题」呢，这似乎不容易看出来呀？</strong><br>解答这个问题，最直观的应该是随便假设一个输入，然后画递归树，肯定是可以发现相同节点的。这属于定量分析，其实不用这么麻烦，下面我来教你定性分析，一眼就能看出「重叠子问题」性质。<br>先拿最简单的斐波那契数列举例，我们抽象出递归算法的框架：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>):</span><br>    fib(n - <span class="hljs-number">1</span>) <span class="hljs-comment">#1</span><br>    fib(n - <span class="hljs-number">2</span>) <span class="hljs-comment">#2</span><br></code></pre></td></tr></table></figure><p>看着这个框架，请问原问题 f(n) 如何触达子问题 f(n - 2) ？有两种路径，一是 f(n) -&gt; #1 -&gt; #1, 二是 f(n) -&gt; #2。前者经过两次递归，后者进过一次递归而已。两条不同的计算路径都到达了同一个问题，这就是「重叠子问题」，而且可以肯定的是，<strong>只要你发现一条重复路径，这样的重复路径一定存在千万条，意味着巨量子问题重叠。</strong><br>同理，对于本问题，我们依然先抽象出算法框架：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">i, j</span>):</span><br>    dp(i, j + <span class="hljs-number">2</span>)     <span class="hljs-comment">#1</span><br>    dp(i + <span class="hljs-number">1</span>, j)     <span class="hljs-comment">#2</span><br>    dp(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) <span class="hljs-comment">#3</span><br></code></pre></td></tr></table></figure><p>提出类似的问题，请问如何从原问题 dp(i, j) 触达子问题 dp(i + 2, j + 2) ？至少有两种路径，一是 dp(i, j) -&gt; #3 -&gt; #3，二是 dp(i, j) -&gt; #1 -&gt; #2 -&gt; #2。因此，本问题一定存在重叠子问题，一定需要动态规划的优化技巧来处理。</p><h3 id="五、最后总结"><a href="#五、最后总结" class="headerlink" title="五、最后总结"></a>五、最后总结</h3><p>通过本文，你深入理解了正则表达式的两种常用通配符的算法实现。其实点号「.」的实现及其简单，关键是星号「*」的实现需要用到动态规划技巧，稍微复杂些，但是也架不住我们对问题的层层拆解，逐个击破。另外，你掌握了一种快速分析「重叠子问题」性质的技巧，可以快速判断一个问题是否可以使用动态规划套路解决。<br>回顾整个解题过程，你应该能够体会到算法设计的流程：从简单的类似问题入手，给基本的框架逐渐组装新的逻辑，最终成为一个比较复杂、精巧的算法。所以说，读者不必畏惧一些比较复杂的算法问题，多思考多类比，再高大上的算法在你眼里也不过一个脆皮。</p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%9B%9B%E9%94%AE%E9%94%AE%E7%9B%98">上一篇：动态规划之四键键盘</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">下一篇：最长公共子序列</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划系列</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>title: 动态规划系列<br>author: 远方<br>tags:</p><ul><li>LeetCode</li><li>算法<br>categories:</li><li>LeetCode破局攻略<br>date: 2016-01-01 19:20:00</li></ul><hr><h1 id="动态规划系列"><a href="#动态规划系列" class="headerlink" title="动态规划系列"></a>动态规划系列</h1><ul><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6">动态规划详解</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84">动态规划答疑篇</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">动态规划设计：最长递增子序列</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">编辑距离</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98">经典动态规划问题：高楼扔鸡蛋</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E8%BF%9B%E9%98%B6">经典动态规划问题：高楼扔鸡蛋（进阶）</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF">动态规划之子序列问题解题模板</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98">动态规划之博弈问题</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98">贪心算法之区间调度问题</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8BKMP%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95">动态规划之KMP字符匹配算法</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%9B%A2%E7%81%AD%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98">团灭 LeetCode 股票买卖问题</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%8A%A2%E6%88%BF%E5%AD%90">团灭 LeetCode 打家劫舍问题</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%9B%9B%E9%94%AE%E9%94%AE%E7%9B%98">动态规划之四键键盘</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE">动态规划之正则表达</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">最长公共子序列</a></li></ul><p>我们公众号最火的就是动态规划系列的文章，也许是动态规划问题有难度而且有意思，也许因为它是面试常考题型。不管你之前是否害怕动态规划系列的问题，相信这一章的内容足以帮助你消除对动态规划算法的恐惧。<br>具体来说，动态规划的一般流程就是三步：<strong>暴力的递归解法 -&gt; 带备忘录的递归解法 -&gt; 迭代的动态规划解法</strong>。<br>就思考流程来说，就分为一下几步：<strong>找到状态和选择 -&gt; 明确 dp 数组/函数的定义 -&gt; 寻找状态之间的关系</strong>。<br>这就是思维模式的框架，<strong>本章都会按照以上的模式来解决问题，辅助读者养成这种模式思维</strong>，有了方向遇到问题就不会抓瞎，足以解决一般的动态规划问题。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划设计：最长递增子序列</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>title: 动态规划设计：最长递增子序列<br>author: 远方<br>tags:</p><ul><li>LeetCode</li><li>算法<br>categories:</li><li>LeetCode破局攻略<br>date: 2016-01-01 19:20:00</li></ul><hr><h1 id="动态规划设计：最长递增子序列"><a href="#动态规划设计：最长递增子序列" class="headerlink" title="动态规划设计：最长递增子序列"></a>动态规划设计：最长递增子序列</h1><p>很多读者反应，就算看了前文<a href="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6">动态规划详解</a>，了解了动态规划的套路，也不会写状态转移方程，没有思路，怎么办？本文就借助「最长递增子序列」来讲一种设计动态规划的通用技巧：数学归纳思想。<br>最长递增子序列（Longest Increasing Subsequence，简写 LIS）是比较经典的一个问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何写动态规划。比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。<br>先看一下题目，很容易理解：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/title.png" alt="title"><br>注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。下面先来一步一步设计动态规划算法解决这个问题。</p><h3 id="一、动态规划解法"><a href="#一、动态规划解法" class="headerlink" title="一、动态规划解法"></a>一、动态规划解法</h3><p>动态规划的核心设计思想是数学归纳法。<br>相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么我们先假设这个结论在 $k&lt;n$ 时成立，然后想办法证明 $k=n$ 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。<br>类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 $dp[0…i-1]$ 都已经被算出来了，然后问自己：怎么通过这些结果算出 dp[i]？<br>直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 dp[i] 的值到底代表着什么？<br><strong>我们的定义是这样的：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。</strong><br>举两个例子：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/1.jpeg" alt="1"></p><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/2.jpeg" alt="2"><br>算法演进的过程是这样的，：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/gif1.gif" alt="gif1"><br>根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dp.size(); i++) &#123;<br>    res = Math.max(res, dp[i]);<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure><p>读者也许会问，刚才这个过程中每个 dp[i] 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 dp[i] 呢？<br>这就是动态规划的重头戏了，要思考如何进行状态转移，这里就可以使用数学归纳的思想：<br>我们已经知道了 $dp[0…4]$ 的所有结果，我们如何通过这些已知结果推出 $dp[5]$ 呢？<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/3.jpeg" alt="3"><br>根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。<br>nums[5] = 3，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。<br>当然，可能形成很多种新的子序列，但是我们只要最长的，把最长子序列的长度作为 dp[5] 的值即可。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/gif2.gif" alt="gif2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) <br>        dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的逻辑就可以算出 dp[5]。到这里，这道算法题我们就基本做完了。读者也许会问，我们刚才只是算了 dp[5] 呀，dp[4], dp[3] 这些怎么算呢？<br>类似数学归纳法，你已经可以算出 dp[5] 了，其他的就都可以算出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) <br>            dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一个细节问题，dp 数组应该全部初始化为 1，因为子序列最少也要包含自己，所以长度最小为 1。下面我们看一下完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    <span class="hljs-comment">// dp 数组全都初始化为 1</span><br>    Arrays.fill(dp, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) <br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dp.length; i++) &#123;<br>        res = Math.max(res, dp[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，这道题就解决了，时间复杂度 O(N^2)。总结一下动态规划的设计流程：<br>首先明确 dp 数组所存数据的含义。这步很重要，如果不得当或者不够清晰，会阻碍之后的步骤。<br>然后根据 dp 数组的定义，运用数学归纳法的思想，假设 $dp[0…i-1]$ 都已知，想办法求出 $dp[i]$，一旦这一步完成，整个题目基本就解决了。<br>但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。<br>最后想一想问题的 base case 是什么，以此来初始化 dp 数组，以保证算法正确运行。</p><h3 id="二、二分查找解法"><a href="#二、二分查找解法" class="headerlink" title="二、二分查找解法"></a>二、二分查找解法</h3><p>这个解法的时间复杂度会将为 O(NlogN)，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以如果大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。<br>根据题目的意思，我都很难想象这个问题竟然能和二分查找扯上关系。其实最长递增子序列和一种叫做 patience game 的纸牌游戏有关，甚至有一种排序方法就叫做 patience sorting（耐心排序）。<br>为了简单期间，后文跳过所有数学证明，通过一个简化的例子来理解一下思路。<br>首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/poker1.jpeg" alt="poker1"><br>处理这些扑克牌要遵循以下规则：<br>只能把点数小的牌压到点数比它大的牌上。如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去。如果当前牌有多个堆可供选择，则选择最左边的堆放置。<br>比如说上述的扑克牌最终会被分成这样 5 堆（我们认为 A 的值是最大的，而不是 1）。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/poker2.jpeg" alt="poker2"><br>为什么遇到多个可选择堆的时候要放到最左边的堆上呢？因为这样可以保证牌堆顶的牌有序（2, 4, 7, 8, Q），证明略。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/poker3.jpeg" alt="poker3"><br>按照上述规则执行，可以算出最长递增子序列，牌的堆数就是最长递增子序列的长度，证明略。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/poker4.jpeg" alt="LIS"><br>我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是有序吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置。<br>PS：旧文<a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3">二分查找算法详解</a>详细介绍了二分查找的细节及变体，这里就完美应用上了。如果没读过强烈建议阅读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] top = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    <span class="hljs-comment">// 牌堆数初始化为 0</span><br>    <span class="hljs-keyword">int</span> piles = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 要处理的扑克牌</span><br>        <span class="hljs-keyword">int</span> poker = nums[i];<br>        <span class="hljs-comment">/***** 搜索左侧边界的二分查找 *****/</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = piles;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (top[mid] &gt; poker) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (top[mid] &lt; poker) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*********************************/</span><br>        <br>        <span class="hljs-comment">// 没找到合适的牌堆，新建一堆</span><br>        <span class="hljs-keyword">if</span> (left == piles) piles++;<br>        <span class="hljs-comment">// 把这张牌放到牌堆顶</span><br>        top[left] = poker;<br>    &#125;<br>    <span class="hljs-comment">// 牌堆数就是 LIS 长度</span><br>    <span class="hljs-keyword">return</span> piles;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，二分查找的解法也讲解完毕。<br>这个解法确实很难想到。首先涉及数学证明，谁能想到按照这些规则执行，就能得到最长递增子序列呢？其次还有二分查找的运用，要是对二分查找的细节不清楚，给了思路也很难写对。<br>所以，这个方法作为思维拓展好了。但动态规划的设计方法应该完全理解：假设之前的答案已知，利用数学归纳的思想正确进行状态的推演转移，最终得到答案。</p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84">上一篇：动态规划答疑篇</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">下一篇：编辑距离</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子序列问题模板</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>title: 子序列问题模板<br>author: 远方<br>tags:</p><ul><li>LeetCode</li><li>算法<br>categories:</li><li>LeetCode破局攻略<br>date: 2016-01-01 19:20:00</li></ul><hr><h1 id="动态规划之子序列问题解题模板"><a href="#动态规划之子序列问题解题模板" class="headerlink" title="动态规划之子序列问题解题模板"></a>动态规划之子序列问题解题模板</h1><p>子序列问题是常见的算法问题，而且并不好解决。<br>首先，子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，就算穷举你都不一定会，更别说求解相关的算法问题了。<br>而且，子序列问题很可能涉及到两个字符串，比如前文「最长公共子序列」，如果没有一定的处理经验，真的不容易想出来。所以本文就来扒一扒子序列问题的套路，其实就有两种模板，相关问题只要往这两种思路上想，十拿九稳。<br>一般来说，这类问题都是让你求一个<strong>最长子序列</strong>，因为最短子序列就是一个字符嘛，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，**考察的是动态规划技巧，时间复杂度一般都是 O(n^2)**。<br>原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着？<br>既然要用动态规划，那就要定义 dp 数组，找状态转移关系。我们说的两种思路模板，就是 dp 数组的定义思路。不同的问题可能需要不同的 dp 数组定义来解决。</p><h3 id="一、两种思路"><a href="#一、两种思路" class="headerlink" title="一、两种思路"></a>一、两种思路</h3><p><strong>1、第一种思路模板是一个一维的 dp 数组</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = array.length;<br><span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>        dp[i] = 最值(dp[i], dp[j] + ...)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>举个我们写过的例子「最长递增子序列」，在这个思路中 dp 数组的定义是：<br><strong>在子数组 <code>array[0..i]</code> 中，我们要求的子序列（最长递增子序列）的长度是 <code>dp[i]</code>**。<br>为啥最长递增子序列需要这种思路呢？前文说得很清楚了，因为这样符合归纳法，可以找到状态转移的关系，这里就不具体展开了。<br>**2、第二种思路模板是一个二维的 dp 数组</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = arr.length;<br><span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> dp[n][n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] == arr[j]) <br>            dp[i][j] = dp[i][j] + ...<br>        <span class="hljs-keyword">else</span><br>            dp[i][j] = 最值(...)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种思路运用相对更多一些，尤其是涉及两个字符串/数组的子序列，比如前文讲的「最长公共子序列」。本思路中 dp 数组含义又分为「只涉及一个字符串」和「涉及两个字符串」两种情况。<br><strong>2.1 涉及两个字符串/数组时</strong>（比如最长公共子序列），dp 数组的含义如下：<br><strong>在子数组 <code>arr1[0..i]</code> 和子数组 <code>arr2[0..j]</code> 中，我们要求的子序列（最长公共子序列）长度为 <code>dp[i][j]</code>**。<br>**2.2 只涉及一个字符串/数组时</strong>（比如本文要讲的最长回文子序列），dp 数组的含义如下：<br>**在子数组 <code>array[i..j]</code> 中，我们要求的子序列（最长回文子序列）的长度为 <code>dp[i][j]</code>**。<br>第一种情况可以参考这两篇旧文：「编辑距离」「公共子序列」<br>下面就借最长回文子序列这个问题，详解一下第二种情况下如何使用动态规划。</p><h3 id="二、最长回文子序列"><a href="#二、最长回文子序列" class="headerlink" title="二、最长回文子序列"></a>二、最长回文子序列</h3><p>之前解决了「最长回文子串」的问题，这次提升难度，求最长回文子序列的长度：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/1.jpg"><br>我们说这个问题对 dp 数组的定义是：<strong>在子串 <code>s[i..j]</code> 中，最长回文子序列的长度为 <code>dp[i][j]</code>**。一定要记住这个定义才能理解算法。<br>为啥这个问题要这样定义二维的 dp 数组呢？我们前文多次提到，</strong>找状态转移需要归纳思维，说白了就是如何从已知的结果推出未知的部分<strong>，这样定义容易归纳，容易发现状态转移关系。<br>具体来说，如果我们想求 <code>dp[i][j]</code>，假设你知道了子问题 <code>dp[i+1][j-1]</code> 的结果（<code>s[i+1..j-1]</code> 中最长回文子序列的长度），你是否能想办法算出 <code>dp[i][j]</code> 的值（<code>s[i..j]</code> 中，最长回文子序列的长度）呢？<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/1.jpg"><br>可以！这取决于 <code>s[i]</code> 和 <code>s[j]</code> 的字符：<br>**如果它俩相等</strong>，那么它俩加上 <code>s[i+1..j-1]</code> 中的最长回文子序列就是 <code>s[i..j]</code> 的最长回文子序列：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/2.jpg"><br><strong>如果它俩不相等</strong>，说明它俩<strong>不可能同时</strong>出现在 <code>s[i..j]</code> 的最长回文子序列中，那么把它俩<strong>分别</strong>加入 <code>s[i+1..j-1]</code> 中，看看哪个子串产生的回文子序列更长即可：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/3.jpg"><br>以上两种情况写成代码就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (s[i] == s[j])<br>    <span class="hljs-comment">// 它俩一定在最长回文子序列中</span><br>    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？</span><br>    dp[i][j] = max(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>至此，状态转移方程就写出来了，根据 dp 数组的定义，我们要求的就是 <code>dp[0][n - 1]</code>，也就是整个 <code>s</code> 的最长回文子序列的长度。</p><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><p>首先明确一下 base case，如果只有一个字符，显然最长回文子序列长度是 1，也就是 <code>dp[i][j] = 1 (i == j)</code>。<br>因为 <code>i</code> 肯定小于等于 <code>j</code>，所以对于那些 <code>i &gt; j</code> 的位置，根本不存在什么子序列，应该初始化为 0。<br>另外，看看刚才写的状态转移方程，想求 <code>dp[i][j]</code> 需要知道 <code>dp[i+1][j-1]</code>，<code>dp[i+1][j]</code>，<code>dp[i][j-1]</code> 这三个位置；再看看我们确定的 base case，填入 dp 数组之后是这样：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/4.jpg"><br><strong>为了保证每次计算 <code>dp[i][j]</code>，左下右方向的位置已经被计算出来，只能斜着遍历或者反着遍历</strong>：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/5.jpg"><br>我选择反着遍历，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.size();<br>    <span class="hljs-comment">// dp 数组全部初始化为 0</span><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>))</span></span>;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        dp[i][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 反着遍历保证正确的状态转移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">// 状态转移方程</span><br>            <span class="hljs-keyword">if</span> (s[i] == s[j])<br>                dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[i][j] = max(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 整个 s 的最长回文子串长度</span><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，最长回文子序列的问题就解决了。</p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E8%BF%9B%E9%98%B6">上一篇：经典动态规划问题：高楼扔鸡蛋（进阶）</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98">下一篇：动态规划之博弈问题</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抢房子</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%8A%A2%E6%88%BF%E5%AD%90/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%8A%A2%E6%88%BF%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>title: 抢房子<br>author: 远方<br>tags:</p><ul><li>LeetCode</li><li>算法<br>categories:</li><li>LeetCode破局攻略<br>date: 2016-01-01 19:20:00</li></ul><hr><h1 id="团灭-LeetCode-打家劫舍问题"><a href="#团灭-LeetCode-打家劫舍问题" class="headerlink" title="团灭 LeetCode 打家劫舍问题"></a>团灭 LeetCode 打家劫舍问题</h1><p>有读者私下问我 LeetCode 「打家劫舍」系列问题（英文版叫 House Robber）怎么做，我发现这一系列题目的点赞非常之高，是比较有代表性和技巧性的动态规划题目，今天就来聊聊这道题目。<br>打家劫舍系列总共有三道，难度设计非常合理，层层递进。第一道是比较标准的动态规划问题，而第二道融入了环形数组的条件，第三道更绝，把动态规划的自底向上和自顶向下解法和二叉树结合起来，我认为很有启发性。如果没做过的朋友，建议学习一下。<br>下面，我们从第一道开始分析。</p><h3 id="House-Robber-I"><a href="#House-Robber-I" class="headerlink" title="House Robber I"></a>House Robber I</h3><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/robber/title.png" alt="title"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>;<br></code></pre></td></tr></table></figure><p>题目很容易理解，而且动态规划的特征很明显。我们前文「动态规划详解」做过总结，<strong>解决动态规划问题就是找「状态」和「选择」，仅此而已</strong>。<br>假想你就是这个专业强盗，从左到右走过这一排房子，在每间房子前都有两种<strong>选择</strong>：抢或者不抢。<br>如果你抢了这间房子，那么你<strong>肯定</strong>不能抢相邻的下一间房子了，只能从下下间房子开始做选择。<br>如果你不抢这件房子，那么你可以走到下一间房子前，继续做选择。<br>当你走过了最后一间房子后，你就没得抢了，能抢到的钱显然是 0（<strong>base case</strong>）。<br>以上的逻辑很简单吧，其实已经明确了「状态」和「选择」：<strong>你面前房子的索引就是状态，抢和不抢就是选择</strong>。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/robber/1.jpg" alt="1"><br>在两个选择中，每次都选更大的结果，最后得到的就是最多能抢到的 money：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> dp(nums, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 返回 nums[start..] 能抢到的最大值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> res = Math.max(<br>            <span class="hljs-comment">// 不抢，去下家</span><br>            dp(nums, start + <span class="hljs-number">1</span>), <br>            <span class="hljs-comment">// 抢，去下下家</span><br>            nums[start] + dp(nums, start + <span class="hljs-number">2</span>)<br>        );<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>明确了状态转移，就可以发现对于同一 <code>start</code> 位置，是存在重叠子问题的，比如下图：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/robber/2.jpg" alt="2"><br>盗贼有多种选择可以走到这个位置，如果每次到这都进入递归，岂不是浪费时间？所以说存在重叠子问题，可以用备忘录进行优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] memo;<br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化备忘录</span><br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 强盗从第 0 间房子开始抢劫</span><br>    <span class="hljs-keyword">return</span> dp(nums, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 返回 dp[start..] 能抢到的最大值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 避免重复计算</span><br>    <span class="hljs-keyword">if</span> (memo[start] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[start];<br>    <br>    <span class="hljs-keyword">int</span> res = Math.max(dp(nums, start + <span class="hljs-number">1</span>), <br>                    nums[start] + dp(nums, start + <span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 记入备忘录</span><br>    memo[start] = res;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是自顶向下的动态规划解法，我们也可以略作修改，写出<strong>自底向上</strong>的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">// dp[i] = x 表示：</span><br>    <span class="hljs-comment">// 从第 i 间房子开始抢劫，最多能抢到的钱为 x</span><br>    <span class="hljs-comment">// base case: dp[n] = 0</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        dp[i] = Math.max(dp[i + <span class="hljs-number">1</span>], nums[i] + dp[i + <span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>我们又发现状态转移只和 <code>dp[i]</code> 最近的两个状态有关，所以可以进一步优化，将空间复杂度降低到 O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">// 记录 dp[i+1] 和 dp[i+2]</span><br>    <span class="hljs-keyword">int</span> dp_i_1 = <span class="hljs-number">0</span>, dp_i_2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 记录 dp[i]</span><br>    <span class="hljs-keyword">int</span> dp_i = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        dp_i = Math.max(dp_i_1, nums[i] + dp_i_2);<br>        dp_i_2 = dp_i_1;<br>        dp_i_1 = dp_i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的流程，在我们「动态规划详解」中详细解释过，相信大家都能手到擒来了。我认为很有意思的是这个问题的 follow up，需要基于我们现在的思路做一些巧妙的应变。</p><h3 id="House-Robber-II"><a href="#House-Robber-II" class="headerlink" title="House Robber II"></a>House Robber II</h3><p>这道题目和第一道描述基本一样，强盗依然不能抢劫相邻的房子，输入依然是一个数组，但是告诉你<strong>这些房子不是一排，而是围成了一个圈</strong>。<br>也就是说，现在第一间房子和最后一间房子也相当于是相邻的，不能同时抢。比如说输入数组 <code>nums=[2,3,2]</code>，算法返回的结果应该是 3 而不是 4，因为开头和结尾不能同时被抢。<br>这个约束条件看起来应该不难解决，我们前文「单调栈解决 Next Greater Number」说过一种解决环形数组的方案，那么在这个问题上怎么处理呢？<br>首先，首尾房间不能同时被抢，那么只可能有三种不同情况：要么都不被抢；要么第一间房子被抢最后一间不抢；要么最后一间房子被抢第一间不抢。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/robber/3.jpg" alt="3"><br>那就简单了啊，这三种情况，那种的结果最大，就是最终答案呗！不过，其实我们不需要比较三种情况，只要比较情况二和情况三就行了，<strong>因为这两种情况对于房子的选择余地比情况一大呀，房子里的钱数都是非负数，所以选择余地大，最优决策结果肯定不会小</strong>。<br>所以只需对之前的解法稍作修改即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> Math.max(robRange(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">2</span>), <br>                    robRange(nums, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-comment">// 仅计算闭区间 [start,end] 的最优结果</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">robRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span> dp_i_1 = <span class="hljs-number">0</span>, dp_i_2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> dp_i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = end; i &gt;= start; i--) &#123;<br>        dp_i = Math.max(dp_i_1, nums[i] + dp_i_2);<br>        dp_i_2 = dp_i_1;<br>        dp_i_1 = dp_i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，第二问也解决了。</p><h3 id="House-Robber-III"><a href="#House-Robber-III" class="headerlink" title="House Robber III"></a>House Robber III</h3><p>第三题又想法设法地变花样了，此强盗发现现在面对的房子不是一排，不是一圈，而是一棵二叉树！房子在二叉树的节点上，相连的两个房子不能同时被抢劫，果然是传说中的高智商犯罪：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/robber/title1.png" alt="title"><br>整体的思路完全没变，还是做抢或者不抢的选择，去收益较大的选择。甚至我们可以直接按这个套路写出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;TreeNode, Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 利用备忘录消除重叠子问题</span><br>    <span class="hljs-keyword">if</span> (memo.containsKey(root)) <br>        <span class="hljs-keyword">return</span> memo.get(root);<br>    <span class="hljs-comment">// 抢，然后去下下家</span><br>    <span class="hljs-keyword">int</span> do_it = root.val<br>        + (root.left == <span class="hljs-keyword">null</span> ? <br>            <span class="hljs-number">0</span> : rob(root.left.left) + rob(root.left.right))<br>        + (root.right == <span class="hljs-keyword">null</span> ? <br>            <span class="hljs-number">0</span> : rob(root.right.left) + rob(root.right.right));<br>    <span class="hljs-comment">// 不抢，然后去下家</span><br>    <span class="hljs-keyword">int</span> not_do = rob(root.left) + rob(root.right);<br>    <br>    <span class="hljs-keyword">int</span> res = Math.max(do_it, not_do);<br>    memo.put(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题就解决了，时间复杂度 O(N)，<code>N</code> 为数的节点数。<br>但是这道题让我觉得巧妙的点在于，还有更漂亮的解法。比如下面是我在评论区看到的一个解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] res = dp(root);<br>    <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">/* 返回一个大小为 2 的数组 arr</span><br><span class="hljs-comment">arr[0] 表示不抢 root 的话，得到的最大钱数</span><br><span class="hljs-comment">arr[1] 表示抢 root 的话，得到的最大钱数 */</span><br><span class="hljs-keyword">int</span>[] dp(TreeNode root) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">int</span>[] left = dp(root.left);<br>    <span class="hljs-keyword">int</span>[] right = dp(root.right);<br>    <span class="hljs-comment">// 抢，下家就不能抢了</span><br>    <span class="hljs-keyword">int</span> rob = root.val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 不抢，下家可抢可不抢，取决于收益大小</span><br>    <span class="hljs-keyword">int</span> not_rob = Math.max(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>])<br>                + Math.max(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;not_rob, rob&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)，空间复杂度只有递归函数堆栈所需的空间，不需要备忘录的额外空间。<br>你看他和我们的思路不一样，修改了递归函数的定义，略微修改了思路，使得逻辑自洽，依然得到了正确的答案，而且代码更漂亮。这就是我们前文「不同定义产生不同解法」所说过的动态规划问题的一个特性。<br>实际上，这个解法比我们的解法运行时间要快得多，虽然算法分析层面时间复杂度是相同的。原因在于此解法没有使用额外的备忘录，减少了数据操作的复杂性，所以实际运行效率会快。</p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%9B%A2%E7%81%AD%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98">上一篇：团灭 LeetCode 股票买卖问题</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%9B%9B%E9%94%AE%E9%94%AE%E7%9B%98">下一篇：动态规划之四键键盘</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最优子结构</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>title: 最优子结构<br>author: 远方<br>tags:</p><ul><li>LeetCode</li><li>算法<br>categories:</li><li>LeetCode破局攻略<h1 id="动态规划答疑篇"><a href="#动态规划答疑篇" class="headerlink" title="动态规划答疑篇"></a>动态规划答疑篇</h1>这篇文章就给你讲明白两个问题：<br>1、到底什么才叫「最优子结构」，和动态规划什么关系。<br>2、为什么动态规划遍历 <code>dp</code> 数组的方式五花八门，有的正着遍历，有的倒着遍历，有的斜着遍历。<h3 id="一、最优子结构详解"><a href="#一、最优子结构详解" class="headerlink" title="一、最优子结构详解"></a>一、最优子结构详解</h3>「最优子结构」是某些问题的一种特定性质，并不是动态规划问题专有的。也就是说，很多问题其实都具有最优子结构，只是其中大部分不具有重叠子问题，所以我们不把它们归为动态规划系列问题而已。<br>我先举个很容易理解的例子：假设你们学校有 10 个班，你已经计算出了每个班的最高考试成绩。那么现在我要求你计算全校最高的成绩，你会不会算？当然会，而且你不用重新遍历全校学生的分数进行比较，而是只要在这 10 个最高成绩中取最大的就是全校的最高成绩。<br>我给你提出的这个问题就<strong>符合最优子结构</strong>：可以从子问题的最优结果推出更大规模问题的最优结果。让你算<strong>每个班</strong>的最优成绩就是子问题，你知道所有子问题的答案后，就可以借此推出<strong>全校</strong>学生的最优成绩这个规模更大的问题的答案。<br>你看，这么简单的问题都有最优子结构性质，只是因为显然没有重叠子问题，所以我们简单地求最值肯定用不出动态规划。<br>再举个例子：假设你们学校有 10 个班，你已知每个班的最大分数差（最高分和最低分的差值）。那么现在我让你计算全校学生中的最大分数差，你会不会算？可以想办法算，但是肯定不能通过已知的这 10 个班的最大分数差推到出来。因为这 10 个班的最大分数差不一定就包含全校学生的最大分数差，比如全校的最大分数差可能是 3 班的最高分和 6 班的最低分之差。<br>这次我给你提出的问题就<strong>不符合最优子结构</strong>，因为你没办通过每个班的最优值推出全校的最优值，没办法通过子问题的最优值推出规模更大的问题的最优值。前文「动态规划详解」说过，想满足最优子结，子问题之间必须互相独立。全校的最大分数差可能出现在两个班之间，显然子问题不独立，所以这个问题本身不符合最优子结构。<br><strong>那么遇到这种最优子结构失效情况，怎么办？策略是：改造问题</strong>。对于最大分数差这个问题，我们不是没办法利用已知的每个班的分数差吗，那我只能这样写一段暴力代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (Student a : school) &#123;<br>    <span class="hljs-keyword">for</span> (Student b : school) &#123;<br>        <span class="hljs-keyword">if</span> (a is b) <span class="hljs-keyword">continue</span>;<br>        result = max(result, |a.score - b.score|);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure>改造问题，也就是把问题等价转化：最大分数差，不就等价于最高分数和最低分数的差么，那不就是要求最高和最低分数么，不就是我们讨论的第一个问题么，不就具有最优子结构了么？那现在改变思路，借助最优子结构解决最值问题，再回过头解决最大分数差问题，是不是就高效多了？<br>当然，上面这个例子太简单了，不过请读者回顾一下，我们做动态规划问题，是不是一直在求各种最值，本质跟我们举的例子没啥区别，无非需要处理一下重叠子问题。<br>前文「不同定义不同解法」和「高楼扔鸡蛋进阶」就展示了如何改造问题，不同的最优子结构，可能导致不同的解法和效率。<br>再举个常见但也十分简单的例子，求一棵二叉树的最大值，不难吧（简单起见，假设节点中的值都是非负数）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxVal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> left = maxVal(root.left);<br>    <span class="hljs-keyword">int</span> right = maxVal(root.right);<br>    <span class="hljs-keyword">return</span> max(root.val, left, right);<br>&#125;<br></code></pre></td></tr></table></figure>你看这个问题也符合最优子结构，以 <code>root</code> 为根的树的最大值，可以通过两边子树（子问题）的最大值推导出来，结合刚才学校和班级的例子，很容易理解吧。<br>当然这也不是动态规划问题，旨在说明，最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；<strong>但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的</strong>，以后碰到那种恶心人的最值题，思路往动态规划想就对了，这就是套路。<br>动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。<br>找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路，经常刷题的朋友应该能体会。<br>这里就不举那些正宗动态规划的例子了，读者可以翻翻历史文章，看看状态转移是如何遵循最优子结构的，这个话题就聊到这，下面再来看另外个动态规划迷惑行为。<h3 id="二、dp-数组的遍历方向"><a href="#二、dp-数组的遍历方向" class="headerlink" title="二、dp 数组的遍历方向"></a>二、dp 数组的遍历方向</h3>我相信读者做动态规问题时，肯定会对 <code>dp</code> 数组的遍历顺序有些头疼。我们拿二维 <code>dp</code> 数组来举例，有时候我们是正向遍历：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        <span class="hljs-comment">// 计算 dp[i][j]</span><br></code></pre></td></tr></table></figure>有时候我们反向遍历：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)<br>        <span class="hljs-comment">// 计算 dp[i][j]</span><br></code></pre></td></tr></table></figure>有时候可能会斜向遍历：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 斜着遍历数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>; l &lt;= n; l++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n - l; i++) &#123;<br>        <span class="hljs-keyword">int</span> j = l + i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 计算 dp[i][j]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>甚至更让人迷惑的是，有时候发现正向反向遍历都可以得到正确答案，比如我们在「团灭股票问题」中有的地方就正反皆可。<br>那么，如果仔细观察的话可以发现其中的原因的。你只要把住两点就行了：<br><strong>1、遍历的过程中，所需的状态必须是已经计算出来的</strong>。<br><strong>2、遍历的终点必须是存储结果的那个位置</strong>。<br>下面来距离解释上面两个原则是什么意思。<br>比如编辑距离这个经典的问题，详解见前文「编辑距离详解」，我们通过对 <code>dp</code> 数组的定义，确定了 base case 是 <code>dp[..][0]</code> 和 <code>dp[0][..]</code>，最终答案是 <code>dp[m][n]</code>；而且我们通过状态转移方程知道 <code>dp[i][j]</code> 需要从 <code>dp[i-1][j]</code>, <code>dp[i][j-1]</code>, <code>dp[i-1][j-1]</code> 转移而来，如下图：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84/1.jpg"><br>那么，参考刚才说的两条原则，你该怎么遍历 <code>dp</code> 数组？肯定是正向遍历：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)<br>        <span class="hljs-comment">// 通过 dp[i-1][j], dp[i][j - 1], dp[i-1][j-1]</span><br>        <span class="hljs-comment">// 计算 dp[i][j]</span><br></code></pre></td></tr></table></figure>因为，这样每一步迭代的左边、上边、左上边的位置都是 base case 或者之前计算过的，而且最终结束在我们想要的答案 <code>dp[m][n]</code>。<br>再举一例，回文子序列问题，详见前文「子序列问题模板」，我们通过过对 <code>dp</code> 数组的定义，确定了 base case 处在中间的对角线，<code>dp[i][j]</code> 需要从 <code>dp[i+1][j]</code>, <code>dp[i][j-1]</code>, <code>dp[i+1][j-1]</code> 转移而来，想要求的最终答案是 <code>dp[0][n-1]</code>，如下图：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/4.jpg"><br>这种情况根据刚才的两个原则，就可以有两种正确的遍历方式：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/5.jpg"><br>要么从左至右斜着遍历，要么从下向上从左到右遍历，这样才能保证每次 <code>dp[i][j]</code> 的左边、下边、左下边已经计算完毕，得到正确结果。<br>现在，你应该理解了这两个原则，主要就是看 base case 和最终结果的存储位置，保证遍历过程中使用的数据都是计算完毕的就行，有时候确实存在多种方法可以得到正确答案，可根据个人口味自行选择。</li></ul><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6">上一篇：动态规划解题框架</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88">下一篇：回溯算法解题框架</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共子序列</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>最长公共子序列（Longest Common Subsequence，简称 LCS）是一道非常经典的面试题目，因为它的解法是典型的二维动态规划，大部分比较困难的字符串问题都和这个问题一个套路，比如说编辑距离。而且，这个算法稍加改造就可以用于解决其他问题，所以说 LCS 算法是值得掌握的。<br>题目就是让我们求两个字符串的 LCS 长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入: str1 &#x3D; &quot;abcde&quot;, str2 &#x3D; &quot;ace&quot; <br>输出: 3  <br>解释: 最长公共子序列是 &quot;ace&quot;，它的长度是 3<br></code></pre></td></tr></table></figure><p>肯定有读者会问，为啥这个问题就是动态规划来解决呢？因为子序列类型的问题，穷举出所有可能的结果都不容易，而动态规划算法做的就是穷举 + 剪枝，它俩天生一对儿。所以可以说只要涉及子序列问题，十有八九都需要动态规划来解决，往这方面考虑就对了。<br>下面就来手把手分析一下，这道题目如何用动态规划技巧解决。</p><h3 id="一、动态规划思路"><a href="#一、动态规划思路" class="headerlink" title="一、动态规划思路"></a>一、动态规划思路</h3><p><strong>第一步，一定要明确 <code>dp</code> 数组的含义</strong>。对于两个字符串的动态规划问题，套路是通用的。<br>比如说对于字符串 <code>s1</code> 和 <code>s2</code>，一般来说都要构造一个这样的 DP table：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/LCS/dp.png"><br>为了方便理解此表，我们暂时认为索引是从 1 开始的，待会的代码中只要稍作调整即可。其中，<code>dp[i][j]</code> 的含义是：对于 <code>s1[1..i]</code> 和 <code>s2[1..j]</code>，它们的 LCS 长度是 <code>dp[i][j]</code>。<br>比如上图的例子，d[2][4] 的含义就是：对于 <code>&quot;ac&quot;</code> 和 <code>&quot;babc&quot;</code>，它们的 LCS 长度是 2。我们最终想得到的答案应该是 <code>dp[3][6]</code>。<br><strong>第二步，定义 base case。</strong><br>我们专门让索引为 0 的行和列表示空串，<code>dp[0][..]</code> 和 <code>dp[..][0]</code> 都应该初始化为 0，这就是 base case。<br>比如说，按照刚才 dp 数组的定义，<code>dp[0][3]=0</code> 的含义是：对于字符串 <code>&quot;&quot;</code> 和 <code>&quot;bab&quot;</code>，其 LCS 的长度为 0。因为有一个字符串是空串，它们的最长公共子序列的长度显然应该是 0。<br><strong>第三步，找状态转移方程。</strong><br>这是动态规划最难的一步，不过好在这种字符串问题的套路都差不多，权且借这道题来聊聊处理这类问题的思路。<br>状态转移说简单些就是做选择，比如说这个问题，是求 <code>s1</code> 和 <code>s2</code> 的最长公共子序列，不妨称这个子序列为 <code>lcs</code>。那么对于 <code>s1</code> 和 <code>s2</code> 中的每个字符，有什么选择？很简单，两种选择，要么在 <code>lcs</code> 中，要么不在。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/LCS/lcs.png"><br>这个「在」和「不在」就是选择，关键是，应该如何选择呢？这个需要动点脑筋：如果某个字符应该在 <code>lcs</code> 中，那么这个字符肯定同时存在于 <code>s1</code> 和 <code>s2</code> 中，因为 <code>lcs</code> 是最长<strong>公共</strong>子序列嘛。所以本题的思路是这样：<br>用两个指针 <code>i</code> 和 <code>j</code> 从后往前遍历 <code>s1</code> 和 <code>s2</code>，如果 <code>s1[i]==s2[j]</code>，那么这个字符<strong>一定在 <code>lcs</code> 中</strong>；否则的话，<code>s1[i]</code> 和 <code>s2[j]</code> 这两个字符<strong>至少有一个不在 <code>lcs</code> 中</strong>，需要丢弃一个。先看一下递归解法，比较容易理解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonSubsequence</span>(<span class="hljs-params">str1, str2</span>) -&gt; int:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">i, j</span>):</span><br>        <span class="hljs-comment"># 空串的 base case</span><br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span> <span class="hljs-keyword">or</span> j == <span class="hljs-number">-1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> str1[i] == str2[j]:<br>            <span class="hljs-comment"># 这边找到一个 lcs 的元素，继续往前找</span><br>            <span class="hljs-keyword">return</span> dp(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 谁能让 lcs 最长，就听谁的</span><br>            <span class="hljs-keyword">return</span> max(dp(i<span class="hljs-number">-1</span>, j), dp(i, j<span class="hljs-number">-1</span>))<br>        <br>    <span class="hljs-comment"># i 和 j 初始化为最后一个索引</span><br>    <span class="hljs-keyword">return</span> dp(len(str1)<span class="hljs-number">-1</span>, len(str2)<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><p>对于第一种情况，找到一个 <code>lcs</code> 中的字符，同时将 <code>i</code> <code>j</code> 向前移动一位，并给 <code>lcs</code> 的长度加一；对于后者，则尝试两种情况，取更大的结果。<br>其实这段代码就是暴力解法，我们可以通过备忘录或者 DP table 来优化时间复杂度，比如通过前文描述的 DP table 来解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonSubsequence</span>(<span class="hljs-params">str1, str2</span>) -&gt; int:</span><br>    m, n = len(str1), len(str2)<br>    <span class="hljs-comment"># 构建 DP table 和 base case</span><br>    dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m + <span class="hljs-number">1</span>)]<br>    <span class="hljs-comment"># 进行状态转移</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> str1[i - <span class="hljs-number">1</span>] == str2[j - <span class="hljs-number">1</span>]:<br>                <span class="hljs-comment"># 找到一个 lcs 中的字符</span><br>                dp[i][j] = <span class="hljs-number">1</span> + dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>        <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">-1</span>][<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><h3 id="二、疑难解答"><a href="#二、疑难解答" class="headerlink" title="二、疑难解答"></a>二、疑难解答</h3><p>对于 <code>s1[i]</code> 和 <code>s2[j]</code> 不相等的情况，<strong>至少有一个</strong>字符不在 <code>lcs</code> 中，会不会两个字符都不在呢？比如下面这种情况：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/LCS/1.png"><br>所以代码是不是应该考虑这种情况，改成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> str1[i - <span class="hljs-number">1</span>] == str2[j - <span class="hljs-number">1</span>]:<br>    <span class="hljs-comment"># ...</span><br><span class="hljs-keyword">else</span>:<br>    dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], <br>                   dp[i][j<span class="hljs-number">-1</span>],<br>                   dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])<br></code></pre></td></tr></table></figure><p>我一开始也有这种怀疑，其实可以这样改，也能得到正确答案，但是多此一举，因为 <code>dp[i-1][j-1]</code> 永远是三者中最小的，max 根本不可能取到它。<br>原因在于我们对 dp 数组的定义：对于 <code>s1[1..i]</code> 和 <code>s2[1..j]</code>，它们的 LCS 长度是 <code>dp[i][j]</code>。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/LCS/2.png"><br>这样一看，显然 <code>dp[i-1][j-1]</code> 对应的 <code>lcs</code> 长度不可能比前两种情况大，所以没有必要参与比较。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>对于两个字符串的动态规划问题，一般来说都是像本文一样定义 DP table，因为这样定义有一个好处，就是容易写出状态转移方程，<code>dp[i][j]</code> 的状态可以通过之前的状态推导出来：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/LCS/3.png"><br>找状态转移方程的方法是，思考每个状态有哪些「选择」，只要我们能用正确的逻辑做出正确的选择，算法就能够正确运行。</p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE">上一篇：动态规划之正则表达</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E6%95%88%E6%96%B9%E6%B3%95">下一篇：学习算法和刷题的思路指南</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编辑距离</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p>前几天看了一份鹅场的面试题，算法部分大半是动态规划，最后一题就是写一个计算编辑距离的函数，今天就专门写一篇文章来探讨一下这个问题。<br>我个人很喜欢编辑距离这个问题，因为它看起来十分困难，解法却出奇得简单漂亮，而且它是少有的比较实用的算法（是的，我承认很多算法问题都不太实用）。下面先来看下题目：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/editDistance/title.png"><br>为什么说这个问题难呢，因为显而易见，它就是难，让人手足无措，望而生畏。<br>为什么说它实用呢，因为前几天我就在日常生活中用到了这个算法。之前有一篇公众号文章由于疏忽，写错位了一段内容，我决定修改这部分内容让逻辑通顺。但是公众号文章最多只能修改 20 个字，且只支持增、删、替换操作（跟编辑距离问题一模一样），于是我就用算法求出了一个最优方案，只用了 16 步就完成了修改。<br>再比如高大上一点的应用，DNA 序列是由 A,G,C,T 组成的序列，可以类比成字符串。编辑距离可以衡量两个 DNA 序列的相似度，编辑距离越小，说明这两段 DNA 越相似，说不定这俩 DNA 的主人是远古近亲啥的。<br>下面言归正传，详细讲解一下编辑距离该怎么算，相信本文会让你有收获。</p><h3 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h3><p>编辑距离问题就是给我们两个字符串 <code>s1</code> 和 <code>s2</code>，只能用三种操作，让我们把 <code>s1</code> 变成 <code>s2</code>，求最少的操作数。需要明确的是，不管是把 <code>s1</code> 变成 <code>s2</code> 还是反过来，结果都是一样的，所以后文就以 <code>s1</code> 变成 <code>s2</code> 举例。<br>前文「最长公共子序列」说过，<strong>解决两个字符串的动态规划问题，一般都是用两个指针 <code>i,j</code> 分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模</strong>。<br>设两个字符串分别为 “rad” 和 “apple”，为了把 <code>s1</code> 变成 <code>s2</code>，算法会这样进行：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/editDistance/edit.gif"><br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/editDistance/1.jpg"><br>请记住这个 GIF 过程，这样就能算出编辑距离。关键在于如何做出正确的操作，稍后会讲。<br>根据上面的 GIF，可以发现操作不只有三个，其实还有第四个操作，就是什么都不要做（skip）。比如这个情况：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/editDistance/2.jpg"><br>因为这两个字符本来就相同，为了使编辑距离最小，显然不应该对它们有任何操作，直接往前移动 <code>i,j</code> 即可。<br>还有一个很容易处理的情况，就是 <code>j</code> 走完 <code>s2</code> 时，如果 <code>i</code> 还没走完 <code>s1</code>，那么只能用删除操作把 <code>s1</code> 缩短为 <code>s2</code>。比如这个情况：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/editDistance/3.jpg"><br>类似的，如果 <code>i</code> 走完 <code>s1</code> 时 <code>j</code> 还没走完了 <code>s2</code>，那就只能用插入操作把 <code>s2</code> 剩下的字符全部插入 <code>s1</code>。等会会看到，这两种情况就是算法的 <strong>base case</strong>。<br>下面详解一下如何将思路转换成代码，坐稳，要发车了。</p><h3 id="二、代码详解"><a href="#二、代码详解" class="headerlink" title="二、代码详解"></a>二、代码详解</h3><p>先梳理一下之前的思路：<br>base case 是 <code>i</code> 走完 <code>s1</code> 或 <code>j</code> 走完 <code>s2</code>，可以直接返回另一个字符串剩下的长度。<br>对于每对儿字符 <code>s1[i]</code> 和 <code>s2[j]</code>，可以有四种操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> s1[i] == s2[j]:<br>    啥都别做（skip）<br>    i, j 同时向前移动<br><span class="hljs-keyword">else</span>:<br>    三选一：<br>        插入（insert）<br>        删除（delete）<br>        替换（replace）<br></code></pre></td></tr></table></figure><p>有这个框架，问题就已经解决了。读者也许会问，这个「三选一」到底该怎么选择呢？很简单，全试一遍，哪个操作最后得到的编辑距离最小，就选谁。这里需要递归技巧，理解需要点技巧，先看下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDistance</span>(<span class="hljs-params">s1, s2</span>) -&gt; int:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">i, j</span>):</span><br>        <span class="hljs-comment"># base case</span><br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span>: <span class="hljs-keyword">return</span> j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> j == <span class="hljs-number">-1</span>: <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">if</span> s1[i] == s2[j]:<br>            <span class="hljs-keyword">return</span> dp(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 啥都不做</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> min(<br>                dp(i, j - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>,    <span class="hljs-comment"># 插入</span><br>                dp(i - <span class="hljs-number">1</span>, j) + <span class="hljs-number">1</span>,    <span class="hljs-comment"># 删除</span><br>                dp(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span> <span class="hljs-comment"># 替换</span><br>            )<br>    <br>    <span class="hljs-comment"># i，j 初始化指向最后一个索引</span><br>    <span class="hljs-keyword">return</span> dp(len(s1) - <span class="hljs-number">1</span>, len(s2) - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>下面来详细解释一下这段递归代码，base case 应该不用解释了，主要解释一下递归部分。<br>都说递归代码的可解释性很好，这是有道理的，只要理解函数的定义，就能很清楚地理解算法的逻辑。我们这里 dp(i, j) 函数的定义是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">i, j</span>) -&gt; int</span><br><span class="hljs-function"># 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离</span><br></code></pre></td></tr></table></figure><p><strong>记住这个定义</strong>之后，先来看这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> s1[i] == s2[j]:<br>    <span class="hljs-keyword">return</span> dp(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 啥都不做</span><br><span class="hljs-comment"># 解释：</span><br><span class="hljs-comment"># 本来就相等，不需要任何操作</span><br><span class="hljs-comment"># s1[0..i] 和 s2[0..j] 的最小编辑距离等于</span><br><span class="hljs-comment"># s1[0..i-1] 和 s2[0..j-1] 的最小编辑距离</span><br><span class="hljs-comment"># 也就是说 dp(i, j) 等于 dp(i-1, j-1)</span><br></code></pre></td></tr></table></figure><p>如果 <code>s1[i]！=s2[j]</code>，就要对三个操作递归了，稍微需要点思考：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">dp(i, j - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>,    <span class="hljs-comment"># 插入</span><br><span class="hljs-comment"># 解释：</span><br><span class="hljs-comment"># 我直接在 s1[i] 插入一个和 s2[j] 一样的字符</span><br><span class="hljs-comment"># 那么 s2[j] 就被匹配了，前移 j，继续跟 i 对比</span><br><span class="hljs-comment"># 别忘了操作数加一</span><br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/editDistance/insert.gif"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">dp(i - <span class="hljs-number">1</span>, j) + <span class="hljs-number">1</span>,    <span class="hljs-comment"># 删除</span><br><span class="hljs-comment"># 解释：</span><br><span class="hljs-comment"># 我直接把 s[i] 这个字符删掉</span><br><span class="hljs-comment"># 前移 i，继续跟 j 对比</span><br><span class="hljs-comment"># 操作数加一</span><br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/editDistance/delete.gif"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">dp(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span> <span class="hljs-comment"># 替换</span><br><span class="hljs-comment"># 解释：</span><br><span class="hljs-comment"># 我直接把 s1[i] 替换成 s2[j]，这样它俩就匹配了</span><br><span class="hljs-comment"># 同时前移 i，j 继续对比</span><br><span class="hljs-comment"># 操作数加一</span><br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/editDistance/replace.gif"><br>现在，你应该完全理解这段短小精悍的代码了。还有点小问题就是，这个解法是暴力解法，存在重叠子问题，需要用动态规划技巧来优化。<br><strong>怎么能一眼看出存在重叠子问题呢</strong>？前文「动态规划之正则表达式」有提过，这里再简单提一下，需要抽象出本文算法的递归框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">i, j</span>):</span><br>    dp(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) <span class="hljs-comment">#1</span><br>    dp(i, j - <span class="hljs-number">1</span>)     <span class="hljs-comment">#2</span><br>    dp(i - <span class="hljs-number">1</span>, j)     <span class="hljs-comment">#3</span><br></code></pre></td></tr></table></figure><p>对于子问题 <code>dp(i-1, j-1)</code>，如何通过原问题 <code>dp(i, j)</code> 得到呢？有不止一条路径，比如 <code>dp(i, j) -&gt; #1</code> 和 <code>dp(i, j) -&gt; #2 -&gt; #3</code>。一旦发现一条重复路径，就说明存在巨量重复路径，也就是重叠子问题。</p><h3 id="三、动态规划优化"><a href="#三、动态规划优化" class="headerlink" title="三、动态规划优化"></a>三、动态规划优化</h3><p>对于重叠子问题呢，前文「动态规划详解」详细介绍过，优化方法无非是备忘录或者 DP table。<br>备忘录很好加，原来的代码稍加修改即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDistance</span>(<span class="hljs-params">s1, s2</span>) -&gt; int:</span><br>    memo = dict() <span class="hljs-comment"># 备忘录</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">i, j</span>):</span><br>        <span class="hljs-keyword">if</span> (i, j) <span class="hljs-keyword">in</span> memo: <br>            <span class="hljs-keyword">return</span> memo[(i, j)]<br>        ...<br>        <br>        <span class="hljs-keyword">if</span> s1[i] == s2[j]:<br>            memo[(i, j)] = ...  <br>        <span class="hljs-keyword">else</span>:<br>            memo[(i, j)] = ...<br>        <span class="hljs-keyword">return</span> memo[(i, j)]<br>    <br>    <span class="hljs-keyword">return</span> dp(len(s1) - <span class="hljs-number">1</span>, len(s2) - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><strong>主要说下 DP table 的解法</strong>：<br>首先明确 dp 数组的含义，dp 数组是一个二维数组，长这样：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/editDistance/dp.jpg"><br>有了之前递归解法的铺垫，应该很容易理解。<code>dp[..][0]</code> 和 <code>dp[0][..]</code> 对应 base case，<code>dp[i][j]</code> 的含义和之前的 dp 函数类似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">i, j</span>) -&gt; int</span><br><span class="hljs-function"># 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离</span><br><span class="hljs-function">dp[i-1][j-1]</span><br><span class="hljs-function"># 存储 s1[0..i] 和 s2[0..j] 的最小编辑距离</span><br></code></pre></td></tr></table></figure><p>dp 函数的 base case 是 <code>i,j</code> 等于 -1，而数组索引至少是 0，所以 dp 数组会偏移一位。<br>既然 dp 数组和递归 dp 函数含义一样，也就可以直接套用之前的思路写代码，<strong>唯一不同的是，DP table 是自底向上求解，递归解法是自顶向下求解</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = s1.length(), n = s2.length();<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// base case </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        dp[<span class="hljs-number">0</span>][j] = j;<br>    <span class="hljs-comment">// 自底向上求解</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (s1.charAt(i-<span class="hljs-number">1</span>) == s2.charAt(j-<span class="hljs-number">1</span>))<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span>               <br>                dp[i][j] = min(<br>                    dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>,<br>                    dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>,<br>                    dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                );<br>    <span class="hljs-comment">// 储存着整个 s1 和 s2 的最小编辑距离</span><br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Math.min(a, Math.min(b, c));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、扩展延伸"><a href="#三、扩展延伸" class="headerlink" title="三、扩展延伸"></a>三、扩展延伸</h3><p>一般来说，处理两个字符串的动态规划问题，都是按本文的思路处理，建立 DP table。为什么呢，因为易于找出状态转移的关系，比如编辑距离的 DP table：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/editDistance/4.jpg"><br>还有一个细节，既然每个 <code>dp[i][j]</code> 只和它附近的三个状态有关，空间复杂度是可以压缩成 $O(min(M, N))$ 的（M，N 是两个字符串的长度）。不难，但是可解释性大大降低，读者可以自己尝试优化一下。<br>你可能还会问，<strong>这里只求出了最小的编辑距离，那具体的操作是什么</strong>？你之前举的修改公众号文章的例子，只有一个最小编辑距离肯定不够，还得知道具体怎么修改才行。<br>这个其实很简单，代码稍加修改，给 dp 数组增加额外的信息即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// int[][] dp;</span><br>Node[][] dp;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-keyword">int</span> choice;<br>    <span class="hljs-comment">// 0 代表啥都不做</span><br>    <span class="hljs-comment">// 1 代表插入</span><br>    <span class="hljs-comment">// 2 代表删除</span><br>    <span class="hljs-comment">// 3 代表替换</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>val</code> 属性就是之前的 dp 数组的数值，<code>choice</code> 属性代表操作。在做最优选择时，顺便把操作记录下来，然后就从结果反推具体操作。<br>我们的最终结果不是 <code>dp[m][n]</code> 吗，这里的 <code>val</code> 存着最小编辑距离，<code>choice</code> 存着最后一个操作，比如说是插入操作，那么就可以左移一格：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/editDistance/5.jpg"><br>重复此过程，可以一步步回到起点 <code>dp[0][0]</code>，形成一条路径，按这条路径上的操作进行编辑，就是最佳方案。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/editDistance/6.jpg"></p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">上一篇：动态规划设计：最长递增子序列</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98">下一篇：经典动态规划问题：高楼扔鸡蛋</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法之区间调度问题</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法之区间调度问题"><a href="#贪心算法之区间调度问题" class="headerlink" title="贪心算法之区间调度问题"></a>贪心算法之区间调度问题</h1><p>什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。<br>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。<br>什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。<br>比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。<br>然而，大部分问题明显不具有贪心选择性质。比如打斗地主，对手出对儿三，按照贪心策略，你应该出尽可能小的牌刚好压制住对方，但现实情况我们甚至可能会出王炸。这种情况就不能用贪心算法，而得使用动态规划解决，参见前文「动态规划解决博弈问题」。</p><h3 id="一、问题概述"><a href="#一、问题概述" class="headerlink" title="一、问题概述"></a>一、问题概述</h3><p>言归正传，本文解决一个很经典的贪心算法问题 Interval Scheduling（区间调度问题）。给你很多形如 <code>[start, end]</code> 的闭区间，请你设计一个算法，<strong>算出这些区间中最多有几个互不相交的区间</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">intervalSchedule</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intvs)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>举个例子，<code>intvs = [[1,3], [2,4], [3,6]]</code>，这些区间最多有 2 个区间互不相交，即 <code>[[1,3], [3,6]]</code>，你的算法应该返回 2。注意边界相同并不算相交。<br>这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 <code>[start, end]</code> 表示开始和结束的时间，请问你今天<strong>最多能参加几个活动呢？</strong>显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。</p><h3 id="二、贪心解法"><a href="#二、贪心解法" class="headerlink" title="二、贪心解法"></a>二、贪心解法</h3><p>这个问题有许多看起来不错的贪心思路，却都不能得到正确答案。比如说：<br>也许我们可以每次选择可选区间中开始最早的那个？但是可能存在某些区间开始很早，但是很长，使得我们错误地错过了一些短的区间。或者我们每次选择可选区间中最短的那个？或者选择出现冲突最少的那个区间？这些方案都能很容易举出反例，不是正确的方案。<br>正确的思路其实很简单，可以分为以下三步：</p><ol><li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中<strong>结束最早的</strong>（end 最小）。</li><li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li><li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。<br>把这个思路实现成算法的话，可以按每个区间的 <code>end</code> 数值升序排序，因为这样处理之后实现步骤 1 和步骤 2 都方便很多:<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/interval/1.gif" alt="1"><br>现在来实现算法，对于步骤 1，由于我们预先按照 <code>end</code> 排了序，所以选择 x 是很容易的。关键在于，如何去除与 x 相交的区间，选择下一轮循环的 x 呢？</li></ol><p><strong>由于我们事先排了序</strong>，不难发现所有与 x 相交的区间必然会与 x 的 <code>end</code> 相交；如果一个区间不想与 x 的 <code>end</code> 相交，它的 <code>start</code> 必须要大于（或等于）x 的 <code>end</code>：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/interval/2.jpg" alt="2"><br>看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">intervalSchedule</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intvs)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (intvs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 按 end 升序排序</span><br>    Arrays.sort(intvs, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 至少有一个区间不相交</span><br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 排序后，第一个区间就是 x</span><br>    <span class="hljs-keyword">int</span> x_end = intvs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] interval : intvs) &#123;<br>        <span class="hljs-keyword">int</span> start = interval[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (start &gt;= x_end) &#123;<br>            <span class="hljs-comment">// 找到下一个选择的区间了</span><br>            count++;<br>            x_end = interval[<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、应用举例"><a href="#三、应用举例" class="headerlink" title="三、应用举例"></a>三、应用举例</h3><p>下面举例几道 LeetCode 题目应用一下区间调度算法。<br>第 435 题，无重叠区间：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/interval/title1.png" alt="title1"><br>我们已经会求最多有几个区间不会重叠了，那么剩下的不就是至少需要去除的区间吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = intervals.length;<br>    <span class="hljs-keyword">return</span> n - intervalSchedule(intervals);<br>&#125;<br></code></pre></td></tr></table></figure><p>第 452 题，用最少的箭头射爆气球：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/interval/title2.png" alt="title2"><br>其实稍微思考一下，这个问题和区间调度算法一模一样！如果最多有 <code>n</code> 个不重叠的区间，那么就至少需要 <code>n</code> 个箭头穿透所有区间：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/interval/3.jpg" alt="3"><br>只是有一点不一样，在 <code>intervalSchedule</code> 算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/interval/4.jpg" alt="4"><br>所以只要将之前的算法稍作修改，就是这道题目的答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intvs)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] interval : intvs) &#123;<br>        <span class="hljs-keyword">int</span> start = interval[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 把 &gt;= 改成 &gt; 就行了</span><br>        <span class="hljs-keyword">if</span> (start &gt; x_end) &#123;<br>            count++;<br>            x_end = interval[<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>这么做的原因也不难理解，因为现在边界接触也算重叠，所以 <code>start == x_end</code> 时不能更新 x。</p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98">上一篇：动态规划之博弈问题</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8BKMP%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95">下一篇：动态规划之KMP字符匹配算法</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高楼扔鸡蛋进阶</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E8%BF%9B%E9%98%B6/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="经典动态规划问题：高楼扔鸡蛋（进阶）"><a href="#经典动态规划问题：高楼扔鸡蛋（进阶）" class="headerlink" title="经典动态规划问题：高楼扔鸡蛋（进阶）"></a>经典动态规划问题：高楼扔鸡蛋（进阶）</h1><p>上篇文章聊了高楼扔鸡蛋问题，讲了一种效率不是很高，但是较为容易理解的动态规划解法。后台很多读者问如何更高效地解决这个问题，今天就谈两种思路，来优化一下这个问题，分别是二分查找优化和重新定义状态转移。<br>如果还不知道高楼扔鸡蛋问题的读者可以看下「经典动态规划：高楼扔鸡蛋」，那篇文章详解了题目的含义和基本的动态规划解题思路，请确保理解前文，因为今天的优化都是基于这个基本解法的。<br>二分搜索的优化思路也许是我们可以尽力尝试写出的，而修改状态转移的解法可能是不容易想到的，可以借此见识一下动态规划算法设计的玄妙，当做思维拓展。</p><h3 id="二分搜索优化"><a href="#二分搜索优化" class="headerlink" title="二分搜索优化"></a>二分搜索优化</h3><p>之前提到过这个解法，核心是因为状态转移方程的单调性，这里可以具体展开看看。<br>首先简述一下原始动态规划的思路：<br>1、暴力穷举尝试在所有楼层 <code>1 &lt;= i &lt;= N</code> 扔鸡蛋，每次选择尝试次数<strong>最少</strong>的那一层；<br>2、每次扔鸡蛋有两种可能，要么碎，要么没碎；<br>3、如果鸡蛋碎了，<code>F</code> 应该在第 <code>i</code> 层下面，否则，<code>F</code> 应该在第 <code>i</code> 层上面；<br>4、鸡蛋是碎了还是没碎，取决于哪种情况下尝试次数<strong>更多</strong>，因为我们想求的是最坏情况下的结果。<br>核心的状态转移代码是这段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 当前状态为 K 个鸡蛋，面对 N 层楼</span><br><span class="hljs-comment"># 返回这个状态下的最优结果</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">K, N</span>):</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> &lt;= i &lt;= N:<br>        <span class="hljs-comment"># 最坏情况下的最少扔鸡蛋次数</span><br>        res = min(res, <br>                  max( <br>                        dp(K - <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>), <span class="hljs-comment"># 碎</span><br>                        dp(K, N - i)      <span class="hljs-comment"># 没碎</span><br>                     ) + <span class="hljs-number">1</span> <span class="hljs-comment"># 在第 i 楼扔了一次</span><br>                 )<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>这个 for 循环就是下面这个状态转移方程的具体代码实现：<br>$$ dp(K, N) = \min_{0 &lt;= i &lt;= N}{\max{dp(K - 1, i - 1), dp(K, N - i)} + 1}$$<br>如果能够理解这个状态转移方程，那么就很容易理解二分查找的优化思路。<br>首先我们根据 <code>dp(K, N)</code> 数组的定义（有 <code>K</code> 个鸡蛋面对 <code>N</code> 层楼，最少需要扔几次），<strong>很容易知道 <code>K</code> 固定时，这个函数随着 <code>N</code> 的增加一定是单调递增的</strong>，无论你策略多聪明，楼层增加测试次数一定要增加。<br>那么注意 <code>dp(K - 1, i - 1)</code> 和 <code>dp(K, N - i)</code> 这两个函数，其中 <code>i</code> 是从 1 到 <code>N</code> 单增的，如果我们固定 <code>K</code> 和 <code>N</code>，<strong>把这两个函数看做关于 <code>i</code> 的函数，前者随着 <code>i</code> 的增加应该也是单调递增的，而后者随着 <code>i</code> 的增加应该是单调递减的</strong>：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%89%94%E9%B8%A1%E8%9B%8B/2.jpg"><br>这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这两条直线交点，也就是红色折线的最低点嘛。<br>我们前文「二分查找只能用来查找元素吗」讲过，二分查找的运用很广泛，形如下面这种形式的 for 循环代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (isOK(i))<br>        <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>都很有可能可以运用二分查找来优化线性搜索的复杂度，回顾这两个 <code>dp</code> 函数的曲线，我们要找的最低点其实就是这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>    <span class="hljs-keyword">if</span> (dp(K - <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>) == dp(K, N - i))<br>        <span class="hljs-keyword">return</span> dp(K, N - i);<br>&#125;<br></code></pre></td></tr></table></figure><p>熟悉二分搜索的同学肯定敏感地想到了，这不就是相当于求 Valley（山谷）值嘛，可以用二分查找来快速寻找这个点的，直接看代码吧，整体的思路还是一样，只是加快了搜索速度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">superEggDrop</span>(<span class="hljs-params">self, K: int, N: int</span>) -&gt; int:</span><br>        <br>    memo = dict()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">K, N</span>):</span><br>        <span class="hljs-keyword">if</span> K == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> N<br>        <span class="hljs-keyword">if</span> N == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> (K, N) <span class="hljs-keyword">in</span> memo:<br>            <span class="hljs-keyword">return</span> memo[(K, N)]<br>                            <br>        <span class="hljs-comment"># for 1 &lt;= i &lt;= N:</span><br>        <span class="hljs-comment">#     res = min(res, </span><br>        <span class="hljs-comment">#             max( </span><br>        <span class="hljs-comment">#                 dp(K - 1, i - 1), </span><br>        <span class="hljs-comment">#                 dp(K, N - i)      </span><br>        <span class="hljs-comment">#                 ) + 1 </span><br>        <span class="hljs-comment">#             )</span><br>        res = float(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>        <span class="hljs-comment"># 用二分搜索代替线性搜索</span><br>        lo, hi = <span class="hljs-number">1</span>, N<br>        <span class="hljs-keyword">while</span> lo &lt;= hi:<br>            mid = (lo + hi) // <span class="hljs-number">2</span><br>            broken = dp(K - <span class="hljs-number">1</span>, mid - <span class="hljs-number">1</span>) <span class="hljs-comment"># 碎</span><br>            not_broken = dp(K, N - mid) <span class="hljs-comment"># 没碎</span><br>            <span class="hljs-comment"># res = min(max(碎，没碎) + 1)</span><br>            <span class="hljs-keyword">if</span> broken &gt; not_broken:<br>                hi = mid - <span class="hljs-number">1</span><br>                res = min(res, broken + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                lo = mid + <span class="hljs-number">1</span><br>                res = min(res, not_broken + <span class="hljs-number">1</span>)<br>        memo[(K, N)] = res<br>        <span class="hljs-keyword">return</span> res<br>    <br>    <span class="hljs-keyword">return</span> dp(K, N)<br></code></pre></td></tr></table></figure><p>这个算法的时间复杂度是多少呢？<strong>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度</strong>。<br>函数本身的复杂度就是忽略递归部分的复杂度，这里 <code>dp</code> 函数中用了一个二分搜索，所以函数本身的复杂度是 O(logN)。<br>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。<br>所以算法的总时间复杂度是 O(K*N*logN), 空间复杂度 O(KN)。效率上比之前的算法 O(KN^2) 要高效一些。</p><h3 id="重新定义状态转移"><a href="#重新定义状态转移" class="headerlink" title="重新定义状态转移"></a>重新定义状态转移</h3><p>前文「不同定义有不同解法」就提过，找动态规划的状态转移本就是见仁见智，比较玄学的事情，不同的状态定义可以衍生出不同的解法，其解法和复杂程度都可能有巨大差异。这里就是一个很好的例子。<br>再回顾一下我们之前定义的 <code>dp</code> 数组含义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">k, n</span>) -&gt; int</span><br><span class="hljs-function"># 当前状态为 k 个鸡蛋，面对 n 层楼</span><br><span class="hljs-function"># 返回这个状态下最少的扔鸡蛋次数</span><br></code></pre></td></tr></table></figure><p>用 dp 数组表示的话也是一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[k][n] = m<br><span class="hljs-comment"># 当前状态为 k 个鸡蛋，面对 n 层楼</span><br><span class="hljs-comment"># 这个状态下最少的扔鸡蛋次数为 m</span><br></code></pre></td></tr></table></figure><p>按照这个定义，就是<strong>确定当前的鸡蛋个数和面对的楼层数，就知道最小扔鸡蛋次数</strong>。最终我们想要的答案就是 <code>dp(K, N)</code> 的结果。<br>这种思路下，肯定要穷举所有可能的扔法的，用二分搜索优化也只是做了「剪枝」，减小了搜索空间，但本质思路没有变，还是穷举。<br>现在，我们稍微修改 <code>dp</code> 数组的定义，<strong>确定当前的鸡蛋个数和最多允许的扔鸡蛋次数，就知道能够确定 <code>F</code> 的最高楼层数</strong>。具体来说是这个意思：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[k][m] = n<br><span class="hljs-comment"># 当前有 k 个鸡蛋，可以尝试扔 m 次鸡蛋</span><br><span class="hljs-comment"># 这个状态下，最坏情况下最多能确切测试一栋 n 层的楼</span><br><span class="hljs-comment"># 比如说 dp[1][7] = 7 表示：</span><br><span class="hljs-comment"># 现在有 1 个鸡蛋，允许你扔 7 次;</span><br><span class="hljs-comment"># 这个状态下最多给你 7 层楼，</span><br><span class="hljs-comment"># 使得你可以确定楼层 F 使得鸡蛋恰好摔不碎</span><br><span class="hljs-comment"># （一层一层线性探查嘛）</span><br></code></pre></td></tr></table></figure><p>这其实就是我们原始思路的一个「反向」版本，我们先不管这种思路的状态转移怎么写，先来思考一下这种定义之下，最终想求的答案是什么？<br>我们最终要求的其实是扔鸡蛋次数 <code>m</code>，但是这时候 <code>m</code> 在状态之中而不是 <code>dp</code> 数组的结果，可以这样处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">superEggDrop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> K, <span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (dp[K][m] &lt; N) &#123;<br>        m++;<br>        <span class="hljs-comment">// 状态转移...</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目不是<strong>给你 <code>K</code> 鸡蛋，<code>N</code> 层楼，让你求最坏情况下最少的测试次数 <code>m</code></strong> 吗？<code>while</code> 循环结束的条件是 <code>dp[K][m] == N</code>，也就是<strong>给你 <code>K</code> 个鸡蛋，测试 <code>m</code> 次，最坏情况下最多能测试 <code>N</code> 层楼</strong>。<br>注意看这两段描述，是完全一样的！所以说这样组织代码是正确的，关键就是状态转移方程怎么找呢？还得从我们原始的思路开始讲。之前的解法配了这样图帮助大家理解状态转移思路：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%89%94%E9%B8%A1%E8%9B%8B/1.jpg"><br>这个图描述的仅仅是某一个楼层 <code>i</code>，原始解法还得线性或者二分扫描所有楼层，要求最大值、最小值。但是现在这种 <code>dp</code> 定义根本不需要这些了，基于下面两个事实：<br><strong>1、无论你在哪层楼扔鸡蛋，鸡蛋只可能摔碎或者没摔碎，碎了的话就测楼下，没碎的话就测楼上</strong>。<br><strong>2、无论你上楼还是下楼，总的楼层数 = 楼上的楼层数 + 楼下的楼层数 + 1（当前这层楼）</strong>。<br>根据这个特点，可以写出下面的状态转移方程：<br><code>dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1</code><br>**<code>dp[k][m - 1]</code> 就是楼上的楼层数<strong>，因为鸡蛋个数 <code>k</code> 不变，也就是鸡蛋没碎，扔鸡蛋次数 <code>m</code> 减一；<br>**<code>dp[k - 1][m - 1]</code> 就是楼下的楼层数</strong>，因为鸡蛋个数 <code>k</code> 减一，也就是鸡蛋碎了，同时扔鸡蛋次数 <code>m</code> 减一。<br>PS：这个 <code>m</code> 为什么要减一而不是加一？之前定义得很清楚，这个 <code>m</code> 是一个允许的次数上界，而不是扔了几次。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%89%94%E9%B8%A1%E8%9B%8B/3.jpg"><br>至此，整个思路就完成了，只要把状态转移方程填进框架即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">superEggDrop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> K, <span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>    <span class="hljs-comment">// m 最多不会超过 N 次（线性扫描）</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[K + <span class="hljs-number">1</span>][N + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// base case:</span><br>    <span class="hljs-comment">// dp[0][..] = 0</span><br>    <span class="hljs-comment">// dp[..][0] = 0</span><br>    <span class="hljs-comment">// Java 默认初始化数组都为 0</span><br>    <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (dp[K][m] &lt; N) &#123;<br>        m++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= K; k++)<br>            dp[k][m] = dp[k][m - <span class="hljs-number">1</span>] + dp[k - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你还觉得这段代码有点难以理解，其实它就等同于这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">1</span>; dp[K][m] &lt; N; m++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= K; k++)<br>        dp[k][m] = dp[k][m - <span class="hljs-number">1</span>] + dp[k - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>看到这种代码形式就熟悉多了吧，因为我们要求的不是 <code>dp</code> 数组里的值，而是某个符合条件的索引 <code>m</code>，所以用 <code>while</code> 循环来找到这个 <code>m</code> 而已。<br>这个算法的时间复杂度是多少？很明显就是两个嵌套循环的复杂度 O(KN)。<br>另外注意到 <code>dp[m][k]</code> 转移只和左边和左上的两个状态有关，所以很容易优化成一维 <code>dp</code> 数组，这里就不写了。</p><h3 id="还可以再优化"><a href="#还可以再优化" class="headerlink" title="还可以再优化"></a>还可以再优化</h3><p>再往下就要用一些数学方法了，不具体展开，就简单提一下思路吧。<br>在刚才的思路之上，<strong>注意函数 <code>dp(m, k)</code> 是随着 <code>m</code> 单增的，因为鸡蛋个数 <code>k</code> 不变时，允许的测试次数越多，可测试的楼层就越高</strong>。<br>这里又可以借助二分搜索算法快速逼近 <code>dp[K][m] == N</code> 这个终止条件，时间复杂度进一步下降为 O(KlogN)，我们可以设 <code>g(k, m) =</code>……<br>算了算了，打住吧。我觉得我们能够写出 O(K*N*logN) 的二分优化算法就行了，后面的这些解法呢，听个响鼓个掌就行了，把欲望限制在能力的范围之内才能拥有快乐！<br>不过可以肯定的是，根据二分搜索代替线性扫描 <code>m</code> 的取值，代码的大致框架肯定是修改穷举 <code>m</code> 的 for 循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 把线性搜索改成二分搜索</span><br><span class="hljs-comment">// for (int m = 1; dp[K][m] &lt; N; m++)</span><br><span class="hljs-keyword">int</span> lo = <span class="hljs-number">1</span>, hi = N;<br><span class="hljs-keyword">while</span> (lo &lt; hi) &#123;<br>    <span class="hljs-keyword">int</span> mid = (lo + hi) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (... &lt; N) &#123;<br>        lo = ...<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        hi = ...<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= K; k++)<br>        <span class="hljs-comment">// 状态转移方程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>简单总结一下吧，第一个二分优化是利用了 <code>dp</code> 函数的单调性，用二分查找技巧快速搜索答案；第二种优化是巧妙地修改了状态转移方程，简化了求解了流程，但相应的，解题逻辑比较难以想到；后续还可以用一些数学方法和二分搜索进一步优化第二种解法，不过看了看镜子中的发量，算了。<br>本文终，希望对你有一点启发。</p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98">上一篇：经典动态规划问题：高楼扔鸡蛋</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF">下一篇：动态规划之子序列问题解题模板</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高楼扔鸡蛋问题</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="经典动态规划问题：高楼扔鸡蛋"><a href="#经典动态规划问题：高楼扔鸡蛋" class="headerlink" title="经典动态规划问题：高楼扔鸡蛋"></a>经典动态规划问题：高楼扔鸡蛋</h1><p>今天要聊一个很经典的算法问题，若干层楼，若干个鸡蛋，让你算出最少的尝试次数，找到鸡蛋恰好摔不碎的那层楼。国内大厂以及谷歌脸书面试都经常考察这道题，只不过他们觉得扔鸡蛋太浪费，改成扔杯子，扔破碗什么的。<br>具体的问题等会再说，但是这道题的解法技巧很多，光动态规划就好几种效率不同的思路，最后还有一种极其高效数学解法。秉承咱们号一贯的作风，拒绝奇技淫巧，拒绝过于诡异的技巧，因为这些技巧无法举一反三，学了也不划算。<br>下面就来用我们一直强调的动态规划通用思路来研究一下这道题。</p><h3 id="一、解析题目"><a href="#一、解析题目" class="headerlink" title="一、解析题目"></a>一、解析题目</h3><p>题目是这样：你面前有一栋从 1 到 <code>N</code> 共 <code>N</code> 层的楼，然后给你 <code>K</code> 个鸡蛋（<code>K</code> 至少为 1）。现在确定这栋楼存在楼层 <code>0 &lt;= F &lt;= N</code>，在这层楼将鸡蛋扔下去，鸡蛋<strong>恰好没摔碎</strong>（高于 <code>F</code> 的楼层都会碎，低于 <code>F</code> 的楼层都不会碎）。现在问你，<strong>最坏</strong>情况下，你<strong>至少</strong>要扔几次鸡蛋，才能<strong>确定</strong>这个楼层 <code>F</code> 呢？<br>也就是让你找摔不碎鸡蛋的最高楼层 <code>F</code>，但什么叫「最坏情况」下「至少」要扔几次呢？我们分别举个例子就明白了。<br>比方说<strong>现在先不管鸡蛋个数的限制</strong>，有 7 层楼，你怎么去找鸡蛋恰好摔碎的那层楼？<br>最原始的方式就是线性扫描：我先在 1 楼扔一下，没碎，我再去 2 楼扔一下，没碎，我再去 3 楼……<br>以这种策略，<strong>最坏</strong>情况应该就是我试到第 7 层鸡蛋也没碎（<code>F = 7</code>），也就是我扔了 7 次鸡蛋。<br>先在你应该理解什么叫做「最坏情况」下了，<strong>鸡蛋破碎一定发生在搜索区间穷尽时</strong>，不会说你在第 1 层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。<br>现在再来理解一下什么叫「至少」要扔几次。依然不考虑鸡蛋个数限制，同样是 7 层楼，我们可以优化策略。<br>最好的策略是使用二分查找思路，我先去第 <code>(1 + 7) / 2 = 4</code> 层扔一下：<br>如果碎了说明 <code>F</code> 小于 4，我就去第 <code>(1 + 3) / 2 = 2</code> 层试……<br>如果没碎说明 <code>F</code> 大于等于 4，我就去第 <code>(5 + 7) / 2 = 6</code> 层试……<br>以这种策略，<strong>最坏</strong>情况应该是试到第 7 层鸡蛋还没碎（<code>F = 7</code>），或者鸡蛋一直碎到第 1 层（<code>F = 0</code>）。然而无论那种最坏情况，只需要试 <code>log7</code> 向上取整等于 3 次，比刚才尝试 7 次要少，这就是所谓的<strong>至少</strong>要扔几次。<br>PS：这有点像 Big O 表示法计算​算法的复杂度。<br>实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，<strong>现在给你了鸡蛋个数的限制 <code>K</code>，直接使用二分思路就不行了</strong>。<br>比如说只给你 1 个鸡蛋，7 层楼，你敢用二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，但如果碎了你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层 <code>F</code> 了。这种情况下只能用线性扫描的方法，算法返回结果应该是 7。<br>有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？<br>很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。<br>如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次​。<br>最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。<br>说了这么多废话，就是确保大家理解了题目的意思，而且认识到这个题目确实复杂，就连我们手算都不容易，如何用算法解决呢？</p><h3 id="二、思路分析"><a href="#二、思路分析" class="headerlink" title="二、思路分析"></a>二、思路分析</h3><p>对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。<br><strong>「状态」很明显，就是当前拥有的鸡蛋数 <code>K</code> 和需要测试的楼层数 <code>N</code>**。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。<br>**「选择」其实就是去选择哪层楼扔鸡蛋</strong>。回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。<br>现在明确了「状态」和「选择」，<strong>动态规划的基本思路就形成了</strong>：肯定是个二维的 <code>dp</code> 数组或者带有两个状态参数的 <code>dp</code> 函数来表示状态转移；外加一个 for 循环来遍历所有选择，择最优的选择更新状态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 当前状态为 K 个鸡蛋，面对 N 层楼</span><br><span class="hljs-comment"># 返回这个状态下的最优结果</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">K, N</span>):</span><br>    int res<br>    <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> &lt;= i &lt;= N:<br>        res = min(res, 这次在第 i 层楼扔鸡蛋)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。<br>我们选择在第 <code>i</code> 层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。<strong>注意，这时候状态转移就来了</strong>：<br><strong>如果鸡蛋碎了</strong>，那么鸡蛋的个数 <code>K</code> 应该减一，搜索的楼层区间应该从 <code>[1..N]</code> 变为 <code>[1..i-1]</code> 共 <code>i-1</code> 层楼；<br><strong>如果鸡蛋没碎</strong>，那么鸡蛋的个数 <code>K</code> 不变，搜索的楼层区间应该从  <code>[1..N]</code> 变为 <code>[i+1..N]</code> 共 <code>N-i</code> 层楼。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%89%94%E9%B8%A1%E8%9B%8B/1.jpg"><br>PS：细心的读者可能会问，在第i层楼扔鸡蛋如果没碎，楼层的搜索区间缩小至上面的楼层，是不是应该包含第i层楼呀？不必，因为已经包含了。开头说了 F 是可以等于 0 的，向上递归后，第i层楼其实就相当于第 0 层，可以被取到，所以说并没有错误。<br>因为我们要求的是<strong>最坏情况</strong>下扔鸡蛋的次数，所以鸡蛋在第 <code>i</code> 层楼碎没碎，取决于那种情况的结果<strong>更大</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">K, N</span>):</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> &lt;= i &lt;= N:<br>        <span class="hljs-comment"># 最坏情况下的最少扔鸡蛋次数</span><br>        res = min(res, <br>                  max( <br>                        dp(K - <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>), <span class="hljs-comment"># 碎</span><br>                        dp(K, N - i)      <span class="hljs-comment"># 没碎</span><br>                     ) + <span class="hljs-number">1</span> <span class="hljs-comment"># 在第 i 楼扔了一次</span><br>                 )<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>递归的 base case 很容易理解：当楼层数 <code>N</code> 等于 0 时，显然不需要扔鸡蛋；当鸡蛋数 <code>K</code> 为 1 时，显然只能线性扫描所有楼层：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">K, N</span>):</span><br>    <span class="hljs-keyword">if</span> K == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> N<br>    <span class="hljs-keyword">if</span> N == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    ...<br></code></pre></td></tr></table></figure><p>至此，其实这道题就解决了！只要添加一个备忘录消除重叠子问题即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">superEggDrop</span>(<span class="hljs-params">K: int, N: int</span>):</span><br>    memo = dict()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">K, N</span>) -&gt; int:</span><br>        <span class="hljs-comment"># base case</span><br>        <span class="hljs-keyword">if</span> K == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> N<br>        <span class="hljs-keyword">if</span> N == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 避免重复计算</span><br>        <span class="hljs-keyword">if</span> (K, N) <span class="hljs-keyword">in</span> memo:<br>            <span class="hljs-keyword">return</span> memo[(K, N)]<br>        res = float(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>        <span class="hljs-comment"># 穷举所有可能的选择</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, N + <span class="hljs-number">1</span>):<br>            res = min(res, <br>                      max(<br>                            dp(K, N - i), <br>                            dp(K - <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>)<br>                         ) + <span class="hljs-number">1</span><br>                  )<br>        <span class="hljs-comment"># 记入备忘录</span><br>        memo[(K, N)] = res<br>        <span class="hljs-keyword">return</span> res<br>    <br>    <span class="hljs-keyword">return</span> dp(K, N)<br></code></pre></td></tr></table></figure><p>这个算法的时间复杂度是多少呢？<strong>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度</strong>。<br>函数本身的复杂度就是忽略递归部分的复杂度，这里 <code>dp</code> 函数中有一个 for 循环，所以函数本身的复杂度是 O(N)。<br>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。<br>所以算法的总时间复杂度是 O(K*N^2), 空间复杂度 O(KN)。</p><h3 id="三、疑难解答"><a href="#三、疑难解答" class="headerlink" title="三、疑难解答"></a>三、疑难解答</h3><p>这个问题很复杂，但是算法代码却十分简洁，这就是动态规划的特性，穷举加备忘录/DP table 优化，真的没啥新意。<br>首先，有读者可能不理解代码中为什么用一个 for 循环遍历楼层 <code>[1..N]</code>，也许会把这个逻辑和之前探讨的线性扫描混为一谈。其实不是的，<strong>这只是在做一次「选择」</strong>。<br>比方说你有 2 个鸡蛋，面对 10 层楼，你<strong>这次</strong>选择去哪一层楼扔呢？不知道，那就把这 10 层楼全试一遍。至于下次怎么选择不用你操心，有正确的状态转移，递归会算出每个选择的代价，我们取最优的那个就是最优解。<br>另外，这个问题还有更好的解法，比如修改代码中的 for 循环为二分搜索，可以将时间复杂度降为 O(K*N*logN)；再改进动态规划解法可以进一步降为 O(KN)；使用数学方法解决，时间复杂度达到最优 O(K*logN)，空间复杂度达到 O(1)。<br>二分的解法也有点误导性，你很可能以为它跟我们之前讨论的二分思路扔鸡蛋有关系，实际上没有半毛钱关系。能用二分搜索是因为状态转移方程的函数图像具有单调性，可以快速找到最值。<br>简单介绍一下二分查找的优化吧，其实只是在优化这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">K, N</span>):</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> &lt;= i &lt;= N:<br>        <span class="hljs-comment"># 最坏情况下的最少扔鸡蛋次数</span><br>        res = min(res, <br>                  max( <br>                        dp(K - <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>), <span class="hljs-comment"># 碎</span><br>                        dp(K, N - i)      <span class="hljs-comment"># 没碎</span><br>                     ) + <span class="hljs-number">1</span> <span class="hljs-comment"># 在第 i 楼扔了一次</span><br>                 )<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>这个 for 循环就是下面这个状态转移方程的具体代码实现：</p><p>$ dp(K, N) = \min_{0 &lt;= i &lt;= N}{\max{dp(K - 1, i - 1), dp(K, N - i)} + 1} $</p><p>首先我们根据 <code>dp(K, N)</code> 数组的定义（有 <code>K</code> 个鸡蛋面对 <code>N</code> 层楼，最少需要扔几次），<strong>很容易知道 <code>K</code> 固定时，这个函数一定是单调递增的</strong>，无论你策略多聪明，楼层增加测试次数一定要增加。<br>那么注意 <code>dp(K - 1, i - 1)</code> 和 <code>dp(K, N - i)</code> 这两个函数，其中 <code>i</code> 是从 1 到 <code>N</code> 单增的，如果我们固定 <code>K</code> 和 <code>N</code>，<strong>把这两个函数看做关于 <code>i</code> 的函数，前者随着 <code>i</code> 的增加应该也是单调递增的，而后者随着 <code>i</code> 的增加应该是单调递减的</strong>：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%89%94%E9%B8%A1%E8%9B%8B/2.jpg"><br>这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这个交点嘛，熟悉二分搜索的同学肯定敏感地想到了，这不就是相当于求 Valley（山谷）值嘛，可以用二分查找来快速寻找这个点的。<br>直接贴一下代码吧，思路还是完全一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">superEggDrop</span>(<span class="hljs-params">self, K: int, N: int</span>) -&gt; int:</span><br>        <br>    memo = dict()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">K, N</span>):</span><br>        <span class="hljs-keyword">if</span> K == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> N<br>        <span class="hljs-keyword">if</span> N == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> (K, N) <span class="hljs-keyword">in</span> memo:<br>            <span class="hljs-keyword">return</span> memo[(K, N)]<br>                            <br>        <span class="hljs-comment"># for 1 &lt;= i &lt;= N:</span><br>        <span class="hljs-comment">#     res = min(res, </span><br>        <span class="hljs-comment">#             max( </span><br>    <span class="hljs-comment">#                     dp(K - 1, i - 1), </span><br>    <span class="hljs-comment">#                     dp(K, N - i)      </span><br>        <span class="hljs-comment">#                 ) + 1 </span><br>        <span class="hljs-comment">#             )</span><br>        res = float(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>        <span class="hljs-comment"># 用二分搜索代替线性搜索</span><br>        lo, hi = <span class="hljs-number">1</span>, N<br>        <span class="hljs-keyword">while</span> lo &lt;= hi:<br>            mid = (lo + hi) // <span class="hljs-number">2</span><br>            broken = dp(K - <span class="hljs-number">1</span>, mid - <span class="hljs-number">1</span>) <span class="hljs-comment"># 碎</span><br>            not_broken = dp(K, N - mid) <span class="hljs-comment"># 没碎</span><br>            <span class="hljs-comment"># res = min(max(碎，没碎) + 1)</span><br>            <span class="hljs-keyword">if</span> broken &gt; not_broken:<br>                hi = mid - <span class="hljs-number">1</span><br>                res = min(res, broken + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                lo = mid + <span class="hljs-number">1</span><br>                res = min(res, not_broken + <span class="hljs-number">1</span>)<br>        memo[(K, N)] = res<br>        <span class="hljs-keyword">return</span> res<br>    <br>    <span class="hljs-keyword">return</span> dp(K, N)<br></code></pre></td></tr></table></figure><p>这里就不展开其他解法了，留在下一篇文章 <a href="%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E8%BF%9B%E9%98%B6">高楼扔鸡蛋进阶</a><br>我觉得吧，我们这种解法就够了：找状态，做选择，足够清晰易懂，可流程化，可举一反三。掌握这套框架学有余力的话，再去考虑那些奇技淫巧也不迟。<br>最后预告一下，《动态规划详解（修订版）》和《回溯算法详解（修订版）》已经动笔了，教大家用模板的力量来对抗变化无穷的算法题，敬请期待。</p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">上一篇：编辑距离</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E8%BF%9B%E9%98%B6">下一篇：经典动态规划问题：高楼扔鸡蛋（进阶）</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linuxshell</title>
      <link href="2016/01/01/%E6%8A%80%E6%9C%AF/linuxshell/"/>
      <url>2016/01/01/%E6%8A%80%E6%9C%AF/linuxshell/</url>
      
        <content type="html"><![CDATA[<p>我个人很喜欢使用 Linux 系统，虽然说 Windows 的图形化界面做的确实比 Linux 好，但是对脚本的支持太差了。一开始有点不习惯命令行操作，但是熟悉了之后反而发现移动鼠标点点点才是浪费时间的罪魁祸首。。。<br><strong>那么对于 Linux 命令行，本文不是介绍某些命令的用法，而是说明一些简单却特别容易让人迷惑的细节问题</strong>。<br>1、标准输入和命令参数的区别。<br>2、在后台运行命令在退出终端后也全部退出了。<br>3、单引号和双引号表示字符串的区别。<br>4、有的命令和<code>sudo</code>一起用就 command not found。</p><h3 id="一、标准输入和参数的区别"><a href="#一、标准输入和参数的区别" class="headerlink" title="一、标准输入和参数的区别"></a>一、标准输入和参数的区别</h3><p>这个问题一定是最容易让人迷惑的，具体来说，就是搞不清什么时候用管道符<code>|</code>和文件重定向<code>&gt;</code>，<code>&lt;</code>，什么时候用变量<code>$</code>。<br>比如说，我现在有个自动连接宽带的 shell 脚本<code>connect.sh</code>，存在我的家目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">where</span> connect.sh</span><br>/home/fdl/bin/connect.sh<br></code></pre></td></tr></table></figure><p>如果我想删除这个脚本，而且想少敲几次键盘，应该怎么操作呢？我曾经这样尝试过：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">where</span> connect.sh | rm</span><br></code></pre></td></tr></table></figure><p>实际上，这样操作是错误的，正确的做法应该是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> rm $(<span class="hljs-built_in">where</span> connect.sh)</span><br></code></pre></td></tr></table></figure><p>前者试图将<code>where</code>的结果连接到<code>rm</code>的标准输入，后者试图将结果作为命令行参数传入。<br><strong>标准输入就是编程语言中诸如<code>scanf</code>或者<code>readline</code>这种命令；而参数是指程序的<code>main</code>函数传入的<code>args</code>字符数组</strong>。<br>前文「Linux文件描述符」说过，管道符和重定向符是将数据作为程序的标准输入，而<code>$(cmd)</code>是读取<code>cmd</code>命令输出的数据作为参数。<br>用刚才的例子说，<code>rm</code>命令源代码中肯定不接受标准输入，而是接收命令行参数，删除相应的文件。作为对比，<code>cat</code>命令是既接受标准输入，又接受命令行参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat filename</span><br>...file text...<br><span class="hljs-meta">$</span><span class="bash"> cat &lt; filename</span><br>...file text...<br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello world&#x27;</span> | cat</span><br>hello world<br></code></pre></td></tr></table></figure><p><strong>如果命令能够让终端阻塞，说明该命令接收标准输入，反之就是不接受</strong>，比如你只运行<code>cat</code>命令不加任何参数，终端就会阻塞，等待你输入字符串并回显相同的字符串。</p><h3 id="二、后台运行程序"><a href="#二、后台运行程序" class="headerlink" title="二、后台运行程序"></a>二、后台运行程序</h3><p>比如说你远程登录到服务器上，运行一个 Django web 程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python manager.py runserver 0.0.0.0</span><br>Listening on 0.0.0.0:8080...<br></code></pre></td></tr></table></figure><p>现在你可以通过服务器的 IP 地址测试 Django 服务，但是终端此时就阻塞了，你输入什么都不响应，除非输入 Ctrl-C 或者 Ctrl-/ 终止 python 进程。<br>可以在命令之后加一个<code>&amp;</code>符号，这样命令行不会阻塞，可以响应你后续输入的命令，但是如果你退出服务器的登录，就不能访问该网页了。<br>如果你想在退出服务器之后仍然能够访问 web 服务，应该这样写命令 <code>(cmd &amp;)</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> (python manager.py runserver 0.0.0.0 &amp;)</span><br>Listening on 0.0.0.0:8080...<br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">logout</span></span><br></code></pre></td></tr></table></figure><p><strong>底层原理是这样的</strong>：<br>每一个命令行终端都是一个 shell 进程，你在这个终端里执行的程序实际上都是这个 shell 进程分出来的子进程。正常情况下，shell 进程会阻塞，等待子进程退出才重新接收你输入的新的命令。加上<code>&amp;</code>号，只是让 shell 进程不再阻塞，可以继续响应你的新命令。但是无论如何，你如果关掉了这个 shell 命令行端口，依附于它的所有子进程都会退出。<br>而<code>(cmd &amp;)</code>这样运行命令，则是将<code>cmd</code>命令挂到一个<code>systemd</code>系统守护进程名下，认<code>systemd</code>做爸爸，这样当你退出当前终端时，对于刚才的<code>cmd</code>命令就完全没有影响了。<br>类似的，还有一种后台运行常用的做法是这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nohub some_cmd &amp;</span><br></code></pre></td></tr></table></figure><p><code>nohub</code>命令也是类似的原理，不过通过我的测试，还是<code>(cmd &amp;)</code>这种形式更加稳定。</p><h3 id="三、单引号和双引号的区别"><a href="#三、单引号和双引号的区别" class="headerlink" title="三、单引号和双引号的区别"></a>三、单引号和双引号的区别</h3><p>不同的 shell 行为会有细微区别，但有一点是确定的，<strong>对于<code>$</code>，<code>(</code>，<code>)</code>这几个符号，单引号包围的字符串不会做任何转义，双引号包围的字符串会转义</strong>。<br>shell 的行为可以测试，使用<code>set -x</code>命令，会开启 shell 的命令回显，你可以通过回显观察 shell 到底在执行什么命令：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/linuxshell/1.png"><br>可见 <code>echo $(cmd)</code> 和 <code>echo &quot;$(cmd)&quot;</code>，结果差不多，但是仍然有区别。注意观察，双引号转义完成的结果会自动增加单引号，而前者不会。<br><strong>也就是说，如果 <code>$</code> 读取出的参数字符串包含空格，应该用双引号括起来，否则就会出错</strong>。</p><h3 id="四、sudo-找不到命令"><a href="#四、sudo-找不到命令" class="headerlink" title="四、sudo 找不到命令"></a>四、sudo 找不到命令</h3><p>有时候我们普通用户可以用的命令，用<code>sudo</code>加权限之后却报错 command not found：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> connect.sh</span><br>network-manager: Permission denied<br><span class="hljs-meta">$</span><span class="bash"> sudo connect.sh</span><br>sudo: command not found<br></code></pre></td></tr></table></figure><p>原因在于，<code>connect.sh</code>这个脚本仅存在于该用户的环境变量中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">where</span> connect.sh </span><br>/home/fdl/bin/connect.sh<br></code></pre></td></tr></table></figure><p><strong>当使用<code>sudo</code>时，系统认为是 root 用户在执行命令，所以会去搜索 root 用户的环境变量</strong>，而这个脚本在 root 的环境变量目录中当然是找不到的。<br>解决方法是使用脚本文件的路径，而不是仅仅通过脚本名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo /home/fdl/bin/connect.sh</span><br></code></pre></td></tr></table></figure><p><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/session%E5%92%8Ccookie">上一篇：一文看懂 session 和 cookie</a><br><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF">下一篇：加密算法的前身今世</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux进程</title>
      <link href="2016/01/01/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B/"/>
      <url>2016/01/01/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux的进程、线程、文件描述符是什么"><a href="#Linux的进程、线程、文件描述符是什么" class="headerlink" title="Linux的进程、线程、文件描述符是什么"></a>Linux的进程、线程、文件描述符是什么</h1><p>说到进程，恐怕面试中最常见的问题就是线程和进程的关系了，那么先说一下答案：<strong>在 Linux 系统中，进程和线程几乎没有区别</strong>。<br>Linux 中的进程就是一个数据结构，看明白就可以理解文件描述符、重定向、管道命令的底层工作原理，最后我们从操作系统的角度看看为什么说线程和进程基本没有区别。</p><h3 id="一、进程是什么"><a href="#一、进程是什么" class="headerlink" title="一、进程是什么"></a>一、进程是什么</h3><p>首先，抽象地来说，我们的计算机就是这个东西：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/linuxProcess/1.jpg"><br>这个大的矩形表示计算机的<strong>内存空间</strong>，其中的小矩形代表<strong>进程</strong>，左下角的圆形表示<strong>磁盘</strong>，右下角的图形表示一些<strong>输入输出设备</strong>，比如鼠标键盘显示器等等。另外，注意到内存空间被划分为了两块，上半部分表示<strong>用户空间</strong>，下半部分表示<strong>内核空间</strong>。<br>用户空间装着用户进程需要使用的资源，比如你在程序代码里开一个数组，这个数组肯定存在用户空间；内核空间存放内核进程需要加载的系统资源，这一些资源一般是不允许用户访问的。但是注意有的用户进程会共享一些内核空间的资源，比如一些动态链接库等等。<br>我们用 C 语言写一个 hello 程序，编译后得到一个可执行文件，在命令行运行就可以打印出一句 hello world，然后程序退出。在操作系统层面，就是新建了一个进程，这个进程将我们编译出来的可执行文件读入内存空间，然后执行，最后退出。<br><strong>你编译好的那个可执行程序只是一个文件</strong>，不是进程，可执行文件必须要载入内存，包装成一个进程才能真正跑起来。进程是要依靠操作系统创建的，每个进程都有它的固有属性，比如进程号（PID）、进程状态、打开的文件等等，进程创建好之后，读入你的程序，你的程序才被系统执行。<br>那么，操作系统是如何创建进程的呢？<strong>对于操作系统，进程就是一个数据结构</strong>，我们直接来看 Linux 的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br><span class="hljs-comment">// 进程状态</span><br><span class="hljs-keyword">long</span>  state;<br><span class="hljs-comment">// 虚拟内存结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span>  *<span class="hljs-title">mm</span>;</span><br><span class="hljs-comment">// 进程号</span><br><span class="hljs-keyword">pid_t</span>  pid;<br><span class="hljs-comment">// 指向父进程的指针</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> __<span class="hljs-title">rcu</span>  *<span class="hljs-title">parent</span>;</span><br><span class="hljs-comment">// 子进程列表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">children</span>;</span><br><span class="hljs-comment">// 存放文件系统信息的指针</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_struct</span>*<span class="hljs-title">fs</span>;</span><br><span class="hljs-comment">// 一个数组，包含该进程打开的文件指针</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span>*<span class="hljs-title">files</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>task_struct</code>就是 Linux 内核对于一个进程的描述，也可以称为「进程描述符」。源码比较复杂，我这里就截取了一小部分比较常见的。<br>其中比较有意思的是<code>mm</code>指针和<code>files</code>指针。<code>mm</code>指向的是进程的虚拟内存，也就是载入资源和可执行文件的地方；<code>files</code>指针指向一个数组，这个数组里装着所有该进程打开的文件的指针。</p><h3 id="二、文件描述符是什么"><a href="#二、文件描述符是什么" class="headerlink" title="二、文件描述符是什么"></a>二、文件描述符是什么</h3><p>先说<code>files</code>，它是一个文件指针数组。一般来说，一个进程会从<code>files[0]</code>读取输入，将输出写入<code>files[1]</code>，将错误信息写入<code>files[2]</code>。<br>举个例子，以我们的角度 C 语言的<code>printf</code>函数是向命令行打印字符，但是从进程的角度来看，就是向<code>files[1]</code>写入数据；同理，<code>scanf</code>函数就是进程试图从<code>files[0]</code>这个文件中读取数据。<br><strong>每个进程被创建时，<code>files</code>的前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引</strong>，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。</p><p>我们可以重新画一幅图：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/linuxProcess/2.jpg"><br>对于一般的计算机，输入流是键盘，输出流是显示器，错误流也是显示器，所以现在这个进程和内核连了三根线。因为硬件都是由内核管理的，我们的进程需要通过「系统调用」让内核进程访问硬件资源。<br>PS：不要忘了，Linux 中一切都被抽象成文件，设备也是文件，可以进行读和写。<br>如果我们写的程序需要其他资源，比如打开一个文件进行读写，这也很简单，进行系统调用，让内核把文件打开，这个文件就会被放到<code>files</code>的第 4 个位置：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/linuxProcess/3.jpg"><br>明白了这个原理，<strong>输入重定向</strong>就很好理解了，程序想读取数据的时候就会去<code>files[0]</code>读取，所以我们只要把<code>files[0]</code>指向一个文件，那么程序就会从这个文件中读取数据，而不是从键盘：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">command</span> &lt; file.txt</span><br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/linuxProcess/5.jpg"><br>同理，<strong>输出重定向</strong>就是把<code>files[1]</code>指向一个文件，那么程序的输出就不会写入到显示器，而是写入到这个文件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">command</span> &gt; file.txt</span><br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/linuxProcess/4.jpg"><br>错误重定向也是一样的，就不再赘述。<br><strong>管道符</strong>其实也是异曲同工，把一个进程的输出流和另一个进程的输入流接起一条「管道」，数据就在其中传递，不得不说这种设计思想真的很优美：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cmd1 | cmd2 | cmd3</span><br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/linuxProcess/6.jpg"><br>到这里，你可能也看出「Linux 中一切皆文件」设计思路的高明了，不管是设备、另一个进程、socket 套接字还是真正的文件，全部都可以读写，统一装进一个简单的<code>files</code>数组，进程通过简单的文件描述符访问相应资源，具体细节交于操作系统，有效解耦，优美高效。</p><h3 id="三、线程是什么"><a href="#三、线程是什么" class="headerlink" title="三、线程是什么"></a>三、线程是什么</h3><p>首先要明确的是，多进程和多线程都是并发，都可以提高处理器的利用效率，所以现在的关键是，多线程和多进程有啥区别。<br>为什么说 Linux 中线程和进程基本没有区别呢，因为从 Linux 内核的角度来看，并没有把线程和进程区别对待。<br>我们知道系统调用<code>fork()</code>可以新建一个子进程，函数<code>pthread()</code>可以新建一个线程。<strong>但无论线程还是进程，都是用<code>task_struct</code>结构表示的，唯一的区别就是共享的数据区域不同</strong>。<br>换句话说，线程看起来跟进程没有区别，只是线程的某些数据区域和其父进程是共享的，而子进程是拷贝副本，而不是共享。就比如说，<code>mm</code>结构和<code>files</code>结构在线程中都是共享的，我画两张图你就明白了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/linuxProcess/7.jpg"><br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/linuxProcess/8.jpg"><br>所以说，我们的多线程程序要利用锁机制，避免多个线程同时往同一区域写入数据，否则可能造成数据错乱。<br>那么你可能问，<strong>既然进程和线程差不多，而且多进程数据不共享，即不存在数据错乱的问题，为什么多线程的使用比多进程普遍得多呢</strong>？<br>因为现实中数据共享的并发更普遍呀，比如十个人同时从一个账户取十元，我们希望的是这个共享账户的余额正确减少一百元，而不是希望每人获得一个账户的拷贝，每个拷贝账户减少十元。<br>当然，必须要说明的是，只有 Linux 系统将线程看做共享数据的进程，不对其做特殊看待，其他的很多操作系统是对线程和进程区别对待的，线程有其特有的数据结构，我个人认为不如 Linux 的这种设计简洁，增加了系统的复杂度。<br>在 Linux 中新建线程和进程的效率都是很高的，对于新建进程时内存区域拷贝的问题，Linux 采用了 copy-on-write 的策略优化，也就是并不真正复制父进程的内存空间，而是等到需要写操作时才去复制。<strong>所以 Linux 中新建进程和新建线程都是很迅速的</strong>。</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7">上一篇：双指针技巧解题框架</a><br><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/%E5%9C%A8%E7%BA%BF%E7%BB%83%E4%B9%A0%E5%B9%B3%E5%8F%B0">下一篇：Git/SQL/正则表达式的在线练习平台</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis入侵</title>
      <link href="2016/01/01/%E6%8A%80%E6%9C%AF/redis%E5%85%A5%E4%BE%B5/"/>
      <url>2016/01/01/%E6%8A%80%E6%9C%AF/redis%E5%85%A5%E4%BE%B5/</url>
      
        <content type="html"><![CDATA[<p>好吧，我也做了回标题党，像我这么细心的同学，怎么可能让服务器被入侵呢？<br>其实是这样的，昨天我和一个朋友聊天，他说他自己有一台云服务器运行了 Redis 数据库，有一天突然发现数据库里的<strong>数据全没了</strong>，只剩下一个奇奇怪怪的键值对，其中值看起来像一个 RSA 公钥的字符串，他以为是误操作删库了，幸好自己的服务器里没啥重要的数据，也就没在意。<br>经过一番攀谈交心了解到，他跑了一个比较古老已经停止维护的开源项目，安装的旧版本的 Redis，而且他对 Linux 的使用不是很熟练。我就知道，他的服务器已经被攻陷了，想到也许还会有不少像我这位朋友的人，不重视操作系统的权限、防火墙的设置和数据库的保护，我就写一篇文章简单看看这种情况出现的原因，以及如何防范。<br>PS：这种手法现在已经行不通了，因为新版本 Redis 都增加了 protect mode，增加了安全性，我们只能在本地简单模拟一下，就别乱试了。</p><h3 id="事件经过"><a href="#事件经过" class="headerlink" title="事件经过"></a>事件经过</h3><p>其实这种攻击手法都是 2015 年的事了，那时候 Redis 的安全保护机制比较差，只能靠运维人员来合理配置以保证数据库的安全。有段时间，全球几万个 Redis 节点遭到了攻击，出现了上述奇怪的现象，所有数据被清空，只剩一个键叫 <code>crackit</code>，它的值形似 RSA 公钥的字符串。<br>后来查证，攻击者利用 Redis 动态设置配置和数据持久化的功能，把自己的 RSA 公钥写入到了被攻击服务器的 <code>/root/.ssh/authored_keys</code> 这个文件，从而可以用私钥直接登录对方的 root 用户，侵入对方系统。<br>沦陷的服务器安全防护做的很不好，具体如下：<br>1、Redis 的端口是默认端口，而且可以从公网访问。<br>2、Redis 还没设密码。<br>3、Redis 进程是由 root 用户启动的。<br>以上每个点都是比较危险的，合在一起，那真是很致命了。且不说别人把公钥写到你的系统里，就说连上你的数据库然后删库，那损失都够大了。那么具体的流程是什么呢，下面我在本地回环地址上简单演示一下。</p><h3 id="本地演示"><a href="#本地演示" class="headerlink" title="本地演示"></a>本地演示</h3><p>Redis 监听的默认端口是 6379，我们设置它接收网卡 127.0.0.1 的连接，这样我从本地肯定可以连接 Redis，以此模拟「从公网可以访问 Redis」这一条件。<br>现在我是名叫 fdl 的普通用户，我想用 ssh 登录我系统上的 root 用户，要输入 root 的密码，我不知道，所以没办法登录。<br>除了密码登录之外，还可以使用 RSA 密钥对登录，但是必须要把我的公钥存到 root 的家目录中 <code>/root/.ssh/authored_keys</code>。我们知道 <code>/root</code> 目录的权限设置是不允许任何其他用户闯入读写的：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/redis%E5%85%A5%E4%BE%B5/1.png"><br>但是，我发现自己竟然可以直接访问 Redis：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/redis%E5%85%A5%E4%BE%B5/2.png"><br>如果 Redis 是以 root 的身份运行的，那么我就可以通过操作 Redis，让它把我的公钥写到 root 的家目录中。Redis 有一种持久化方式是生成 RDB 文件，其中会包含原始数据。<br>我露出了邪恶的微笑，先把 Redis 中的数据全部清空，然后把我的 RSA 公钥写到数据库里，这里在开头和结尾加换行符目的是避免 RDB 文件生成过程中损坏到公钥字符串：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/redis%E5%85%A5%E4%BE%B5/3.png"><br>命令 Redis 把生成的数据文件保存到 <code>/root/.ssh/</code> 中的 <code>authored_keys</code> 文件中：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/redis%E5%85%A5%E4%BE%B5/4.png"><br>现在，root 的家目录中已经包含了我们的 RSA 公钥，我们现在可以通过密钥对登录进 root 了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/redis%E5%85%A5%E4%BE%B5/5.png"><br>看一下刚才写入 root 家的公钥：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/redis%E5%85%A5%E4%BE%B5/6.png"><br>乱码是 GDB 文件的某种编码吧，但是中间的公钥被完整保存了，而且 ssh 登录程序竟然也识别了这段被乱码包围的公钥！<br>至此，拥有了 root 权限，就可以为所欲为了。。。</p><h3 id="吸取教训"><a href="#吸取教训" class="headerlink" title="吸取教训"></a>吸取教训</h3><p>虽然现在基本不会受到这种攻击（新版本的 Redis 没有密码时默认不对外网开放），但是对于系统的安全性是每个人都应该重视的。<br>我们自己折腾东西，用个低配云服务器，为了省事儿一般也不认真配置防火墙，数据库不设密码或者设成 admin、root 这样简单的密码，反正也没啥数据。这样肯定不是个好习惯。<br>现在我们的计算机系统越来越完善，每个成熟的项目都由最优秀的一帮人维护，从技术上说应该算是无懈可击了，那么唯一可能出问题的地方就在于使用它们的人。<br>就像经常看到有人的 QQ 被盗，我相信盗号的人肯定不是跑到腾讯的数据库里盗号，肯定是 QQ 号主安全防范意识差，在哪个钓鱼网站输入了自己的账号密码，导致被盗。我基本没见过微信被盗的，可能是微信弱化密码登录，改用二维码扫描登录的原因。这应该也算是一种安全方面的考量吧，毕竟微信是有支付功能的。<br>上面这种骗局对于技术人来说，看看 url，浏览器分析一下网络包就很容易识别出来，但是你还别不信，一般人真的搞不明白怎么识别钓鱼网站和官方网站。就像我真没想到都 2020 年了，还有人在找 Redis 的这个漏洞，而且还有人中招。。。<br>那么说回 Redis 数据库的使用，在官网上明确写出了安全防护的建议，我简单总结一下吧：<br>1、不要用 root 用户启动 Redis Server，而且一定要设置密码，而且密码不要太短，否则容易被暴力破解。<br>2、配置服务器防火墙和 Redis 的 config 文件，尽量不要让 Redis 与外界接触。<br>3、利用 rename 功能伪装 flushall 这种危险命令，以防被删库，丢失数据。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线练习平台</title>
      <link href="2016/01/01/%E6%8A%80%E6%9C%AF/%E5%9C%A8%E7%BA%BF%E7%BB%83%E4%B9%A0%E5%B9%B3%E5%8F%B0/"/>
      <url>2016/01/01/%E6%8A%80%E6%9C%AF/%E5%9C%A8%E7%BA%BF%E7%BB%83%E4%B9%A0%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<p>虽说我没事就喜欢喷应试教育，但我也从应试教育中发现了一个窍门：如果能够以刷题的形式学习某项技能，效率和效果是最佳的。对于技术的学习，我经常面临的困境是，<strong>理论知识知道的不少，但是有的场景实在无法模拟，缺少亲自动手实践的机会</strong>，如果能有一本带标准答案的习题册让我刷刷就好了。<br>所以在学习新技术时，我首先会去搜索是否有在线刷题平台，你还别说，有的大神真就做了很不错的在线练习平台，下面就介绍几个平台，分别是学习 Git、SQL、正则表达式的在线练习平台。</p><h3 id="一、练习-Git"><a href="#一、练习-Git" class="headerlink" title="一、练习 Git"></a>一、练习 Git</h3><p>这是个叫做 Learning Git Branching 的项目，是我一定要推荐的：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/online/1.png"><br>正如对话框中的自我介绍，这确实也是我至今发现的<strong>最好</strong>的 Git 动画教程，没有之一。<br>想当年我用 Git 就会 <code>add .</code>，<code>clone</code>，<code>push</code>，<code>pull</code>，<code>commit</code> 几个命令，其他的命令完全不会，Git 就是一个下载器，Github 就是个资源网站加免费图床，命令能不能达成目的都是靠运气。什么版本控制，我根本搞不懂，也懒得去看那一堆乱七八糟的文档。<br>这个网站的教程不是给你举那种修改文件的细节例子，而是将每次 <code>commit</code> 都抽象成树的节点，<strong>用动画闯关的形式</strong>，让你自由使用 Git 命令完成目标：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/online/2.png"><br>所有 Git 分支都被可视化了，你只要在左侧的命令行输入 Git 命令，分支会进行相应的变化，只要达成任务目标，你就过关啦！网站还会记录你的命令数，试试能不能以最少的命令数过关！<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/online/3.png"><br>我一开始以为这个教程只包含本地 Git 仓库的版本管理，<strong>后来我惊奇地发现它还有远程仓库的操作教程</strong>！<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/online/4.png"><br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/online/5.png"><br>真的跟玩游戏一样，难度设计合理，流畅度很好，我一玩都停不下来了，几小时就打通了，哈哈哈！<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/online/6.png"><br>总之，这个教程很适合初学和进阶，如果你觉得自己对 Git 的掌握还不太好，用 Git 命令还是靠碰运气，就可以玩玩这个教程，相信能够让你更熟练地使用 Git。<br>它是一个开源项目，Github 项目地址：<br><a href="https://github.com/pcottle/learnGitBranching">https://github.com/pcottle/learnGitBranching</a><br>教程网站地址：<br><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org</a></p><h3 id="二、练习正则表达式"><a href="#二、练习正则表达式" class="headerlink" title="二、练习正则表达式"></a>二、练习正则表达式</h3><p><strong>正则表达式是个非常强有力的工具</strong>，可以说计算机中的一切数据都是字符，借助正则表达式这种模式匹配工具，操作计算机可以说是如虎添翼。<br>我这里要推荐两个网站，一个是练习平台，一个是测试正则表达式的平台。<br>先说练习平台，叫做 RegexOne：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/online/9.png"><br>前面有基本教程，后面有一些常见的正则表达式题目，比如判断邮箱、URL、电话号，或者抽取日志的关键信息等等。<br>只要写出符合要求的正则表达式，就可以进入下一个问题，关键是每道题还有标准答案，可以点击下面的 solution 按钮查看：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/online/10.png"><br>RegexOne 网址：<br><a href="https://regexone.com/">https://regexone.com/</a><br>再说测试工具，是个叫做 RegExr 的 Github 项目，这是它的网站：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/online/11.png"><br>可以看见，输入文本和正则模式串后，<strong>网站会给正则表达式添加好看且容易辨认的样式，自动在文本中搜索模式串，高亮显示匹配的字符串，并且还会显示每个分组捕获的字符串</strong>。<br>这个网站可以配合前面的正则练习平台使用，在这里尝试各种表达式，成功匹配之后粘贴过去。<br>RegExr 网址：<br><a href="https://regexr.com/">https://regexr.com/</a></p><h3 id="三、练习-SQL"><a href="#三、练习-SQL" class="headerlink" title="三、练习 SQL"></a>三、练习 SQL</h3><p>这是一个叫做 SQLZOO 的网站，左侧是所有的练习内容：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/online/7.png"><br>SQLZOO 是一款很好用的 SQL 练习平台，英文不难理解，可以直接看英文版，但是也可以切换繁体中文，比较友好。<br>这里都是比较常用的 SQL 命令，给你一个需求，你写 SQL 语句实现正确的查询结果。<strong>最重要的是，这里不仅对每个命令的用法有详细解释，每个专题后面还有选择题（quiz），而且有判题系统，甚至有的比较难的题目还有视频讲解</strong>：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/online/8.png"><br>至于难度，循序渐进，即便对新手也很友好，靠后的问题确实比较有技巧性，相信这是热爱思维挑战的人喜欢的！LeetCode 也有 SQL 相关的题目，不过难度一般比较大，我觉得 SQLZOO 刷完基础 SQL 命令再去 LeetCode 刷比较合适。<br>网站地址：<br><a href="https://sqlzoo.net/">https://sqlzoo.net/</a></p><p><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B">上一篇：Linux的进程、线程、文件描述符是什么</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6">下一篇：动态规划详解</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>session和cookie</title>
      <link href="2016/01/01/%E6%8A%80%E6%9C%AF/session%E5%92%8Ccookie/"/>
      <url>2016/01/01/%E6%8A%80%E6%9C%AF/session%E5%92%8Ccookie/</url>
      
        <content type="html"><![CDATA[<p>cookie 大家应该都熟悉，比如说登录某些网站一段时间后，就要求你重新登录；再比如有的同学很喜欢玩爬虫技术，有时候网站就是可以拦截住你的爬虫，这些都和 cookie 有关。如果你明白了服务器后端对于 cookie 和 session 的处理逻辑，就可以解释这些现象，甚至钻一些空子无限白嫖，待我慢慢道来。</p><h3 id="一、session-和-cookie-简介"><a href="#一、session-和-cookie-简介" class="headerlink" title="一、session 和 cookie 简介"></a>一、session 和 cookie 简介</h3><p>cookie 的出现是因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你。<br>抽象地概括一下：<strong>一个 cookie 可以认为是一个「变量」，形如 <code>name=value</code>，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上</strong>。<br>注意，我说的是「一个」cookie 可以认为是一个变量，但是服务器可以一次设置多个 cookie，所以有时候说 cookie 是「一组」键值对儿，这也可以说得通。<br>cookie 可以在服务器端通过 HTTP 的 SetCookie 字段设置 cookie，比如我用 Go 语言写的一个简单服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cookie</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 设置了两个 cookie </span><br>http.SetCookie(w, &amp;http.Cookie&#123;<br>Name:       <span class="hljs-string">&quot;name1&quot;</span>,<br>Value:      <span class="hljs-string">&quot;value1&quot;</span>,<br>&#125;)<br>http.SetCookie(w, &amp;http.Cookie&#123;<br>Name:  <span class="hljs-string">&quot;name2&quot;</span>,<br>Value: <span class="hljs-string">&quot;value2&quot;</span>,<br>&#125;)<br>    <span class="hljs-comment">// 将字符串写入网页</span><br>fmt.Fprintln(w, <span class="hljs-string">&quot;页面内容&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>当浏览器访问对应网址时，通过浏览器的开发者工具查看此次 HTTP 通信的细节，可以看见服务器的回应发出了两次 <code>SetCookie</code> 命令：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/session/1.png"><br>在这之后，浏览器的请求中的 <code>Cookie</code> 字段就带上了这两个 cookie：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/session/2.png"><br><strong>cookie 的作用其实就是这么简单，无非就是服务器给每个客户端（浏览器）打的标签</strong>，方便服务器辨认而已。当然，HTTP 还有很多参数可以设置 cookie，比如过期时间，或者让某个 cookie 只有某个特定路径才能使用等等。<br>但问题是，我们也知道现在的很多网站功能很复杂，而且涉及很多的数据交互，比如说电商网站的购物车功能，信息量大，而且结构也比较复杂，无法通过简单的 cookie 机制传递这么多信息，而且要知道 cookie 字段是存储在 HTTP header 中的，就算能够承载这些信息，也会消耗很多的带宽，比较消耗网络资源。<br>session 就可以配合 cookie 解决这一问题，比如说一个 cookie 存储这样一个变量 <code>sessionID=xxxx</code>，仅仅把这一个 cookie 传给服务器，然后服务器通过这个 ID 找到对应的 session，这个 session 是一个数据结构，里面存储着该用户的购物车等详细信息，服务器可以通过这些信息返回该用户的定制化网页，有效解决了追踪用户的问题。<br><strong>session 是一个数据结构，由网站的开发者设计，所以可以承载各种数据</strong>，只要客户端的 cookie 传来一个唯一的 session ID，服务器就可以找到对应的 session，认出这个客户。<br>当然，由于 session 存储在服务器中，肯定会消耗服务器的资源，所以 session 一般都会有一个过期时间，服务器一般会定期检查并删除过期的 session，如果后来该用户再次访问服务器，可能就会面临重新登录等等措施，然后服务器新建一个 session，将 session ID 通过 cookie 的形式传送给客户端。<br>那么，我们知道 cookie 和 session 的原理，有什么切实的好处呢？<strong>除了应对面试，我给你说一个鸡贼的用处，就是可以白嫖某些服务</strong>。<br>有些网站，你第一次使用它的服务，它直接免费让你试用，但是用一次之后，就让你登录然后付费继续使用该服务。而且你发现网站似乎通过某些手段记住了你的电脑，除非你换个电脑或者换个浏览器才能再白嫖一次。<br>那么问题来了，你试用的时候没有登录，网站服务器是怎么记住你的呢？这就很显然了，服务器一定是给你的浏览器打了 cookie，后台建立了对应的 session 记录你的状态。你的浏览器在每次访问该网站的时候都会听话地带着 cookie，服务器一查 session 就知道这个浏览器已经免费使用过了，得让它登录付费，不能让它继续白嫖了。<br>那如果我不让浏览器发送 cookie，每次都伪装成一个第一次来试用的小萌新，不就可以不断白嫖了么？浏览器会把网站的 cookie 以文件的形式存在某些地方（不同的浏览器配置不同），你把他们找到然后删除就行了。但是对于 Firefox 和 Chrome 浏览器，有很多插件可以直接编辑 cookie，比如我的 Chrome 浏览器就用的一款叫做 EditThisCookie 的插件，这是他们官网：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/session/3.png" alt="http://www.editthiscookie.com/"><br>这类插件可以读取浏览器在当前网页的 cookie，点开插件可以任意编辑和删除 cookie。<strong>当然，偶尔白嫖一两次还行，不鼓励高频率白嫖，想常用还是掏钱吧，否则网站赚不到钱，就只能取消免费试用这个机制了</strong>。<br>以上就是关于 cookie 和 session 的简单介绍，cookie 是 HTTP 协议的一部分，不算复杂，而 session 是可以定制的，所以下面详细看一下实现 session 管理的代码架构吧。</p><h3 id="二、session-的实现"><a href="#二、session-的实现" class="headerlink" title="二、session 的实现"></a>二、session 的实现</h3><p>session 的原理不难，但是具体实现它可是很有技巧的，一般需要三个组件配合完成，它们分别是 <code>Manager</code>、<code>Provider</code> 和 <code>Session</code> 三个类（接口）。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/session/4.jpg"><br>1、浏览器通过 HTTP 协议向服务器请求路径 <code>/content</code> 的网页资源，对应路径上有一个 Handler 函数接收请求，解析 HTTP header 中的 cookie，得到其中存储的 sessionID，然后把这个 ID 发给 <code>Manager</code>。<br>2、<code>Manager</code> 充当一个 session 管理器的角色，主要存储一些配置信息，比如 session 的存活时间，cookie 的名字等等。而所有的 session 存在 <code>Manager</code> 内部的一个 <code>Provider</code> 中。所以 <code>Manager</code> 会把 <code>sid</code>（sessionID）传递给 <code>Provider</code>，让它去找这个 ID 对应的具体是哪个 session。<br>3、<code>Provider</code> 就是一个容器，最常见的应该就是一个散列表，将每个 <code>sid</code> 和对应的 session 一一映射起来。收到 <code>Manager</code> 传递的 <code>sid</code> 之后，它就找到 <code>sid</code> 对应的 session 结构，也就是 <code>Session</code> 结构，然后返回它。<br>4、<code>Session</code> 中存储着用户的具体信息，由 Handler 函数中的逻辑拿出这些信息，生成该用户的 HTML 网页，返回给客户端。<br>那么你也许会问，为什么搞这么麻烦，直接在 Handler 函数中搞一个哈希表，然后存储 <code>sid</code> 和 <code>Session</code> 结构的映射不就完事儿了？<br><strong>这就是设计层面的技巧了</strong>，下面就来说说，为什么分成 <code>Manager</code>、<code>Provider</code> 和 <code>Session</code>。</p><p>先从最底层的 <code>Session</code> 说。既然 session 就是键值对，为啥不直接用哈希表，而是要抽象出这么一个数据结构呢？<br>第一，因为 <code>Session</code> 结构可能不止存储了一个哈希表，还可以存储一些辅助数据，比如 <code>sid</code>，访问次数，过期时间或者最后一次的访问时间，这样便于实现想 LRU、LFU 这样的算法。<br>第二，因为 session 可以有不同的存储方式。如果用编程语言内置的哈希表，那么 session 数据就是存储在内存中，如果数据量大，很容易造成程序崩溃，而且一旦程序结束，所有 session 数据都会丢失。所以可以有很多种 session 的存储方式，比如存入缓存数据库 Redis，或者存入 MySQL 等等。<br>因此，<code>Session</code> 结构提供一层抽象，屏蔽不同存储方式的差异，只要提供一组通用接口操纵键值对：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Session <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-comment">// 设置键值对</span><br>    Set(key, val <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    <span class="hljs-comment">// 获取 key 对应的值</span><br>    Get(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>    <span class="hljs-comment">// 删除键 key</span><br>Delete(key <span class="hljs-keyword">interface</span>&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>再说 <code>Provider</code> 为啥要抽象出来。我们上面那个图的 <code>Provider</code> 就是一个散列表，保存 <code>sid</code> 到 <code>Session</code> 的映射，但是实际中肯定会更加复杂。我们不是要时不时删除一些 session 吗，除了设置存活时间之外，还可以采用一些其他策略，比如 LRU 缓存淘汰算法，这样就需要 <code>Provider</code> 内部使用哈希链表这种数据结构来存储 session。<br>PS：关于 LRU 算法的奥妙，参见前文「LRU 算法详解」。<br>因此，<code>Provider</code> 作为一个容器，就是要屏蔽算法细节，以合理的数据结构和算法组织 <code>sid</code> 和 <code>Session</code> 的映射关系，只需要实现下面这几个方法实现对 session 的增删查改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Provider <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-comment">// 新增并返回一个 session</span><br>    SessionCreate(sid <span class="hljs-keyword">string</span>) (Session, error)<br>    <span class="hljs-comment">// 删除一个 session</span><br>    SessionDestroy(sid <span class="hljs-keyword">string</span>)<br>    <span class="hljs-comment">// 查找一个 session</span><br>    SessionRead(sid <span class="hljs-keyword">string</span>) (Session, error)<br>    <span class="hljs-comment">// 修改一个session</span><br>    SessionUpdate(sid <span class="hljs-keyword">string</span>)<br>    <span class="hljs-comment">// 通过类似 LRU 的算法回收过期的 session</span><br>SessionGC(maxLifeTime <span class="hljs-keyword">int64</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后说 <code>Manager</code>，大部分具体工作都委托给 <code>Session</code> 和 <code>Provider</code> 承担了，<code>Manager</code> 主要就是一个参数集合，比如 session 的存活时间，清理过期 session 的策略，以及 session 的可用存储方式。<code>Manager</code> 屏蔽了操作的具体细节，我们可以通过 <code>Manager</code> 灵活地配置 session 机制。<br>综上，session 机制分成几部分的最主要原因就是解耦，实现定制化。我在 Github 上看过几个 Go 语言实现的 session 服务，源码都很简单，有兴趣的朋友可以学习学习：<br><a href="https://github.com/alexedwards/scs">https://github.com/alexedwards/scs</a><br><a href="https://github.com/astaxie/build-web-application-with-golang">https://github.com/astaxie/build-web-application-with-golang</a></p><p><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B">上一篇：Linux的进程、线程、文件描述符是什么</a><br><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/linuxshell">下一篇：关于 Linux shell 你必须知道的</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码技术</title>
      <link href="2016/01/01/%E6%8A%80%E6%9C%AF/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
      <url>2016/01/01/%E6%8A%80%E6%9C%AF/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>说到密码，我们第一个想到的就是登陆账户的密码，但是从密码学的角度来看，这种根本就不算合格的密码。<br>为什么呢，因为我们的账户密码，是依靠隐蔽性来达到加密作用：密码藏在我心里，你不知道，所以你登不上我的账户。<br>然而密码技术认为，「保密」信息总有一天会被扒出来，所以加密算法不应该依靠「保密」来保证机密性，而应该做到：即便知道了加密算法，依然无计可施。说的魔幻一点就是，告诉你我的密码，你依然不知道我的密码。</p><p>最玄学的就是 Diffie-Hellman 密钥交换算法，我当初就觉得很惊奇，两个人当着你的面互相报几个数字，他们就可以拥有一个共同的秘密，而你却根本不可能算出来这个秘密。下文会着重介绍一下这个算法。<br>本文讨论的密码技术要解决的主要是信息传输中的加密和解密问题。要假设数据传输过程是不安全的，所有信息都在被窃听的，所以发送端要把信息加密，接收方收到信息之后，肯定得知道如何解密。有意思的是，如果你能够让接收者知道如何解密，那么窃听者不是也能够知道如何解密了吗？<br>下面，<strong>我们会介绍对称加密算法、密钥交换算法、非对称加密算法、数字签名、公钥证书</strong>，看看解决安全传输问题的一路坎坷波折。</p><h3 id="一、对称性加密"><a href="#一、对称性加密" class="headerlink" title="一、对称性加密"></a>一、对称性加密</h3><p>对称性密码，也叫共享密钥密码，顾名思义，这种加密方式用相同的密钥进行加密和解密。<br>比如我说一种最简单的对称加密的方法。首先我们知道信息都可以表示成 0/1 比特序列，也知道相同的两个比特序列做异或运算的结果为 0。<br>那么我们就可以生成一个长度和原始信息一样的随机比特序列作为密钥，然后用它对原始信息做异或运算，就生成了密文。反之，再用该密钥对密文做一次异或运算，就可以恢复原始信息。<br>这是一个简单例子，不过有些过于简单，有很多问题。比如密钥的长度和原始信息完全一致，如果原始信息很大，密钥也会一样大，而且生成大量真随机比特序列的计算开销也比较大。<br>当然，有很多更复杂优秀的对称加密算法解决了这些问题，比如 Rijndael 算法、三重 DES 算法等等。<strong>它们从算法上是无懈可击的，也就是拥有巨大的密钥空间，基本无法暴力破解，而且加密过程相对快速</strong>。<br><strong>但是，一切对称加密算法的软肋在于密钥的配送</strong>。加密和解密用同一个密钥，发送方必须设法把密钥发送给接收方。如果窃听者有能力窃取密文，肯定也可以窃取密钥，那么再无懈可击的算法依然不攻自破。<br>所以，下面介绍两种解决密钥配送问题最常见的算法，分别是 Diffie-Hellman 密钥交换算法和非对称加密算法。</p><h3 id="二、密钥交换算法"><a href="#二、密钥交换算法" class="headerlink" title="二、密钥交换算法"></a>二、密钥交换算法</h3><p>我们所说的密钥一般就是一个很大的数字，算法用这个数加密、解密。问题在于，信道是不安全的，所有发出的数据都会被窃取。换句话说，有没有一种办法，能够让两个人在众目睽睽之下，光明正大地交换一个秘密，把对称性密钥安全地送到接收方的手中？<br>Diffie-Hellman 密钥交换算法可以做到。<strong>准确的说，该算法并不是把一个秘密安全地「送给」对方，而是通过一些共享的数字，双方「心中」各自「生成」了一个相同的秘密，而且双方的这个秘密，是第三方窃听者无法生成的</strong>。<br>也许这就是传说中的心有灵犀一点通吧。<br>这个算法规则不算复杂，你甚至都可以找个朋友尝试一下共享秘密，等会我会简单画出它的基本流程。在此之前，需要明确一个问题：<strong>并不是所有运算都有逆运算</strong>。<br>最简单的例子就是我们熟知的单向散列函数，给一个数字 <code>a</code> 和一个散列函数 <code>f</code>，你可以很快计算出 <code>f(a)</code>，但是如果给你 <code>f(a)</code> 和 <code>f</code>，推出 <code>a</code> 是一件基本做不到的事。密钥交换算法之所以看起来如此玄幻，就是利用了这种不可逆的性质。<br>下面，看下密钥交换算法的流程是什么，按照命名惯例，准备执行密钥交换算法的双方称为 Alice 和 Bob，在网络中企图窃取他俩通信内容的坏人称为 Hack 吧。<br>首先，Alice 和 Bob 协商出两个数字 <code>N</code> 和 <code>G</code> 作为生成元，当然协商过程可以被窃听者 Hack 窃取，所以我把这两个数画到中间，代表三方都知道：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/1.jpg"><br>现在 Alice 和 Bob <strong>心中</strong>各自想一个数字出来，分别称为 <code>A</code> 和 <code>B</code> 吧：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/2.jpg"><br>现在 Alice 将自己心里的这个数字 <code>A</code> 和 <code>G</code> 通过某些运算得出一个数 <code>AG</code>，然后发给 Bob；Bob 将自己心里的数 <code>B</code> 和 <code>G</code> 通过相同的运算得出一个数 <code>BG</code>，然后发给 Alice：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/3.jpg"><br>现在的情况变成这样了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/4.jpg"><br>注意，类似刚才举的散列函数的例子，知道 <code>AG</code> 和 <code>G</code>，并不能反推出 <code>A</code> 是多少，<code>BG</code> 同理。<br>那么，Alice 可以通过 <code>BG</code> 和自己的 <code>A</code> 通过某些运算得到一个数 <code>ABG</code>，Bob 也可以通过 <code>AG</code> 和自己的 <code>B</code> 通过某些运算得到 <code>ABG</code>，这个数就是 Alice 和 Bob 共有的秘密。<br>而对于 Hack，可以窃取传输过程中的 <code>G</code>，<code>AG</code>，<code>BG</code>，但是由于计算不可逆，怎么都无法结合出 <code>ABG</code> 这个数字。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/5.jpg"><br>以上就是基本流程，至于具体的数字取值是有讲究的，运算方法在百度上很容易找到，限于篇幅我就不具体写了。<br>该算法可以在第三者窃听的前提下，算出一个别人无法算出的秘密作为对称性加密算法的密钥，开始对称加密的通信。<br>对于该算法，Hack 又想到一种破解方法，不是窃听 Alice 和 Bob 的通信数据，而是直接同时冒充 Alice 和 Bob 的身份，也就是我们说的「<strong>中间人攻击</strong>」：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/6.jpg"><br>这样，双方根本无法察觉在和 Hack 共享秘密，后果就是 Hack 可以解密甚至修改数据。<br><strong>可见，密钥交换算法也不算完全解决了密钥配送问题，缺陷在于无法核实对方身份</strong>。所以密钥交换算法之前一般要核实对方身份，比如使用数字签名。</p><h3 id="三、非对称加密"><a href="#三、非对称加密" class="headerlink" title="三、非对称加密"></a>三、非对称加密</h3><p>非对称加密的思路就是，干脆别偷偷摸摸传输密钥了，我把加密密钥和解密密钥分开，公钥用于加密，私钥用于解密。只把公钥传送给对方，然后对方开始给我发送加密的数据，我用私钥就可以解密。至于窃听者，拿到公钥和加密数据也没用，因为只有我手上的私钥才能解密。<br>可以这样想，<strong>私钥是钥匙，而公钥是锁，可以把锁公开出去，让别人把数据锁起来发给我；而钥匙一定要留在自己手里，用于解锁</strong>。我们常见的 RSA 算法就是典型的非对称加密算法，具体实现比较复杂，我就不写了，网上很多资料。<br>在实际应用中，非对称性加密的运算速度要比对称性加密慢很多的，所以传输大量数据时，一般不会用公钥直接加密数据，而是加密对称性加密的密钥，传输给对方，然后双方使用对称性加密算法传输数据。<br>需要注意的是，类似 Diffie-Hellman 算法，<strong>非对称加密算法也无法确定通信双方的身份，依然会遭到中间人攻击</strong>。比如 Hack 拦截 Bob 发出的公钥，然后冒充 Bob 的身份给 Alice 发送自己的公钥，那么不知情的 Alice 就会把私密数据用 Hack 的公钥加密，Hack 可以通过私钥解密窃取。<br>那么，Diffie-Hellman 算法和 RSA 非对称加密算法都可以一定程度上解决密钥配送的问题，也具有相同的缺陷，二者的应用场景有什么区别呢？<br>简单来说，根据两种算法的基本原理就可以看出来：<br>如果双方有一个对称加密方案，希望加密通信，而且不能让别人得到钥匙，那么可以使用 Diffie-Hellman 算法交换密钥。<br>如果你希望任何人都可以对信息加密，而只有你能够解密，那么就使用 RSA 非对称加密算法，公布公钥。<br>下面，我们尝试着解决认证发送方身份的问题。</p><h3 id="四、数字签名"><a href="#四、数字签名" class="headerlink" title="四、数字签名"></a>四、数字签名</h3><p>刚才说非对称加密，把公钥公开用于他人对数据加密然后发给你，只有用你手上对应的私钥才能将密文解密。其实，<strong>私钥也可用用来加密数据的，对于 RSA 算法，私钥加密的数据只有公钥才能解开</strong>。<br>数字签名也是利用了非对称性密钥的特性，但是和公钥加密完全颠倒过来：<strong>仍然公布公钥，但是用你的私钥加密数据，然后把加密的数据公布出去，这就是数字签名</strong>。<br>你可能问，这有什么用，公钥可以解开私钥加密，我还加密发出去，不是多此一举吗？<br>是的，但是<strong>数字签名的作用本来就不是保证数据的机密性，而是证明你的身份</strong>，证明这些数据确实是由你本人发出的。<br>你想想，你的私钥加密的数据，只有你的公钥才能解开，那么如果一份加密数据能够被你的公钥解开，不就说明这份数据是你（私钥持有者）本人发布的吗？<br>当然，加密数据仅仅是一个签名，签名应该和数据一同发出，具体流程应该是：<br>1、Bob 生成公钥和私钥，然后把公钥公布出去，私钥自己保留。<br>2、<strong>用私钥加密数据作为签名，然后将数据附带着签名一同发布出去</strong>。<br>3、Alice 收到数据和签名，需要检查此份数据是否是 Bob 所发出，于是用 Bob 之前发出的公钥尝试解密签名，将收到的数据和签名解密后的结果作对比，如果完全相同，说明数据没被篡改，且确实由 Bob 发出。<br>为什么 Alice 这么肯定呢，毕竟数据和签名是两部分，都可以被掉包呀？原因如下：<br>1、如果有人修改了数据，那么 Alice 解密签名之后，对比发现二者不一致，察觉出异常。<br>2、如果有人替换了签名，那么 Alice 用 Bob 的公钥只能解出一串乱码，显然和数据不一致。<br>3、也许有人企图修改数据，然后将修改之后的数据制成签名，使得 Alice 的对比无法发现不一致；但是一旦解开签名，就不可能再重新生成 Bob 的签名了，因为没有 Bob 的私钥。<br>综上，<strong>数字签名可以一定程度上认证数据的来源</strong>。之所以说是一定程度上，是因为这种方式依然可能受到中间人攻击。一旦涉及公钥的发布，接收方就可能收到中间人的假公钥，进行错误的认证，这个问题始终避免不了。<br>说来可笑，数字签名就是验证对方身份的一种方式，但是前提是对方的身份必须是真的… 这似乎陷入一个先有鸡还是先有蛋的死循环，<strong>要想确定对方的身份，必须有一个信任的源头，否则的话，再多的流程也只是在转移问题，而不是真正解决问题</strong>。</p><h3 id="五、公钥证书"><a href="#五、公钥证书" class="headerlink" title="五、公钥证书"></a>五、公钥证书</h3><p><strong>证书其实就是公钥 + 签名，由第三方认证机构颁发</strong>。引入可信任的第三方，是终结信任循环的一种可行方案。<br>证书认证的流程大致如下：<br>1、Bob 去可信任的认证机构证实本人真实身份，并提供自己的公钥。<br>2、Alice 想跟 Bob 通信，首先向认证机构请求 Bob 的公钥，认证机构会把一张证书（Bob 的公钥以及自己对其公钥的签名）发送给 Alice。<br>3、Alice 检查签名，确定该公钥确实由这家认证机构发送，中途未被篡改。<br>4、Alice 通过这个公钥加密数据，开始和 Bob 通信。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/7.jpg" alt="图片来自《图解密码技术》"><br>PS：以上只是为了说明，证书只需要安装一次，并不需要每次都向认证机构请求；一般是服务器直接给客户端发送证书，而不是认证机构。<br>也许有人问，Alice 要想通过数字签名确定证书的有效性，前提是要有该机构的（认证）公钥，这不是又回到刚才的死循环了吗？<br>我们安装的正规浏览器中都预存了正规认证机构的证书（包含其公钥），用于确认机构身份，所以说证书的认证是可信的。<br>Bob 向机构提供公钥的过程中，需要提供很多个人信息进行身份验证，比较严格，所以说也算是可靠的。<br>获得了 Bob 的可信公钥，Alice 和 Bob 之间的通信基于加密算法的保护，是完全无懈可击的。<br>现在的正规网站，大都使用 HTTPS 协议，就是在 HTTP 协议和 TCP 协议之间加了一个 SSL/TLS 安全层。在你的浏览器和网站服务器完成 TCP 握手后，SSL 协议层也会进行 SSL 握手交换安全参数，其中就包含该网站的证书，以便浏览器验证站点身份。SSL 安全层验证完成之后，上层的 HTTP 协议内容都会被加密，保证数据的安全传输。<br>这样一来，传统的中间人攻击就几乎没有了生存空间，攻击手段只能由技术缺陷转变为坑蒙拐骗。事实上，这种手段的效果反而更高效，比如我就发现<strong>网上不少下载网站发布的浏览器，不仅包含乱七八糟的导航和收藏网址，还包含一些不正规的认证机构证书。任何人都可以申请证书，这些不正规证书很可能造成安全隐患</strong>。</p><h3 id="六、最后总结"><a href="#六、最后总结" class="headerlink" title="六、最后总结"></a>六、最后总结</h3><p>对称性加密算法使用同一个密钥加密和解密，难以破解，加密速度较快，但是存在密钥配送问题。<br>Diffie-Hellman 密钥交换算法可以让双方「心有灵犀一点通」，一定程度解决密钥配送问题，但是无法验证通信方的身份，所以可能受到中间人攻击。<br>非对称性加密算法生成一对儿密钥，把加密和解密的工作分开了。<br>RSA 算法作为经典的非对称加密算法，有两种用途：如果用于加密，可以把公钥发布出去用于加密，只有自己的私钥可以解密，保证了数据的机密性；如果用于数字签名，把公钥发布出去后，用私钥加密数据作为签名，以证明该数据由私钥持有者所发送。但是无论那种用法，涉及公钥的发布，都无法避免中间人攻击。<br>公钥证书就是公钥 + 签名，由可信任的第三方认证机构颁发。由于正规浏览器都预装了可信的认证机构的公钥，所以可以有效防止中间人攻击。<br>HTTPS 协议中的 SSL/TLS 安全层会组合使用以上几种加密方式，<strong>所以说不要安装非正规的浏览器，不要乱安装未知来源的证书</strong>。<br>密码技术只是安全的一小部分，即便是通过正规机构认证的 HTTPS 站点，也不意味着可信任，只能说明其数据传输是安全的。技术永远不可能真正保护你，最重要的还是得提高个人的安全防范意识，多留心眼儿，谨慎处理敏感数据。</p><p><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/linuxshell">上一篇：关于 Linux shell 你必须知道的</a><br><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/%E5%9C%A8%E7%BA%BF%E7%BB%83%E4%B9%A0%E5%B9%B3%E5%8F%B0">下一篇：Git/SQL/正则表达式的在线练习平台</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉堆详解实现优先级队列</title>
      <link href="2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
      <url>2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉堆详解实现优先级队列"><a href="#二叉堆详解实现优先级队列" class="headerlink" title="二叉堆详解实现优先级队列"></a>二叉堆详解实现优先级队列</h1><p>二叉堆（Binary Heap）没什么神秘，性质比二叉搜索树 BST 还简单。其主要操作就两个，<code>sink</code>（下沉）和 <code>swim</code>（上浮），用以维护二叉堆的性质。其主要应用有两个，首先是一种排序方法「堆排序」，第二是一种很有用的数据结构「优先级队列」。<br>本文就以实现优先级队列（Priority Queue）为例，通过图片和人类的语言来描述一下二叉堆怎么运作的。</p><h3 id="一、二叉堆概览"><a href="#一、二叉堆概览" class="headerlink" title="一、二叉堆概览"></a>一、二叉堆概览</h3><p>首先，二叉堆和二叉树有啥关系呢，为什么人们总数把二叉堆画成一棵二叉树？<br>因为，二叉堆其实就是一种特殊的二叉树（完全二叉树），只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父节点的索引</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> root / <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// 左孩子的索引</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> root * <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// 右孩子的索引</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> root * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>画个图你立即就能理解了，注意数组的第一个索引 0 空着不用，<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/heap/1.png" alt="1"><br>PS：因为数组索引是数组，为了方便区分，将字符作为数组元素。<br>你看到了，把 arr[1] 作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。为了方便讲解，下面都会画的图都是二叉树结构，相信你能把树和数组对应起来。<br>二叉堆还分为最大堆和最小堆。<strong>最大堆的性质是：每个节点都大于等于它的两个子节点。</strong>类似的，最小堆的性质是：每个节点都小于等于它的子节点。<br>两种堆核心思路都是一样的，本文以最大堆为例讲解。<br>对于一个最大堆，根据其性质，显然堆顶，也就是 arr[1] 一定是所有元素中最大的元素。</p><h3 id="二、优先级队列概览"><a href="#二、优先级队列概览" class="headerlink" title="二、优先级队列概览"></a>二、优先级队列概览</h3><p>优先级队列这种数据结构有一个很有用的功能，你插入或者删除元素的时候，元素会自动排序，这底层的原理就是二叉堆的操作。<br>数据结构的功能无非增删查该，优先级队列有两个主要 API，分别是 <code>insert</code> 插入一个元素和 <code>delMax</code> 删除最大元素（如果底层用最小堆，那么就是 <code>delMin</code>）。<br>下面我们实现一个简化的优先级队列，先看下代码框架：<br>PS：为了清晰起见，这里用到 Java 的泛型，<code>Key</code> 可以是任何一种可比较大小的数据类型，你可以认为它是 int、char 等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxPQ</span></span><br><span class="hljs-class">    &lt;<span class="hljs-title">Key</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Key</span>&gt;&gt; </span>&#123;<br>    <span class="hljs-comment">// 存储元素的数组</span><br>    <span class="hljs-keyword">private</span> Key[] pq;<br>    <span class="hljs-comment">// 当前 Priority Queue 中的元素个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxPQ</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>        <span class="hljs-comment">// 索引 0 不用，所以多分配一个空间</span><br>        pq = (Key[]) <span class="hljs-keyword">new</span> Comparable[cap + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">/* 返回当前队列中最大元素 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Key <span class="hljs-title">max</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pq[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">/* 插入元素 e */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Key e)</span> </span>&#123;...&#125;<br>    <span class="hljs-comment">/* 删除并返回当前队列中最大元素 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Key <span class="hljs-title">delMax</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    <span class="hljs-comment">/* 上浮第 k 个元素，以维护最大堆性质 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;...&#125;<br>    <span class="hljs-comment">/* 下沉第 k 个元素，以维护最大堆性质 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;...&#125;<br>    <span class="hljs-comment">/* 交换数组的两个元素 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        Key temp = pq[i];<br>        pq[i] = pq[j];<br>        pq[j] = temp;<br>    &#125;<br>    <span class="hljs-comment">/* pq[i] 是否比 pq[j] 小？ */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">less</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">/* 还有 left, right, parent 三个方法 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>空出来的四个方法是二叉堆和优先级队列的奥妙所在，下面用图文来逐个理解。</p><h3 id="三、实现-swim-和-sink"><a href="#三、实现-swim-和-sink" class="headerlink" title="三、实现 swim 和 sink"></a>三、实现 swim 和 sink</h3><p>为什么要有上浮 swim 和下沉 sink 的操作呢？为了维护堆结构。<br>我们要讲的是最大堆，每个节点都比它的两个子节点大，但是在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。<br>对于最大堆，会破坏堆性质的有有两种情况：</p><ol><li>如果某个节点 A 比它的子节点（中的一个）小，那么 A 就不配做父节点，应该下去，下面那个更大的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</li><li>如果某个节点 A 比它的父节点大，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。<br>当然，错位的节点 A 可能要上浮（或下沉）很多次，才能到达正确的位置，恢复堆的性质。所以代码中肯定有一个 <code>while</code> 循环。<br>细心的读者也许会问，这两个操作不是互逆吗，所以上浮的操作一定能用下沉来完成，为什么我还要费劲写两个方法？<br>是的，操作是互逆等价的，但是最终我们的操作只会在堆底和堆顶进行（等会讲原因），显然堆底的「错位」元素需要上浮，堆顶的「错位」元素需要下沉。</li></ol><p><strong>上浮的代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果浮到堆顶，就不能再上浮了</span><br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">1</span> &amp;&amp; less(parent(k), k)) &#123;<br>        <span class="hljs-comment">// 如果第 k 个元素比上层大</span><br>        <span class="hljs-comment">// 将 k 换上去</span><br>        exch(parent(k), k);<br>        k = parent(k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>画个 GIF 看一眼就明白了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/heap/swim.gif" alt="2"><br><strong>下沉的代码实现：</strong><br>下沉比上浮略微复杂一点，因为上浮某个节点 A，只需要 A 和其父节点比较大小即可；但是下沉某个节点 A，需要 A 和其<strong>两个子节点</strong>比较大小，如果 A 不是最大的就需要调整位置，要把较大的那个子节点和 A 交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果沉到堆底，就沉不下去了</span><br>    <span class="hljs-keyword">while</span> (left(k) &lt;= N) &#123;<br>        <span class="hljs-comment">// 先假设左边节点较大</span><br>        <span class="hljs-keyword">int</span> older = left(k);<br>        <span class="hljs-comment">// 如果右边节点存在，比一下大小</span><br>        <span class="hljs-keyword">if</span> (right(k) &lt;= N &amp;&amp; less(older, right(k)))<br>            older = right(k);<br>        <span class="hljs-comment">// 结点 k 比俩孩子都大，就不必下沉了</span><br>        <span class="hljs-keyword">if</span> (less(older, k)) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 否则，不符合最大堆的结构，下沉 k 结点</span><br>        exch(k, older);<br>        k = older;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>画个 GIF 看下就明白了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/heap/sink.gif" alt="3"><br>至此，二叉堆的主要操作就讲完了，一点都不难吧，代码加起来也就十行。明白了 <code>sink</code> 和 <code>swim</code> 的行为，下面就可以实现优先级队列了。</p><h3 id="四、实现-delMax-和-insert"><a href="#四、实现-delMax-和-insert" class="headerlink" title="四、实现 delMax 和 insert"></a>四、实现 delMax 和 insert</h3><p>这两个方法就是建立在 <code>swim</code> 和 <code>sink</code> 上的。<br>**<code>insert</code> 方法先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置。**<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/heap/insert.gif" alt="4"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Key e)</span> </span>&#123;<br>    N++;<br>    <span class="hljs-comment">// 先把新元素加到最后</span><br>    pq[N] = e;<br>    <span class="hljs-comment">// 然后让它上浮到正确的位置</span><br>    swim(N);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>delMax</code> 方法先把堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A，最后让 B 下沉到正确位置。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Key <span class="hljs-title">delMax</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 最大堆的堆顶就是最大元素</span><br>    Key max = pq[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 把这个最大元素换到最后，删除之</span><br>    exch(<span class="hljs-number">1</span>, N);<br>    pq[N] = <span class="hljs-keyword">null</span>;<br>    N--;<br>    <span class="hljs-comment">// 让 pq[1] 下沉到正确位置</span><br>    sink(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/heap/delete.gif" alt="5"><br>至此，一个优先级队列就实现了，插入和删除元素的时间复杂度为 $O(logK)$，$K$ 为当前二叉堆（优先级队列）中的元素总数。因为我们时间复杂度主要花费在 <code>sink</code> 或者 <code>swim</code> 上，而不管上浮还是下沉，最多也就树（堆）的高度，也就是 log 级别。</p><h3 id="五、最后总结"><a href="#五、最后总结" class="headerlink" title="五、最后总结"></a>五、最后总结</h3><p>二叉堆就是一种完全二叉树，所以适合存储在数组中，而且二叉堆拥有一些特殊性质。<br>二叉堆的操作很简单，主要就是上浮和下沉，来维护堆的性质（堆有序），核心代码也就十行。<br>优先级队列是基于二叉堆实现的，主要操作是插入和删除。插入是先插到最后，然后上浮到正确位置；删除是调换位置后再删除，然后下沉到正确位置。核心代码也就十行。<br>也许这就是数据结构的威力，简单的操作就能实现巧妙的功能，真心佩服发明二叉堆算法的人！</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%954">上一篇：学习数据结构和算法读什么书</a><br><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/LRU%E7%AE%97%E6%B3%95">下一篇：LRU算法详解</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树操作集锦</title>
      <link href="2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%93%8D%E4%BD%9C%E9%9B%86%E9%94%A6/"/>
      <url>2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%93%8D%E4%BD%9C%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树操作集锦"><a href="#二叉搜索树操作集锦" class="headerlink" title="二叉搜索树操作集锦"></a>二叉搜索树操作集锦</h1><p>通过之前的文章<a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E6%95%88%E6%96%B9%E6%B3%95">框架思维</a>，二叉树的遍历框架应该已经印到你的脑子里了，这篇文章就来实操一下，看看框架思维是怎么灵活运用，秒杀一切二叉树问题的。<br>二叉树算法的设计的总路线：明确一个节点要做的事情，然后剩下的事抛给框架。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">// root 需要做什么？在这做。</span><br>    <span class="hljs-comment">// 其他的不用 root 操心，抛给框架</span><br>    traverse(root.left);<br>    traverse(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><p>举两个简单的例子体会一下这个思路，热热身。<br><strong>1. 如何把二叉树所有的节点中的值加一？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">plusOne</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>    root.val += <span class="hljs-number">1</span>;<br>    plusOne(root.left);<br>    plusOne(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. 如何判断两棵二叉树是否完全相同？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> </span>&#123;<br>    <span class="hljs-comment">// 都为空的话，显然相同</span><br>    <span class="hljs-keyword">if</span> (root1 == <span class="hljs-keyword">null</span> &amp;&amp; root2 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">// 一个为空，一个非空，显然不同</span><br>    <span class="hljs-keyword">if</span> (root1 == <span class="hljs-keyword">null</span> || root2 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 两个都非空，但 val 不一样也不行</span><br>    <span class="hljs-keyword">if</span> (root1.val != root2.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// root1 和 root2 该比的都比完了</span><br>    <span class="hljs-keyword">return</span> isSameTree(root1.left, root2.left)<br>        &amp;&amp; isSameTree(root1.right, root2.right);<br>&#125;<br></code></pre></td></tr></table></figure><p>借助框架，上面这两个例子不难理解吧？如果可以理解，那么所有二叉树算法你都能解决。</p><p>二叉搜索树（Binary Search Tree，简称 BST）是一种很常用的的二叉树。它的定义是：一个二叉树中，任意节点的值要大于等于左子树所有节点的值，且要小于等于右边子树的所有节点的值。<br>如下就是一个符合定义的 BST：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/BST/BST_example.png" alt="BST"></p><p>下面实现 BST 的基础操作：判断 BST 的合法性、增、删、查。其中“删”和“判断合法性”略微复杂。<br><strong>零、判断 BST 的合法性</strong><br>这里是有坑的哦，我们按照刚才的思路，每个节点自己要做的事不就是比较自己和左右孩子吗？看起来应该这样写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span> &amp;&amp; root.val &lt;= root.left.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span> &amp;&amp; root.val &gt;= root.right.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> isValidBST(root.left)<br>        &amp;&amp; isValidBST(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这个算法出现了错误，BST 的每个节点应该要小于右边子树的所有节点，下面这个二叉树显然不是 BST，但是我们的算法会把它判定为 BST。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/BST/%E5%81%87BST.png" alt="notBST"><br>出现错误，不要慌张，框架没有错，一定是某个细节问题没注意到。我们重新看一下 BST 的定义，root 需要做的不只是和左右子节点比较，而是要整个左子树和右子树所有节点比较。怎么办，鞭长莫及啊！<br>这种情况，我们可以使用辅助函数，增加函数参数列表，在参数中携带额外信息，请看正确的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> isValidBST(root, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root, TreeNode min, TreeNode max)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (min != <span class="hljs-keyword">null</span> &amp;&amp; root.val &lt;= min.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (max != <span class="hljs-keyword">null</span> &amp;&amp; root.val &gt;= max.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> isValidBST(root.left, min, root) <br>        &amp;&amp; isValidBST(root.right, root, max);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一、在 BST 中查找一个数是否存在</strong><br>根据我们的指导思想，可以这样写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isInBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (root.val == target) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span> isInBST(root.left, target)<br>        || isInBST(root.right, target);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写完全正确，充分证明了你的框架性思维已经养成。现在你可以考虑一点细节问题了：如何充分利用信息，把 BST 这个“左小右大”的特性用上？<br>很简单，其实不需要递归地搜索两边，类似二分查找思想，根据 target 和 root.val 的大小比较，就能排除一边。我们把上面的思路稍稍改动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isInBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (root.val == target)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (root.val &lt; target) <br>        <span class="hljs-keyword">return</span> isInBST(root.right, target);<br>    <span class="hljs-keyword">if</span> (root.val &gt; target)<br>        <span class="hljs-keyword">return</span> isInBST(root.left, target);<br>    <span class="hljs-comment">// root 该做的事做完了，顺带把框架也完成了，妙</span><br>&#125;<br></code></pre></td></tr></table></figure><p>于是，我们对原始框架进行改造，抽象出一套<strong>针对 BST 的遍历框架</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root.val == target)<br>        <span class="hljs-comment">// 找到目标，做点什么</span><br>    <span class="hljs-keyword">if</span> (root.val &lt; target) <br>        BST(root.right, target);<br>    <span class="hljs-keyword">if</span> (root.val &gt; target)<br>        BST(root.left, target);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二、在 BST 中插入一个数</strong><br>对数据结构的操作无非遍历 + 访问，遍历就是“找”，访问就是“改”。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。<br>上一个问题，我们总结了 BST 中的遍历框架，就是“找”的问题。直接套框架，加上“改”的操作即可。一旦涉及“改”，函数就要返回 TreeNode 类型，并且对递归调用的返回值进行接收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">TreeNode <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-comment">// 找到空位置插入新节点</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(val);<br>    <span class="hljs-comment">// if (root.val == val)</span><br>    <span class="hljs-comment">//     BST 中一般不会插入已存在元素</span><br>    <span class="hljs-keyword">if</span> (root.val &lt; val) <br>        root.right = insertIntoBST(root.right, val);<br>    <span class="hljs-keyword">if</span> (root.val &gt; val) <br>        root.left = insertIntoBST(root.left, val);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>三、在 BST 中删除一个数</strong><br>这个问题稍微复杂，不过你有框架指导，难不住你。跟插入操作类似，先“找”再“改”，先把框架写出来再说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">TreeNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root.val == key) &#123;<br>        <span class="hljs-comment">// 找到啦，进行删除</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &gt; key) &#123;<br>        root.left = deleteNode(root.left, key);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; key) &#123;<br>        root.right = deleteNode(root.right, key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>找到目标节点了，比方说是节点 A，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。<br>情况 1：A 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。<br>图片来自 LeetCode<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/BST/bst_deletion_case_1.png" alt="1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p>情况 2：A 只有一个非空子节点，那么它要让这个孩子接替自己的位置。<br>图片来自 LeetCode<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/BST/bst_deletion_case_2.png" alt="2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 排除了情况 1 之后</span><br><span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.right;<br><span class="hljs-keyword">if</span> (root.right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.left;<br></code></pre></td></tr></table></figure><p>情况 3：A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。<br>图片来自 LeetCode<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/BST/bst_deletion_case_3.png" alt="2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span> &amp;&amp; root.right != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// 找到右子树的最小节点</span><br>    TreeNode minNode = getMin(root.right);<br>    <span class="hljs-comment">// 把 root 改成 minNode</span><br>    root.val = minNode.val;<br>    <span class="hljs-comment">// 转而去删除 minNode</span><br>    root.right = deleteNode(root.right, minNode.val);<br>&#125;<br></code></pre></td></tr></table></figure><p>三种情况分析完毕，填入框架，简化一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">TreeNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (root.val == key) &#123;<br>        <span class="hljs-comment">// 这两个 if 把情况 1 和 2 都正确处理了</span><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.right;<br>        <span class="hljs-keyword">if</span> (root.right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.left;<br>        <span class="hljs-comment">// 处理情况 3</span><br>        TreeNode minNode = getMin(root.right);<br>        root.val = minNode.val;<br>        root.right = deleteNode(root.right, minNode.val);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &gt; key) &#123;<br>        root.left = deleteNode(root.left, key);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; key) &#123;<br>        root.right = deleteNode(root.right, key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function">TreeNode <span class="hljs-title">getMin</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;<br>    <span class="hljs-comment">// BST 最左边的就是最小的</span><br>    <span class="hljs-keyword">while</span> (node.left != <span class="hljs-keyword">null</span>) node = node.left;<br>    <span class="hljs-keyword">return</span> node;<br>&#125; <br></code></pre></td></tr></table></figure><p>删除操作就完成了。注意一下，这个删除操作并不完美，因为我们一般不会通过 root.val = minNode.val 修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换 root 和 minNode 两个节点。因为具体应用中，val 域可能会很大，修改起来很耗时，而链表操作无非改一改指针，而不会去碰内部数据。<br>但这里忽略这个细节，旨在突出 BST 基本操作的共性，以及借助框架逐层细化问题的思维方式。<br><strong>四、最后总结</strong><br>通过这篇文章，你学会了如下几个技巧：</p><ol><li>二叉树算法设计的总路线：把当前节点要做的事做好，其他的交给递归框架，不用当前节点操心。</li><li>如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。</li><li>在二叉树框架之上，扩展出一套 BST 遍历框架：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root.val == target)<br>        <span class="hljs-comment">// 找到目标，做点什么</span><br>    <span class="hljs-keyword">if</span> (root.val &lt; target) <br>        BST(root.right, target);<br>    <span class="hljs-keyword">if</span> (root.val &gt; target)<br>        BST(root.left, target);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>掌握了 BST 的基本操作。</li></ol><p><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/LRU%E7%AE%97%E6%B3%95">上一篇：LRU算法详解</a><br><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88">下一篇：特殊数据结构：单调栈</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="如何使用单调栈解题"><a href="#如何使用单调栈解题" class="headerlink" title="如何使用单调栈解题"></a>如何使用单调栈解题</h3><p>栈（stack）是很简单的一种数据结构，先进后出的逻辑顺序，符合某些问题的特点，比如说函数调用栈。<br>单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。<br>听起来有点像堆（heap）？不是的，单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。本文用讲解单调队列的算法模版解决这类问题，并且探讨处理「循环数组」的策略。<br>首先，讲解 Next Greater Number 的原始问题：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。不好用语言解释清楚，直接上一个例子：<br>给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。<br>解释：第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。<br>这道题的暴力解法很好想到，就是对每个元素后面都进行扫描，找到第一个更大的元素就行了。但是暴力解法的时间复杂度是 O(n^2)。<br>这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的 Next Greater Number 呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的 Next Greater Number，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8D%95%E8%B0%83%E6%A0%88/1.png" alt="ink-image"><br>这个情景很好理解吧？带着这个抽象的情景，先来看下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums.size())</span></span>; <span class="hljs-comment">// 存放答案的数组</span><br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 倒着往栈里放</span><br>        <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123; <span class="hljs-comment">// 判定个子高矮</span><br>            s.pop(); <span class="hljs-comment">// 矮个起开，反正也被挡着了。。。</span><br>        &#125;<br>        ans[i] = s.empty() ? <span class="hljs-number">-1</span> : s.top(); <span class="hljs-comment">// 这个元素身后的第一个高个</span><br>        s.push(nums[i]); <span class="hljs-comment">// 进队，接受之后的身高判定吧！</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是单调队列解决问题的模板。for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个“高个”元素之间的元素排除，因为他们的存在没有意义，前面挡着个“更高”的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。<br>这个算法的时间复杂度不是那么直观，如果你看到 for 循环嵌套 while 循环，可能认为这个算法的复杂度也是 O(n^2)，但是实际上这个算法的复杂度只有 O(n)。<br>分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 n 成正比的，也就是 O(n) 的复杂度。<br>现在，你已经掌握了单调栈的使用技巧，来一个简单的变形来加深一下理解。<br>给你一个数组 T = [73, 74, 75, 71, 69, 72, 76, 73]，这个数组存放的是近几天的天气气温（这气温是铁板烧？不是的，这里用的华氏度）。你返回一个数组，计算：对于每一天，你还要至少等多少天才能等到一个更暖和的气温；如果等不到那一天，填 0 。<br>举例：给你 T = [73, 74, 75, 71, 69, 72, 76, 73]，你返回 [1, 1, 4, 2, 1, 1, 0, 0]。<br>解释：第一天 73 华氏度，第二天 74 华氏度，比 73 大，所以对于第一天，只要等一天就能等到一个更暖和的气温。后面的同理。<br>你已经对 Next Greater Number 类型问题有些敏感了，这个问题本质上也是找 Next Greater Number，只不过现在不是问你 Next Greater Number 是多少，而是问你当前距离 Next Greater Number 的距离而已。<br>相同类型的问题，相同的思路，直接调用单调栈的算法模板，稍作改动就可以啦，直接上代码把。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; T)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(T.size())</span></span>;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s; <span class="hljs-comment">// 这里放元素索引，而不是元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = T.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; T[s.top()] &lt;= T[i]) &#123;<br>            s.pop();<br>        &#125;<br>        ans[i] = s.empty() ? <span class="hljs-number">0</span> : (s.top() - i); <span class="hljs-comment">// 得到索引间距</span><br>        s.push(i); <span class="hljs-comment">// 加入索引，而不是元素</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>单调栈讲解完毕。下面开始另一个重点：如何处理「循环数组」。<br>同样是 Next Greater Number，现在假设给你的数组是个环形的，如何处理？<br>给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,4]。拥有了环形属性，最后一个元素 3 绕了一圈后找到了比自己大的元素 4 。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8D%95%E8%B0%83%E6%A0%88/2.png" alt="ink-image"></p><p>首先，计算机的内存都是线性的，没有真正意义上的环形数组，但是我们可以模拟出环形数组的效果，一般是通过 % 运算符求模（余数），获得环形特效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">int</span> n = arr.length, index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>    print(arr[index % n]);<br>    index++;<br>&#125;<br></code></pre></td></tr></table></figure><p>回到 Next Greater Number 的问题，增加了环形属性后，问题的难点在于：这个 Next 的意义不仅仅是当前元素的右边了，有可能出现在当前元素的左边（如上例）。<br>明确问题，问题就已经解决了一半了。我们可以考虑这样的思路：将原始数组“翻倍”，就是在后面再接一个原始数组，这样的话，按照之前“比身高”的流程，每个元素不仅可以比较自己右边的元素，而且也可以和左边的元素比较了。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8D%95%E8%B0%83%E6%A0%88/3.png" alt="ink-image (2)"><br>怎么实现呢？你当然可以把这个双倍长度的数组构造出来，然后套用算法模板。但是，我们可以不用构造新数组，而是利用循环数组的技巧来模拟。直接看代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.size();<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// 存放结果</span><br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-comment">// 假装这个数组长度翻倍了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i % n])<br>            s.pop();<br>        res[i % n] = s.empty() ? <span class="hljs-number">-1</span> : s.top();<br>        s.push(nums[i % n]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，你已经掌握了单调栈的设计方法及代码模板，学会了解决 Next Greater Number，并能够处理循环数组了。<br>你的在看，是对我的鼓励。关注公众号：labuladong</p><p><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%93%8D%E4%BD%9C%E9%9B%86%E9%94%A6">上一篇：二叉搜索树操作集锦</a><br><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97">下一篇：特殊数据结构：单调队列</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列</title>
      <link href="2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="特殊数据结构：单调队列"><a href="#特殊数据结构：单调队列" class="headerlink" title="特殊数据结构：单调队列"></a>特殊数据结构：单调队列</h1><p>前文讲了一种特殊的数据结构「单调栈」monotonic stack，解决了一类问题「Next Greater Number」，本文写一个类似的数据结构「单调队列」。<br>也许这种数据结构的名字你没听过，其实没啥难的，就是一个「队列」，只是使用了一点巧妙的方法，使得队列中的元素单调递增（或递减）。这个数据结构有什么用？可以解决滑动窗口的一系列问题。<br>看一道 LeetCode 题目，难度 hard：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/title.png"></p><h3 id="一、搭建解题框架"><a href="#一、搭建解题框架" class="headerlink" title="一、搭建解题框架"></a>一、搭建解题框架</h3><p>这道题不复杂，难点在于如何在 O(1) 时间算出每个「窗口」中的最大值，使得整个算法在线性时间完成。在之前我们探讨过类似的场景，得到一个结论：<br>在一堆数字中，已知最值，如果给这堆数添加一个数，那么比较一下就可以很快算出最值；但如果减少一个数，就不一定能很快得到最值了，而要遍历所有数重新找最值。<br>回到这道题的场景，每个窗口前进的时候，要添加一个数同时减少一个数，所以想在 O(1) 的时间得出新的最值，就需要「单调队列」这种特殊的数据结构来辅助了。<br>一个普通的队列一定有这两个操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<br>    <span class="hljs-comment">// 或 enqueue，在队尾加入元素 n</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 或 dequeue，删除队头元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个「单调队列」的操作也差不多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonotonicQueue</span> </span>&#123;<br>    <span class="hljs-comment">// 在队尾添加元素 n</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<br>    <span class="hljs-comment">// 返回当前队列中的最大值</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 队头元素如果是 n，删除它</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这几个 API 的实现方法肯定跟一般的 Queue 不一样，不过我们暂且不管，而且认为这几个操作的时间复杂度都是 O(1)，先把这道「滑动窗口」问题的解答框架搭出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    MonotonicQueue window;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; k - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//先把窗口的前 k - 1 填满</span><br>            window.push(nums[i]);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 窗口开始向前滑动</span><br>            window.push(nums[i]);<br>            res.push_back(window.max());<br>            window.pop(nums[i - k + <span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">// nums[i - k + 1] 就是窗口最后的元素</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/1.png" alt="图示"><br>这个思路很简单，能理解吧？下面我们开始重头戏，单调队列的实现。</p><h3 id="二、实现单调队列数据结构"><a href="#二、实现单调队列数据结构" class="headerlink" title="二、实现单调队列数据结构"></a>二、实现单调队列数据结构</h3><p>首先我们要认识另一种数据结构：deque，即双端队列。很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">deque</span> </span>&#123;<br>    <span class="hljs-comment">// 在队头插入元素 n</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<br>    <span class="hljs-comment">// 在队尾插入元素 n</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<br>    <span class="hljs-comment">// 在队头删除元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 在队尾删除元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 返回队头元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 返回队尾元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">back</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而且，这些操作的复杂度都是 O(1)。这其实不是啥稀奇的数据结构，用链表作为底层结构的话，很容易实现这些功能。<br>「单调队列」的核心思路和「单调栈」类似。单调队列的 push 方法依然在队尾添加元素，但是要把前面比新元素小的元素都删掉：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonotonicQueue</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!data.empty() &amp;&amp; data.back() &lt; n) <br>            data.pop_back();<br>        data.push_back(n);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>你可以想象，加入数字的大小代表人的体重，把前面体重不足的都压扁了，直到遇到更大的量级才停住。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/2.png"><br>如果每个元素被加入时都这样操作，最终单调队列中的元素大小就会保持一个单调递减的顺序，因此我们的 max() API 可以可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> data.front();<br>&#125;<br></code></pre></td></tr></table></figure><p>pop() API 在队头删除元素 n，也很好写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!data.empty() &amp;&amp; data.front() == n)<br>        data.pop_front();<br>&#125;<br></code></pre></td></tr></table></figure><p>之所以要判断 <code>data.front() == n</code>，是因为我们想删除的队头元素 n 可能已经被「压扁」了，这时候就不用删除了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/3.png"><br>至此，单调队列设计完毕，看下完整的解题代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonotonicQueue</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!data.empty() &amp;&amp; data.back() &lt; n) <br>            data.pop_back();<br>        data.push_back(n);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> data.front(); &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!data.empty() &amp;&amp; data.front() == n)<br>            data.pop_front();<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    MonotonicQueue window;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; k - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//先填满窗口的前 k - 1</span><br>            window.push(nums[i]);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 窗口向前滑动</span><br>            window.push(nums[i]);<br>            res.push_back(window.max());<br>            window.pop(nums[i - k + <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>三、算法复杂度分析</strong><br>读者可能疑惑，push 操作中含有 while 循环，时间复杂度不是 O(1) 呀，那么本算法的时间复杂度应该不是线性时间吧？<br>单独看 push 操作的复杂度确实不是 O(1)，但是算法整体的复杂度依然是 O(N) 线性时间。要这样想，nums 中的每个元素最多被 push_back 和 pop_back 一次，没有任何多余操作，所以整体的复杂度还是 O(N)。<br>空间复杂度就很简单了，就是窗口的大小 O(k)。<br><strong>四、最后总结</strong><br>有的读者可能觉得「单调队列」和「优先级队列」比较像，实际上差别很大的。<br>单调队列在添加元素的时候靠删除元素保持队列的单调性，相当于抽取出某个函数中单调递增（或递减）的部分；而优先级队列（二叉堆）相当于自动排序，差别大了去了。<br>赶紧去拿下 LeetCode 第 239 道题吧～</p><p><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88">上一篇：特殊数据结构：单调栈</a><br><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E8%AE%BE%E8%AE%A1Twitter">下一篇：设计Twitter</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现计算器</title>
      <link href="2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="拆解复杂问题：实现计算器"><a href="#拆解复杂问题：实现计算器" class="headerlink" title="拆解复杂问题：实现计算器"></a>拆解复杂问题：实现计算器</h1><p>我们最终要实现的计算器功能如下：</p><p>1、输入一个字符串，可以包含<code>+ - * /</code>、数字、括号以及空格，你的算法返回运算结构。<br>2、要符合运算法则，括号的优先级最高，先乘除后加减。<br>3、除号是整数除法，无论正负都向 0 取整（5/2=2，-5/2=-2）。<br>4、可以假定输入的算式一定合法，且计算过程不会出现整型溢出，不会出现除数为 0 的意外情况。<br>比如输入如下字符串，算法会返回 9：<br><code>3 * (2-6 /(3 -7))</code><br>可以看到，这就已经非常接近我们实际生活中使用的计算器了，虽然我们以前肯定都用过计算器，但是如果简单思考一下其算法实现，就会大惊失色：<br>1、按照常理处理括号，要先计算最内层的括号，然后向外慢慢化简。这个过程我们手算都容易出错，何况写成算法呢！<br>2、要做到先乘除，后加减，这一点教会小朋友还不算难，但教给计算机恐怕有点困难。<br>3、要处理空格。我们为了美观，习惯性在数字和运算符之间打个空格，但是计算之中得想办法忽略这些空格。<br>我记得很多大学数据结构的教材上，在讲栈这种数据结构的时候，应该都会用计算器举例，但是有一说一，讲的真的垃圾，不知道多少未来的计算机科学家就被这种简单的数据结构劝退了。<br>那么本文就来聊聊怎么实现上述一个功能完备的计算器功能，<strong>关键在于层层拆解问题，化整为零，逐个击破</strong>，相信这种思维方式能帮大家解决各种复杂问题。<br>下面就来拆解，从最简单的一个问题开始。</p><h3 id="一、字符串转整数"><a href="#一、字符串转整数" class="headerlink" title="一、字符串转整数"></a>一、字符串转整数</h3><p>是的，就是这么一个简单的问题，首先告诉我，怎么把一个字符串形式的<strong>正</strong>整数，转化成 int 型？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;458&quot;</span>;<br><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>    <span class="hljs-keyword">char</span> c = s[i];<br>    n = <span class="hljs-number">10</span> * n + (c - <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// n 现在就等于 458</span><br></code></pre></td></tr></table></figure><p>这个还是很简单的吧，老套路了。但是即便这么简单，依然有坑：**<code>(c - &#39;0&#39;)</code>的这个括号不能省略，否则可能造成整型溢出**。<br>因为变量<code>c</code>是一个 ASCII 码，如果不加括号就会先加后减，想象一下<code>s</code>如果接近 INT_MAX，就会溢出。所以用括号保证先减后加才行。</p><h3 id="二、处理加减法"><a href="#二、处理加减法" class="headerlink" title="二、处理加减法"></a>二、处理加减法</h3><p>现在进一步，<strong>如果输入的这个算式只包含加减法，而且不存在空格</strong>，你怎么计算结果？我们拿字符串算式<code>1-12+3</code>为例，来说一个很简单的思路：<br>1、先给第一个数字加一个默认符号<code>+</code>，变成<code>+1-12+3</code>。<br>2、把一个运算符和数字组合成一对儿，也就是三对儿<code>+1</code>，<code>-12</code>，<code>+3</code>，把它们转化成数字，然后放到一个栈中。<br>3、将栈中所有的数字求和，就是原算式的结果。<br>我们直接看代码，结合一张图就看明白了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stk;<br>    <span class="hljs-comment">// 记录算式中的数字</span><br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 记录 num 前的符号，初始化为 +</span><br>    <span class="hljs-keyword">char</span> sign = <span class="hljs-string">&#x27;+&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>        <span class="hljs-keyword">char</span> c = s[i];<br>        <span class="hljs-comment">// 如果是数字，连续读取到 num</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) <br>            num = <span class="hljs-number">10</span> * num + (c - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-comment">// 如果不是数字，就是遇到了下一个符号，</span><br>        <span class="hljs-comment">// 之前的数字和符号就要存进栈中</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(c) || i == s.size() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">switch</span> (sign) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                    stk.push(num); <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                    stk.push(-num); <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 更新符号为当前符号，数字清零</span><br>            sign = c;<br>            num = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将栈中所有结果求和就是答案</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!stk.empty()) &#123;<br>        res += stk.top();<br>        stk.pop();<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>我估计就是中间带<code>switch</code>语句的部分有点不好理解吧，<code>i</code>就是从左到右扫描，<code>sign</code>和<code>num</code>跟在它身后。当<code>s[i]</code>遇到一个运算符时，情况是这样的：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/calculator/1.jpg"><br>所以说，此时要根据<code>sign</code>的 case 不同选择<code>nums</code>的正负号，存入栈中，然后更新<code>sign</code>并清零<code>nums</code>记录下一对儿符合和数字的组合。<br>另外注意，不只是遇到新的符号会触发入栈，当<code>i</code>走到了算式的尽头（<code>i == s.size() - 1</code>），也应该将前面的数字入栈，方便后续计算最终结果。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/calculator/2.jpg"><br>至此，仅处理紧凑加减法字符串的算法就完成了，请确保理解以上内容，后续的内容就基于这个框架修修改改就完事儿了。</p><h3 id="三、处理乘除法"><a href="#三、处理乘除法" class="headerlink" title="三、处理乘除法"></a>三、处理乘除法</h3><p>其实思路跟仅处理加减法没啥区别，拿字符串<code>2-3*4+5</code>举例，核心思路依然是把字符串分解成符号和数字的组合。<br>比如上述例子就可以分解为<code>+2</code>，<code>-3</code>，<code>*4</code>，<code>+5</code>几对儿，我们刚才不是没有处理乘除号吗，很简单，<strong>其他部分都不用变</strong>，在<code>switch</code>部分加上对应的 case 就行了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>    <span class="hljs-keyword">char</span> c = s[i];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) <br>        num = <span class="hljs-number">10</span> * num + (c - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(c) || i == s.size() - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">switch</span> (sign) &#123;<br>            <span class="hljs-keyword">int</span> pre;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                stk.push(num); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                stk.push(-num); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 只要拿出前一个数字做对应运算即可</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                pre = stk.top();<br>                stk.pop();<br>                stk.push(pre * num);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>                pre = stk.top();<br>                stk.pop();<br>                stk.push(pre / num);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 更新符号为当前符号，数字清零</span><br>        sign = c;<br>        num = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/calculator/3.jpg"><br><strong>乘除法优先于加减法体现在，乘除法可以和栈顶的数结合，而加减法只能把自己放入栈</strong>。<br>现在我们思考一下<strong>如何处理字符串中可能出现的空格字符</strong>。其实也非常简单，想想空格字符的出现，会影响我们现有代码的哪一部分？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 如果 c 非数字</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(c) || i == s.size() - <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (c) &#123;...&#125;<br>    sign = c;<br>    num = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然空格会进入这个 if 语句，但是我们并不想让空格的情况进入这个 if，因为这里会更新<code>sign</code>并清零<code>nums</code>，空格根本就不是运算符，应该被忽略。<br>那么只要多加一个条件即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> ((!<span class="hljs-built_in">isdigit</span>(c) &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>) || i == s.size() - <span class="hljs-number">1</span>) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>好了，现在我们的算法已经可以按照正确的法则计算加减乘除，并且自动忽略空格符，剩下的就是如何让算法正确识别括号了。</p><h3 id="四、处理括号"><a href="#四、处理括号" class="headerlink" title="四、处理括号"></a>四、处理括号</h3><p>处理算式中的括号看起来应该是最难的，但真没有看起来那么难。<br>为了规避编程语言的繁琐细节，我把前面解法的代码翻译成 Python 版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate</span>(<span class="hljs-params">s: str</span>) -&gt; int:</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span>(<span class="hljs-params">s: List</span>) -&gt; int:</span><br>        stack = []<br>        sign = <span class="hljs-string">&#x27;+&#x27;</span><br>        num = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> len(s) &gt; <span class="hljs-number">0</span>:<br>            c = s.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> c.isdigit():<br>                num = <span class="hljs-number">10</span> * num + int(c)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> c.isdigit() <span class="hljs-keyword">and</span> c != <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-keyword">or</span> len(s) == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> sign == <span class="hljs-string">&#x27;+&#x27;</span>:<br>                    stack.append(num)<br>                <span class="hljs-keyword">elif</span> sign == <span class="hljs-string">&#x27;-&#x27;</span>:<br>                    stack.append(-num)<br>                <span class="hljs-keyword">elif</span> sign == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                    stack[<span class="hljs-number">-1</span>] = stack[<span class="hljs-number">-1</span>] * num<br>                <span class="hljs-keyword">elif</span> sign == <span class="hljs-string">&#x27;/&#x27;</span>:<br>                    <span class="hljs-comment"># python 除法向 0 取整的写法</span><br>                    stack[<span class="hljs-number">-1</span>] = int(stack[<span class="hljs-number">-1</span>] / float(num))                    <br>                num = <span class="hljs-number">0</span><br>                sign = c<br>        <span class="hljs-keyword">return</span> sum(stack)<br>    <span class="hljs-comment"># 需要把字符串转成列表方便操作</span><br>    <span class="hljs-keyword">return</span> helper(list(s))<br></code></pre></td></tr></table></figure><p>这段代码跟刚才 C++ 代码完全相同，唯一的区别是，不是从左到右遍历字符串，而是不断从左边<code>pop</code>出字符，本质还是一样的。<br>那么，为什么说处理括号没有看起来那么难呢，<strong>因为括号具有递归性质</strong>。我们拿字符串<code>3*(4-5/2)-6</code>举例：<br>calculate(<code>3*(4-5/2)-6</code>)<br>= 3 * calculate(<code>4-5/2</code>) - 6<br>= 3 * 2 - 6<br>= 0<br>可以脑补一下，无论多少层括号嵌套，通过 calculate 函数递归调用自己，都可以将括号中的算式化简成一个数字。<strong>换句话说，括号包含的算式，我们直接视为一个数字就行了</strong>。<br>现在的问题是，递归的开始条件和结束条件是什么？<strong>遇到<code>(</code>开始递归，遇到<code>)</code>结束递归</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate</span>(<span class="hljs-params">s: str</span>) -&gt; int:</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span>(<span class="hljs-params">s: List</span>) -&gt; int:</span><br>        stack = []<br>        sign = <span class="hljs-string">&#x27;+&#x27;</span><br>        num = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> len(s) &gt; <span class="hljs-number">0</span>:<br>            c = s.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> c.isdigit():<br>                num = <span class="hljs-number">10</span> * num + int(c)<br>            <span class="hljs-comment"># 遇到左括号开始递归计算 num</span><br>            <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                num = helper(s)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> c.isdigit() <span class="hljs-keyword">and</span> c != <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-keyword">or</span> len(s) == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> sign == <span class="hljs-string">&#x27;+&#x27;</span>: ...<br>                <span class="hljs-keyword">elif</span> sign == <span class="hljs-string">&#x27;-&#x27;</span>: ... <br>                <span class="hljs-keyword">elif</span> sign == <span class="hljs-string">&#x27;*&#x27;</span>: ...<br>                <span class="hljs-keyword">elif</span> sign == <span class="hljs-string">&#x27;/&#x27;</span>: ...<br>                num = <span class="hljs-number">0</span><br>                sign = c<br>            <span class="hljs-comment"># 遇到右括号返回递归结果</span><br>            <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> sum(stack)<br>    <span class="hljs-keyword">return</span> helper(list(s))<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/calculator/4.jpg"><br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/calculator/5.jpg"><br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/calculator/6.jpg"><br>你看，加了两三行代码，就可以处理括号了，这就是递归的魅力。至此，计算器的全部功能就实现了，通过对问题的层层拆解化整为零，再回头看，这个问题似乎也没那么复杂嘛。</p><h3 id="五、最后总结"><a href="#五、最后总结" class="headerlink" title="五、最后总结"></a>五、最后总结</h3><p>本文借实现计算器的问题，主要想表达的是一种处理复杂问题的思路。<br>我们首先从字符串转数字这个简单问题开始，进而处理只包含加减法的算式，进而处理包含加减乘除四则运算的算式，进而处理空格字符，进而处理包含括号的算式。<br><strong>可见，对于一些比较困难的问题，其解法并不是一蹴而就的，而是步步推进，螺旋上升的</strong>。如果一开始给你原题，你不会做，甚至看不懂答案，都很正常，关键在于我们自己如何简化问题，如何以退为进。<br><strong>退而求其次是一种很聪明策略</strong>。你想想啊，假设这是一道考试题，你不会实现这个计算器，但是你写了字符串转整数的算法并指出了容易溢出的陷阱，那起码可以得 20 分吧；如果你能够处理加减法，那可以得 40 分吧；如果你能处理加减乘除四则运算，那起码够 70 分了；再加上处理空格字符，80 有了吧。我就是不会处理括号，那就算了，80 已经很 OK 了好不好。</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BD%8D%E6%93%8D%E4%BD%9C">上一篇：常用的位操作</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E7%83%A7%E9%A5%BC%E6%8E%92%E5%BA%8F">下一篇：烧饼排序</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构系列</title>
      <link href="2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/"/>
      <url>2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构系列"><a href="#数据结构系列" class="headerlink" title="数据结构系列"></a>数据结构系列</h1><ul><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E6%95%88%E6%96%B9%E6%B3%95">学习算法和刷题的思路指南</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%954">学习数据结构和算法读什么书</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">二叉堆详解实现优先级队列</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/LRU%E7%AE%97%E6%B3%95">LRU算法详解</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%93%8D%E4%BD%9C%E9%9B%86%E9%94%A6">二叉搜索树操作集锦</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88">特殊数据结构：单调栈</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97">特殊数据结构：单调队列</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E8%AE%BE%E8%AE%A1Twitter">设计Twitter</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">递归反转链表的一部分</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">队列实现栈|栈实现队列</a><br>这一章主要是一些特殊的数据结构设计，比如单调栈解决 Next Greater Number，单调队列解决滑动窗口问题；还有常用数据结构的操作，比如链表、树、二叉堆。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计Twitter</title>
      <link href="2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E8%AE%BE%E8%AE%A1Twitter/"/>
      <url>2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E8%AE%BE%E8%AE%A1Twitter/</url>
      
        <content type="html"><![CDATA[<h1 id="设计Twitter"><a href="#设计Twitter" class="headerlink" title="设计Twitter"></a>设计Twitter</h1><p>「design Twitter」是 LeetCode 上第 335 道题目，不仅题目本身很有意思，而且把合并多个有序链表的算法和面向对象设计（OO design）结合起来了，很有实际意义，本文就带大家来看看这道题。<br>至于 Twitter 的什么功能跟算法有关系，等我们描述一下题目要求就知道了。</p><h3 id="一、题目及应用场景简介"><a href="#一、题目及应用场景简介" class="headerlink" title="一、题目及应用场景简介"></a>一、题目及应用场景简介</h3><p>Twitter 和微博功能差不多，我们主要要实现这样几个 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Twitter</span> </span>&#123;<br>    <span class="hljs-comment">/** user 发表一条 tweet 动态 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postTweet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> tweetId)</span> </span>&#123;&#125;<br>    <br>    <span class="hljs-comment">/** 返回该 user 关注的人（包括他自己）最近的动态 id，</span><br><span class="hljs-comment">    最多 10 条，而且这些动态必须按从新到旧的时间线顺序排列。*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getNewsFeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>&#123;&#125;<br>    <br>    <span class="hljs-comment">/** follower 关注 followee，如果 Id 不存在则新建 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">follow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> followerId, <span class="hljs-keyword">int</span> followeeId)</span> </span>&#123;&#125;<br>    <br>    <span class="hljs-comment">/** follower 取关 followee，如果 Id 不存在则什么都不做 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unfollow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> followerId, <span class="hljs-keyword">int</span> followeeId)</span> </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>举个具体的例子，方便大家理解 API 的具体用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Twitter twitter = <span class="hljs-keyword">new</span> Twitter();<br>twitter.postTweet(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">// 用户 1 发送了一条新推文 5</span><br>twitter.getNewsFeed(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// return [5]，因为自己是关注自己的</span><br>twitter.follow(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 用户 1 关注了用户 2</span><br>twitter.postTweet(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>);<br><span class="hljs-comment">// 用户2发送了一个新推文 (id = 6)</span><br>twitter.getNewsFeed(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// return [6, 5]</span><br><span class="hljs-comment">// 解释：用户 1 关注了自己和用户 2，所以返回他们的最近推文</span><br><span class="hljs-comment">// 而且 6 必须在 5 之前，因为 6 是最近发送的</span><br>twitter.unfollow(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 用户 1 取消关注了用户 2</span><br>twitter.getNewsFeed(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// return [5]</span><br></code></pre></td></tr></table></figure><p>这个场景在我们的现实生活中非常常见。拿朋友圈举例，比如我刚加到女神的微信，然后我去刷新一下我的朋友圈动态，那么女神的动态就会出现在我的动态列表，而且会和其他动态按时间排好序。只不过 Twitter 是单向关注，微信好友相当于双向关注。除非，被屏蔽…<br>这几个 API 中大部分都很好实现，最核心的功能难点应该是 <code>getNewsFeed</code>，因为返回的结果必须在时间上有序，但问题是用户的关注是动态变化的，怎么办？<br><strong>这里就涉及到算法了</strong>：如果我们把每个用户各自的推文存储在链表里，每个链表节点存储文章 id 和一个时间戳 time（记录发帖时间以便比较），而且这个链表是按 time 有序的，那么如果某个用户关注了 k 个用户，我们就可以用合并 k 个有序链表的算法合并出有序的推文列表，正确地 <code>getNewsFeed</code> 了！<br>具体的算法等会讲解。不过，就算我们掌握了算法，应该如何编程表示用户 user 和推文动态 tweet 才能把算法流畅地用出来呢？<strong>这就涉及简单的面向对象设计了</strong>，下面我们来由浅入深，一步一步进行设计。</p><h3 id="二、面向对象设计"><a href="#二、面向对象设计" class="headerlink" title="二、面向对象设计"></a>二、面向对象设计</h3><p>根据刚才的分析，我们需要一个 User 类，储存 user 信息，还需要一个 Tweet 类，储存推文信息，并且要作为链表的节点。所以我们先搭建一下整体的框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Twitter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> timestamp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tweet</span> </span>&#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;&#125;<br>    <span class="hljs-comment">/* 还有那几个 API 方法 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postTweet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> tweetId)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getNewsFeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">follow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> followerId, <span class="hljs-keyword">int</span> followeeId)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unfollow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> followerId, <span class="hljs-keyword">int</span> followeeId)</span> </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之所以要把 Tweet 和 User 类放到 Twitter 类里面，是因为 Tweet 类必须要用到一个全局时间戳 timestamp，而 User 类又需要用到 Tweet 类记录用户发送的推文，所以它们都作为内部类。不过为了清晰和简洁，下文会把每个内部类和 API 方法单独拿出来实现。<br><strong>1、Tweet 类的实现</strong><br>根据前面的分析，Tweet 类很容易实现：每个 Tweet 实例需要记录自己的 tweetId 和发表时间 time，而且作为链表节点，要有一个指向下一个节点的 next 指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tweet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> time;<br>    <span class="hljs-keyword">private</span> Tweet next;<br>    <span class="hljs-comment">// 需要传入推文内容（id）和发文时间</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Tweet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.time = time;<br>        <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E8%AE%BE%E8%AE%A1Twitter/tweet.jpg" alt="tweet"><br><strong>2、User 类的实现</strong><br>我们根据实际场景想一想，一个用户需要存储的信息有 userId，关注列表，以及该用户发过的推文列表。其中关注列表应该用集合（Hash Set）这种数据结构来存，因为不能重复，而且需要快速查找；推文列表应该由链表这种数据结构储存，以便于进行有序合并的操作。画个图理解一下：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E8%AE%BE%E8%AE%A1Twitter/user.jpg" alt="User"><br>除此之外，根据面向对象的设计原则，「关注」「取关」和「发文」应该是 User 的行为，况且关注列表和推文列表也存储在 User 类中，所以我们也应该给 User 添加 follow，unfollow 和 post 这几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// static int timestamp = 0</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">public</span> Set&lt;Integer&gt; followed;<br>    <span class="hljs-comment">// 用户发表的推文链表头结点</span><br>    <span class="hljs-keyword">public</span> Tweet head;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>&#123;<br>        followed = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">this</span>.id = userId;<br>        <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 关注一下自己</span><br>        follow(id);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">follow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>&#123;<br>        followed.add(userId);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unfollow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>&#123;<br>        <span class="hljs-comment">// 不可以取关自己</span><br>        <span class="hljs-keyword">if</span> (userId != <span class="hljs-keyword">this</span>.id)<br>            followed.remove(userId);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tweetId)</span> </span>&#123;<br>        Tweet twt = <span class="hljs-keyword">new</span> Tweet(tweetId, timestamp);<br>        timestamp++;<br>        <span class="hljs-comment">// 将新建的推文插入链表头</span><br>        <span class="hljs-comment">// 越靠前的推文 time 值越大</span><br>        twt.next = head;<br>        head = twt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3、几个 API 方法的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Twitter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> timestamp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tweet</span> </span>&#123;...&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;...&#125;<br>    <span class="hljs-comment">// 我们需要一个映射将 userId 和 User 对象对应起来</span><br>    <span class="hljs-keyword">private</span> HashMap&lt;Integer, User&gt; userMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">/** user 发表一条 tweet 动态 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postTweet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">int</span> tweetId)</span> </span>&#123;<br>        <span class="hljs-comment">// 若 userId 不存在，则新建</span><br>        <span class="hljs-keyword">if</span> (!userMap.containsKey(userId))<br>            userMap.put(userId, <span class="hljs-keyword">new</span> User(userId));<br>        User u = userMap.get(userId);<br>        u.post(tweetId);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** follower 关注 followee */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">follow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> followerId, <span class="hljs-keyword">int</span> followeeId)</span> </span>&#123;<br>        <span class="hljs-comment">// 若 follower 不存在，则新建</span><br><span class="hljs-keyword">if</span>(!userMap.containsKey(followerId))&#123;<br>User u = <span class="hljs-keyword">new</span> User(followerId);<br>userMap.put(followerId, u);<br>&#125;<br>        <span class="hljs-comment">// 若 followee 不存在，则新建</span><br><span class="hljs-keyword">if</span>(!userMap.containsKey(followeeId))&#123;<br>User u = <span class="hljs-keyword">new</span> User(followeeId);<br>userMap.put(followeeId, u);<br>&#125;<br>userMap.get(followerId).follow(followeeId);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** follower 取关 followee，如果 Id 不存在则什么都不做 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unfollow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> followerId, <span class="hljs-keyword">int</span> followeeId)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (userMap.containsKey(followerId)) &#123;<br>            User flwer = userMap.get(followerId);<br>            flwer.unfollow(followeeId);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/** 返回该 user 关注的人（包括他自己）最近的动态 id，</span><br><span class="hljs-comment">    最多 10 条，而且这些动态必须按从新到旧的时间线顺序排列。*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getNewsFeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>&#123;<br>        <span class="hljs-comment">// 需要理解算法，见下文</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、算法设计"><a href="#三、算法设计" class="headerlink" title="三、算法设计"></a>三、算法设计</h3><p>实现合并 k 个有序链表的算法需要用到优先级队列（Priority Queue），这种数据结构是「二叉堆」最重要的应用，你可以理解为它可以对插入的元素自动排序。乱序的元素插入其中就被放到了正确的位置，可以按照从小到大（或从大到小）有序地取出元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">PriorityQueue pq<br><span class="hljs-comment"># 乱序插入</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>&#125;:<br>    pq.add(i)<br><span class="hljs-keyword">while</span> pq <span class="hljs-keyword">not</span> empty:<br>    <span class="hljs-comment"># 每次取出第一个（最小）元素</span><br>    print(pq.pop())<br><span class="hljs-comment"># 输出有序：1,2,4,6,9</span><br></code></pre></td></tr></table></figure><p>借助这种牛逼的数据结构支持，我们就很容易实现这个核心功能了。注意我们把优先级队列设为按 time 属性<strong>从大到小降序排列</strong>，因为 time 越大意味着时间越近，应该排在前面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getNewsFeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>&#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (!userMap.containsKey(userId)) <span class="hljs-keyword">return</span> res;<br>    <span class="hljs-comment">// 关注列表的用户 Id</span><br>    Set&lt;Integer&gt; users = userMap.get(userId).followed;<br>    <span class="hljs-comment">// 自动通过 time 属性从大到小排序，容量为 users 的大小</span><br>    PriorityQueue&lt;Tweet&gt; pq = <br>        <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(users.size(), (a, b)-&gt;(b.time - a.time));<br>    <span class="hljs-comment">// 先将所有链表头节点插入优先级队列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> id : users) &#123;<br>        Tweet twt = userMap.get(id).head;<br>        <span class="hljs-keyword">if</span> (twt == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">continue</span>;<br>        pq.add(twt);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>        <span class="hljs-comment">// 最多返回 10 条就够了</span><br>        <span class="hljs-keyword">if</span> (res.size() == <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 弹出 time 值最大的（最近发表的）</span><br>        Tweet twt = pq.poll();<br>        res.add(twt.id);<br>        <span class="hljs-comment">// 将下一篇 Tweet 插入进行排序</span><br>        <span class="hljs-keyword">if</span> (twt.next != <span class="hljs-keyword">null</span>) <br>            pq.add(twt.next);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个过程是这样的，下面是我制作的一个 GIF 图描述合并链表的过程。假设有三个 Tweet 链表按 time 属性降序排列，我们把他们降序合并添加到 res 中。注意图中链表节点中的数字是 time 属性，不是 id 属性：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E8%AE%BE%E8%AE%A1Twitter/merge.gif" alt="gif"><br>至此，这道一个极其简化的 Twitter 时间线功能就设计完毕了。</p><h3 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a>四、最后总结</h3><p>本文运用简单的面向对象技巧和合并 k 个有序链表的算法设计了一套简化的时间线功能，这个功能其实广泛地运用在许多社交应用中。<br>我们先合理地设计出 User 和 Tweet 两个类，然后基于这个设计之上运用算法解决了最重要的一个功能。可见实际应用中的算法并不是孤立存在的，需要和其他知识混合运用，才能发挥实际价值。<br>当然，实际应用中的社交 App 数据量是巨大的，考虑到数据库的读写性能，我们的设计可能承受不住流量压力，还是有些太简化了。而且实际的应用都是一个极其庞大的工程，比如下图，是 Twitter 这样的社交网站大致的系统结构：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E8%AE%BE%E8%AE%A1Twitter/design.png" alt="design"><br>我们解决的问题应该只能算 Timeline Service 模块的一小部分，功能越多，系统的复杂性可能是指数级增长的。所以说合理的顶层设计十分重要，其作用是远超某一个算法的。<br>最后，Github 上有一个优秀的开源项目叫 <a href="https://github.com/donnemartin/system-design-primer">system-design-primer</a>，专门收集了很多大型系统设计的案例和解析，而且有中文版本，上面这个图也出自该项目。对系统设计感兴趣的读者可以点击链接查看。<br>PS：本文前两张图片和 GIF 是我第一次尝试用平板的绘图软件制作的，花了很多时间，尤其是 GIF 图，需要一帧一帧制作。如果本文内容对你有帮助，点个赞分个享，鼓励一下我呗！</p><p><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97">上一篇：特殊数据结构：单调队列</a><br><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">下一篇：递归反转链表的一部分</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归反转链表的一部分</title>
      <link href="2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86/"/>
      <url>2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="递归反转链表的一部分"><a href="#递归反转链表的一部分" class="headerlink" title="递归反转链表的一部分"></a>递归反转链表的一部分</h1><p>反转单链表的迭代实现不是一个困难的事情，但是递归实现就有点难度了，如果再加一点难度，让你仅仅反转单链表中的一部分，你是否能<strong>够递归实现</strong>呢？<br>本文就来由浅入深，step by step 地解决这个问题。如果你还不会递归地反转单链表也没关系，<strong>本文会从递归反转整个单链表开始拓展</strong>，只要你明白单链表的结构，相信你能够有所收获。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 单链表节点的结构</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;<br>    ListNode(<span class="hljs-keyword">int</span> x) &#123; val = x; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>什么叫反转单链表的一部分呢，就是给你一个索引区间，让你把单链表中这部分元素反转，其他部分不变：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/title.png"><br><strong>注意这里的索引是从 1 开始的</strong>。迭代的思路大概是：先用一个 for 循环找到第 <code>m</code> 个位置，然后再用一个 for 循环将 <code>m</code> 和 <code>n</code> 之间的元素反转。但是我们的递归解法不用一个 for 循环，纯递归实现反转。<br>迭代实现思路看起来虽然简单，但是细节问题很多的，反而不容易写对。相反，递归实现就很简洁优美，下面就由浅入深，先从反转整个单链表说起。</p><h3 id="一、递归反转整个链表"><a href="#一、递归反转整个链表" class="headerlink" title="一、递归反转整个链表"></a>一、递归反转整个链表</h3><p>这个算法可能很多读者都听说过，这里详细介绍一下，先直接看实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head;<br>    ListNode last = reverse(head.next);<br>    head.next.next = head;<br>    head.next = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> last;<br>&#125;<br></code></pre></td></tr></table></figure><p>看起来是不是感觉不知所云，完全不能理解这样为什么能够反转链表？这就对了，这个算法常常拿来显示递归的巧妙和优美，我们下面来详细解释一下这段代码。<br><strong>对于递归算法，最重要的就是明确递归函数的定义</strong>。具体来说，我们的 <code>reverse</code> 函数定义是这样的：<br><strong>输入一个节点 <code>head</code>，将「以 <code>head</code> 为起点」的链表反转，并返回反转之后的头结点</strong>。<br>明白了函数的定义，在来看这个问题。比如说我们想反转这个链表：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1.jpg"><br>那么输入 <code>reverse(head)</code> 后，会在这里进行递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode last = reverse(head.next);<br></code></pre></td></tr></table></figure><p>不要跳进递归（你的脑袋能压几个栈呀？），而是要根据刚才的函数定义，来弄清楚这段代码会产生什么结果：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2.jpg"><br>这个 <code>reverse(head.next)</code> 执行完成后，整个链表就成了这样：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/3.jpg"><br>并且根据函数定义，<code>reverse</code> 函数会返回反转之后的头结点，我们用变量 <code>last</code> 接收了。<br>现在再来看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">head.next.next = head;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/4.jpg"><br>接下来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">head.next = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">return</span> last;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/5.jpg"><br>神不神奇，这样整个链表就反转过来了！递归代码就是这么简洁优雅，不过其中有两个地方需要注意：<br>1、递归函数要有 base case，也就是这句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (head.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head;<br></code></pre></td></tr></table></figure><p>意思是如果链表只有一个节点的时候反转也是它自己，直接返回即可。<br>2、当链表递归反转之后，新的头结点是 <code>last</code>，而之前的 <code>head</code> 变成了最后一个节点，别忘了链表的末尾要指向 null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">head.next = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p>理解了这两点后，我们就可以进一步深入了，接下来的问题其实都是在这个算法上的扩展。</p><h3 id="二、反转链表前-N-个节点"><a href="#二、反转链表前-N-个节点" class="headerlink" title="二、反转链表前 N 个节点"></a>二、反转链表前 N 个节点</h3><p>这次我们实现一个这样的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将链表的前 n 个节点反转（n &lt;= 链表长度）</span><br><span class="hljs-function">ListNode <span class="hljs-title">reverseN</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span></span><br></code></pre></td></tr></table></figure><p>比如说对于下图链表，执行 <code>reverseN(head, 3)</code>：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/6.jpg"><br>解决思路和反转整个链表差不多，只要稍加修改即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode successor = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 后驱节点</span><br><span class="hljs-comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span><br><span class="hljs-function">ListNode <span class="hljs-title">reverseN</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <br>        <span class="hljs-comment">// 记录第 n + 1 个节点</span><br>        successor = head.next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-comment">// 以 head.next 为起点，需要反转前 n - 1 个节点</span><br>    ListNode last = reverseN(head.next, n - <span class="hljs-number">1</span>);<br>    head.next.next = head;<br>    <span class="hljs-comment">// 让反转之后的 head 节点和后面的节点连起来</span><br>    head.next = successor;<br>    <span class="hljs-keyword">return</span> last;<br>&#125;    <br></code></pre></td></tr></table></figure><p>具体的区别：<br>1、base case 变为 <code>n == 1</code>，反转一个元素，就是它本身，同时<strong>要记录后驱节点</strong>。<br>2、刚才我们直接把 <code>head.next</code> 设置为 null，因为整个链表反转后原来的 <code>head</code> 变成了整个链表的最后一个节点。但现在 <code>head</code> 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 <code>successor</code>（第 n + 1 个节点），反转之后将 <code>head</code> 连接上。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/7.jpg"><br>OK，如果这个函数你也能看懂，就离实现「反转一部分链表」不远了。</p><h3 id="三、反转链表的一部分"><a href="#三、反转链表的一部分" class="headerlink" title="三、反转链表的一部分"></a>三、反转链表的一部分</h3><p>现在解决我们最开始提出的问题，给一个索引区间 <code>[m,n]</code>（索引从 1 开始），仅仅反转区间中的链表元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span></span><br></code></pre></td></tr></table></figure><p>首先，如果 <code>m == 1</code>，就相当于反转链表开头的 <code>n</code> 个元素嘛，也就是我们刚才实现的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 相当于反转前 n 个元素</span><br>        <span class="hljs-keyword">return</span> reverseN(head, n);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>m != 1</code> 怎么办？如果我们把 <code>head</code> 的索引视为 1，那么我们是想从第 <code>m</code> 个元素开始反转对吧；如果把 <code>head.next</code> 的索引视为 1 呢？那么相对于 <code>head.next</code>，反转的区间应该是从第 <code>m - 1</code> 个元素开始的；那么对于 <code>head.next.next</code> 呢……<br>区别于迭代思想，这就是递归思想，所以我们可以完成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> reverseN(head, n);<br>    &#125;<br>    <span class="hljs-comment">// 前进到反转的起点触发 base case</span><br>    head.next = reverseBetween(head.next, m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们的最终大 BOSS 就被解决了。</p><h3 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a>四、最后总结</h3><p>递归的思想相对迭代思想，稍微有点难以理解，处理的技巧是：不要跳进递归，而是利用明确的定义来实现算法逻辑。<br>处理看起来比较困难的问题，可以尝试化整为零，把一些简单的解法进行修改，解决困难的问题。<br>值得一提的是，递归操作链表并不高效。和迭代解法相比，虽然时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)。所以递归操作链表可以作为对递归算法的练习或者拿去和小伙伴装逼，但是考虑效率的话还是使用迭代算法更好。</p><p><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E8%AE%BE%E8%AE%A1Twitter">上一篇：设计Twitter</a><br><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">下一篇：队列实现栈|栈实现队列</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列实现栈栈实现队列</title>
      <link href="2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="队列实现栈-栈实现队列"><a href="#队列实现栈-栈实现队列" class="headerlink" title="队列实现栈|栈实现队列"></a>队列实现栈|栈实现队列</h1><p>队列是一种先进先出的数据结构，栈是一种先进后出的数据结构，形象一点就是这样：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%A0%88%E9%98%9F%E5%88%97/1.jpg"><br>这两种数据结构底层其实都是数组或者链表实现的，只是 API 限定了它们的特性，那么今天就来看看如何使用「栈」的特性来实现一个「队列」，如何用「队列」实现一个「栈」。</p><h3 id="一、用栈实现队列"><a href="#一、用栈实现队列" class="headerlink" title="一、用栈实现队列"></a>一、用栈实现队列</h3><p>首先，队列的 API 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    <br>    <span class="hljs-comment">/** 添加元素到队尾 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;<br>    <br>    <span class="hljs-comment">/** 删除队头的元素并返回 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-comment">/** 返回队头元素 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-comment">/** 判断队列是否为空 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用两个栈 <code>s1, s2</code> 就能实现一个队列的功能（这样放置栈可能更容易理解）：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%A0%88%E9%98%9F%E5%88%97/2.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; s1, s2;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        s1 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        s2 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当调用 <code>push</code> 让元素入队时，只要把元素压入 <code>s1</code> 即可，比如说 <code>push</code> 进 3 个元素分别是 1,2,3，那么底层结构就是这样：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%A0%88%E9%98%9F%E5%88%97/3.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 添加元素到队尾 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    s1.push(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如果这时候使用 <code>peek</code> 查看队头的元素怎么办呢？按道理队头元素应该是 1，但是在 <code>s1</code> 中 1 被压在栈底，现在就要轮到 <code>s2</code> 起到一个中转的作用了：当 <code>s2</code> 为空时，可以把 <code>s1</code> 的所有元素取出再添加进 <code>s2</code>，<strong>这时候 <code>s2</code> 中元素就是先进先出顺序了</strong>。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%A0%88%E9%98%9F%E5%88%97/4.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 返回队头元素 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s2.isEmpty())<br>        <span class="hljs-comment">// 把 s1 元素压入 s2</span><br>        <span class="hljs-keyword">while</span> (!s1.isEmpty())<br>            s2.push(s1.pop());<br>    <span class="hljs-keyword">return</span> s2.peek();<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，对于 <code>pop</code> 操作，只要操作 <code>s2</code> 就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 删除队头的元素并返回 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 先调用 peek 保证 s2 非空</span><br>    peek();<br>    <span class="hljs-keyword">return</span> s2.pop();<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，如何判断队列是否为空呢？如果两个栈都为空的话，就说明队列为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 判断队列是否为空 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，就用栈结构实现了一个队列，核心思想是利用两个栈互相配合。<br>值得一提的是，这几个操作的时间复杂度是多少呢？有点意思的是 <code>peek</code> 操作，调用它时可能触发 <code>while</code> 循环，这样的话时间复杂度是 O(N)，但是大部分情况下 <code>while</code> 循环不会被触发，时间复杂度是 O(1)。由于 <code>pop</code> 操作调用了 <code>peek</code>，它的时间复杂度和 <code>peek</code> 相同。<br>像这种情况，可以说它们的<strong>最坏时间复杂度</strong>是 O(N)，因为包含 <code>while</code> 循环，<strong>可能</strong>需要从 <code>s1</code> 往 <code>s2</code> 搬移元素。<br>但是它们的<strong>均摊时间复杂度</strong>是 O(1)，这个要这么理解：对于一个元素，最多只可能被搬运一次，也就是说 <code>peek</code> 操作平均到每个元素的时间复杂度是 O(1)。</p><h3 id="二、用队列实现栈"><a href="#二、用队列实现栈" class="headerlink" title="二、用队列实现栈"></a>二、用队列实现栈</h3><p>如果说双栈实现队列比较巧妙，那么用队列实现栈就比较简单粗暴了，只需要一个队列作为底层数据结构。首先看下栈的 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> </span>&#123;<br>    <br>    <span class="hljs-comment">/** 添加元素到栈顶 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;<br>    <br>    <span class="hljs-comment">/** 删除栈顶的元素并返回 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-comment">/** 返回栈顶元素 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-comment">/** 判断栈是否为空 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>先说 <code>push</code> API，直接将元素加入队列，同时记录队尾元素，因为队尾元素相当于栈顶元素，如果要 <code>top</code> 查看栈顶元素的话可以直接返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> </span>&#123;<br>    Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> top_elem = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/** 添加元素到栈顶 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// x 是队列的队尾，是栈的栈顶</span><br>        q.offer(x);<br>        top_elem = x;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** 返回栈顶元素 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> top_elem;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的底层数据结构是先进先出的队列，每次 <code>pop</code> 只能从队头取元素；但是栈是后进先出，也就是说 <code>pop</code> API 要从队尾取元素。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%A0%88%E9%98%9F%E5%88%97/5.jpg"><br>解决方法简单粗暴，把队列前面的都取出来再加入队尾，让之前的队尾元素排到队头，这样就可以取出了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%A0%88%E9%98%9F%E5%88%97/6.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 删除栈顶的元素并返回 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = q.size();<br>    <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">1</span>) &#123;<br>        q.offer(q.poll());<br>        size--;<br>    &#125;<br>    <span class="hljs-comment">// 之前的队尾元素已经到了队头</span><br>    <span class="hljs-keyword">return</span> q.poll();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样实现还有一点小问题就是，原来的队尾元素被提到队头并删除了，但是 <code>top_elem</code> 变量没有更新，我们还需要一点小修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 删除栈顶的元素并返回 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = q.size();<br>    <span class="hljs-comment">// 留下队尾 2 个元素</span><br>    <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">2</span>) &#123;<br>        q.offer(q.poll());<br>        size--;<br>    &#125;<br>    <span class="hljs-comment">// 记录新的队尾元素</span><br>    top_elem = q.peek();<br>    q.offer(q.poll());<br>    <span class="hljs-comment">// 删除之前的队尾元素</span><br>    <span class="hljs-keyword">return</span> q.poll();<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，API <code>empty</code> 就很容易实现了，只要看底层的队列是否为空即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 判断栈是否为空 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> q.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显，用队列实现栈的话，<code>pop</code> 操作时间复杂度是 O(N)，其他操作都是 O(1)​。​<br>个人认为，用队列实现栈是没啥亮点的问题，但是<strong>用双栈实现队列是值得学习的</strong>。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%A0%88%E9%98%9F%E5%88%97/4.jpg"><br>从栈 <code>s1</code> 搬运元素到 <code>s2</code> 之后，元素在 <code>s2</code> 中就变成了队列的先进先出顺序，这个特性有点类似「负负得正」，确实不太容易想到。<br>希望本文对你有帮助。</p><p><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">上一篇：递归反转链表的一部分</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF">下一篇：算法学习之路</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FloodFill算法详解及应用</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/FloodFill%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/FloodFill%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="FloodFill算法详解及应用"><a href="#FloodFill算法详解及应用" class="headerlink" title="FloodFill算法详解及应用"></a>FloodFill算法详解及应用</h1><p>啥是 FloodFill 算法呢，最直接的一个应用就是「颜色填充」，就是 Windows 绘画本中那个小油漆桶的标志，可以把一块被圈起来的区域全部染色。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/floodfill/floodfill.gif" alt="floodfill"><br>这种算法思想还在许多其他地方有应用。比如说扫雷游戏，有时候你点一个方格，会一下子展开一片区域，这个展开过程，就是 FloodFill 算法实现的。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/floodfill/%E6%89%AB%E9%9B%B7.png" alt="扫雷"><br>类似的，像消消乐这类游戏，相同方块积累到一定数量，就全部消除，也是 FloodFill 算法的功劳。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/floodfill/xiaoxiaole.jpg" alt="xiaoxiaole"><br>通过以上的几个例子，你应该对 FloodFill 算法有个概念了，现在我们要抽象问题，提取共同点。</p><h3 id="一、构建框架"><a href="#一、构建框架" class="headerlink" title="一、构建框架"></a>一、构建框架</h3><p>以上几个例子，都可以抽象成一个二维矩阵（图片其实就是像素点矩阵），然后从某个点开始向四周扩展，直到无法再扩展为止。<br>矩阵，可以抽象为一幅「图」，这就是一个图的遍历问题，也就类似一个 N 叉树遍历的问题。几行代码就能解决，直接上框架吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// (x, y) 为坐标位置</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    fill(x - <span class="hljs-number">1</span>, y); <span class="hljs-comment">// 上</span><br>    fill(x + <span class="hljs-number">1</span>, y); <span class="hljs-comment">// 下</span><br>    fill(x, y - <span class="hljs-number">1</span>); <span class="hljs-comment">// 左</span><br>    fill(x, y + <span class="hljs-number">1</span>); <span class="hljs-comment">// 右</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个框架可以解决所有在二维矩阵中遍历的问题，说得高端一点，这就叫深度优先搜索（Depth First Search，简称 DFS），说得简单一点，这就叫四叉树遍历框架。坐标 (x, y) 就是 root，四个方向就是 root 的四个子节点。<br>下面看一道 LeetCode 题目，其实就是让我们来实现一个「颜色填充」功能。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/floodfill/leetcode.png" alt="title"><br>根据上篇文章，我们讲了「树」算法设计的一个总路线，今天就可以用到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] floodFill(<span class="hljs-keyword">int</span>[][] image,<br>        <span class="hljs-keyword">int</span> sr, <span class="hljs-keyword">int</span> sc, <span class="hljs-keyword">int</span> newColor) &#123;<br>    <span class="hljs-keyword">int</span> origColor = image[sr][sc];<br>    fill(image, sr, sc, origColor, newColor);<br>    <span class="hljs-keyword">return</span> image;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] image, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> origColor, <span class="hljs-keyword">int</span> newColor)</span> </span>&#123;<br>    <span class="hljs-comment">// 出界：超出边界索引</span><br>    <span class="hljs-keyword">if</span> (!inArea(image, x, y)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 碰壁：遇到其他颜色，超出 origColor 区域</span><br>    <span class="hljs-keyword">if</span> (image[x][y] != origColor) <span class="hljs-keyword">return</span>;<br>    image[x][y] = newColor;<br>    <br>    fill(image, x, y + <span class="hljs-number">1</span>, origColor, newColor);<br>    fill(image, x, y - <span class="hljs-number">1</span>, origColor, newColor);<br>    fill(image, x - <span class="hljs-number">1</span>, y, origColor, newColor);<br>    fill(image, x + <span class="hljs-number">1</span>, y, origColor, newColor);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] image, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; image.length<br>        &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; image[<span class="hljs-number">0</span>].length;<br>&#125;<br></code></pre></td></tr></table></figure><p>只要你能够理解这段代码，一定要给你鼓掌，给你 99 分，因为你对「框架思维」的掌控已经炉火纯青，此算法已经 cover 了 99% 的情况，仅有一个细节问题没有解决，就是当 origColor 和 newColor 相同时，会陷入无限递归。</p><h3 id="二、研究细节"><a href="#二、研究细节" class="headerlink" title="二、研究细节"></a>二、研究细节</h3><p>为什么会陷入无限递归呢，很好理解，因为每个坐标都要搜索上下左右，那么对于一个坐标，一定会被上下左右的坐标搜索。<strong>被重复搜索时，必须保证递归函数能够能正确地退出，否则就会陷入死循环。</strong><br>为什么 newColor 和 origColor 不同时可以正常退出呢？把算法流程画个图理解一下：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/floodfill/ppt1.PNG" alt="ppt1"><br>可以看到，fill(1, 1) 被重复搜索了，我们用 fill(1, 1)* 表示这次重复搜索。fill(1, 1)* 执行时，(1, 1) 已经被换成了 newColor，所以 fill(1, 1)* 会在这个 if 语句被怼回去，正确退出了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 碰壁：遇到其他颜色，超出 origColor 区域</span><br><span class="hljs-keyword">if</span> (image[x][y] != origColor) <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/floodfill/ppt2.PNG" alt="ppt2"><br>但是，如果说 origColor 和 newColor 一样，这个 if 语句就无法让 fill(1, 1)* 正确退出，而是开启了下面的重复递归，形成了死循环。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/floodfill/ppt3.PNG" alt="ppt3"></p><h3 id="三、处理细节"><a href="#三、处理细节" class="headerlink" title="三、处理细节"></a>三、处理细节</h3><p>如何避免上述问题的发生，最容易想到的就是用一个和 image 一样大小的二维 bool 数组记录走过的地方，一旦发现重复立即 return。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 出界：超出边界索引</span><br><span class="hljs-keyword">if</span> (!inArea(image, x, y)) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 碰壁：遇到其他颜色，超出 origColor 区域</span><br><span class="hljs-keyword">if</span> (image[x][y] != origColor) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 不走回头路</span><br><span class="hljs-keyword">if</span> (visited[x][y]) <span class="hljs-keyword">return</span>;<br>visited[x][y] = <span class="hljs-keyword">true</span>;<br>image[x][y] = newColor;<br></code></pre></td></tr></table></figure><p>完全 OK，这也是处理「图」的一种常用手段。不过对于此题，不用开数组，我们有一种更好的方法，那就是回溯算法。<br>前文「回溯算法详解」讲过，这里不再赘述，直接套回溯算法框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] image, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> origColor, <span class="hljs-keyword">int</span> newColor)</span> </span>&#123;<br>    <span class="hljs-comment">// 出界：超出数组边界</span><br>    <span class="hljs-keyword">if</span> (!inArea(image, x, y)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 碰壁：遇到其他颜色，超出 origColor 区域</span><br>    <span class="hljs-keyword">if</span> (image[x][y] != origColor) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 已探索过的 origColor 区域</span><br>    <span class="hljs-keyword">if</span> (image[x][y] == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// choose：打标记，以免重复</span><br>    image[x][y] = -<span class="hljs-number">1</span>;<br>    fill(image, x, y + <span class="hljs-number">1</span>, origColor, newColor);<br>    fill(image, x, y - <span class="hljs-number">1</span>, origColor, newColor);<br>    fill(image, x - <span class="hljs-number">1</span>, y, origColor, newColor);<br>    fill(image, x + <span class="hljs-number">1</span>, y, origColor, newColor);<br>    <span class="hljs-comment">// unchoose：将标记替换为 newColor</span><br>    image[x][y] = newColor;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种解决方法是最常用的，相当于使用一个特殊值 -1 代替 visited 数组的作用，达到不走回头路的效果。为什么是 -1，因为题目中说了颜色取值在 0 - 65535 之间，所以 -1 足够特殊，能和颜色区分开。</p><h3 id="四、拓展延伸：自动魔棒工具和扫雷"><a href="#四、拓展延伸：自动魔棒工具和扫雷" class="headerlink" title="四、拓展延伸：自动魔棒工具和扫雷"></a>四、拓展延伸：自动魔棒工具和扫雷</h3><p>大部分图片编辑软件一定有「自动魔棒工具」这个功能：点击一个地方，帮你自动选中相近颜色的部分。如下图，我想选中老鹰，可以先用自动魔棒选中蓝天背景，然后反向选择，就选中了老鹰。我们来分析一下自动魔棒工具的原理。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/floodfill/%E6%8A%A0%E5%9B%BE.jpg" alt="抠图"><br>显然，这个算法肯定是基于 FloodFill 算法的，但有两点不同：首先，背景色是蓝色，但不能保证都是相同的蓝色，毕竟是像素点，可能存在肉眼无法分辨的深浅差异，而我们希望能够忽略这种细微差异。第二，FloodFill 算法是「区域填充」，这里更像「边界填充」。<br>对于第一个问题，很好解决，可以设置一个阈值 threshold，在阈值范围内波动的颜色都视为 origColor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (Math.abs(image[x][y] - origColor) &gt; threshold)<br>    <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p>对于第二个问题，我们首先明确问题：不要把区域内所有 origColor 的都染色，而是只给区域最外圈染色。然后，我们分析，如何才能仅给外围染色，即如何才能找到最外围坐标，最外围坐标有什么特点？<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/floodfill/ppt4.PNG" alt="ppt4"><br>可以发现，区域边界上的坐标，至少有一个方向不是 origColor，而区域内部的坐标，四面都是 origColor，这就是解决问题的关键。保持框架不变，使用 visited 数组记录已搜索坐标，主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fill</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] image, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> origColor, <span class="hljs-keyword">int</span> newColor)</span> </span>&#123;<br>    <span class="hljs-comment">// 出界：超出数组边界</span><br>    <span class="hljs-keyword">if</span> (!inArea(image, x, y)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 已探索过的 origColor 区域</span><br>    <span class="hljs-keyword">if</span> (visited[x][y]) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 碰壁：遇到其他颜色，超出 origColor 区域</span><br>    <span class="hljs-keyword">if</span> (image[x][y] != origColor) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    visited[x][y] = <span class="hljs-keyword">true</span>;<br>    <br>    <span class="hljs-keyword">int</span> surround = <br>          fill(image, x - <span class="hljs-number">1</span>, y, origColor, newColor)<br>        + fill(image, x + <span class="hljs-number">1</span>, y, origColor, newColor)<br>        + fill(image, x, y - <span class="hljs-number">1</span>, origColor, newColor)<br>        + fill(image, x, y + <span class="hljs-number">1</span>, origColor, newColor);<br>    <br>    <span class="hljs-keyword">if</span> (surround &lt; <span class="hljs-number">4</span>)<br>        image[x][y] = newColor;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，区域内部的坐标探索四周后得到的 surround 是 4，而边界的坐标会遇到其他颜色，或超出边界索引，surround 会小于 4。如果你对这句话不理解，我们把逻辑框架抽象出来看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fill</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] image, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> origColor, <span class="hljs-keyword">int</span> newColor)</span> </span>&#123;<br>    <span class="hljs-comment">// 出界：超出数组边界</span><br>    <span class="hljs-keyword">if</span> (!inArea(image, x, y)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 已探索过的 origColor 区域</span><br>    <span class="hljs-keyword">if</span> (visited[x][y]) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 碰壁：遇到其他颜色，超出 origColor 区域</span><br>    <span class="hljs-keyword">if</span> (image[x][y] != origColor) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 未探索且属于 origColor 区域</span><br>    <span class="hljs-keyword">if</span> (image[x][y] == origColor) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这 4 个 if 判断涵盖了 (x, y) 的所有可能情况，surround 的值由四个递归函数相加得到，而每个递归函数的返回值就这四种情况的一种。借助这个逻辑框架，你一定能理解上面那句话了。<br>这样就实现了仅对 origColor 区域边界坐标染色的目的，等同于完成了魔棒工具选定区域边界的功能。<br>这个算法有两个细节问题，一是必须借助 visited 来记录已探索的坐标，而无法使用回溯算法；二是开头几个 if 顺序不可打乱。读者可以思考一下原因。<br>同理，思考扫雷游戏，应用 FloodFill 算法展开空白区域的同时，也需要计算并显示边界上雷的个数，如何实现的？其实也是相同的思路，遇到雷就返回 true，这样 surround 变量存储的就是雷的个数。当然，扫雷的 FloodFill 算法不能只检查上下左右，还得加上四个斜向。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/floodfill/ppt5.PNG"><br>以上详细讲解了 FloodFill 算法的框架设计，<strong>二维矩阵中的搜索问题，都逃不出这个算法框架</strong>。</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95">上一篇：字符串乘法</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98%E4%B9%8B%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6">下一篇：区间调度之区间合并问题</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnionFind算法应用</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Union-Find算法应用"><a href="#Union-Find算法应用" class="headerlink" title="Union-Find算法应用"></a>Union-Find算法应用</h1><p>上篇文章很多读者对于 Union-Find 算法的应用表示很感兴趣，这篇文章就拿几道 LeetCode 题目来讲讲这个算法的巧妙用法。<br>首先，复习一下，Union-Find 算法解决的是图的动态连通性问题，这个算法本身不难，能不能应用出来主要是看你抽象问题的能力，是否能够把原始问题抽象成一个有关图论的问题。<br>先复习一下上篇文章写的算法代码，回答读者提出的几个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span> </span>&#123;<br>    <span class="hljs-comment">// 记录连通分量个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-comment">// 存储若干棵树</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br>    <span class="hljs-comment">// 记录树的“重量”</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.count = n;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rootP = find(p);<br>        <span class="hljs-keyword">int</span> rootQ = find(q);<br>        <span class="hljs-keyword">if</span> (rootP == rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span> (size[rootP] &gt; size[rootQ]) &#123;<br>            parent[rootQ] = rootP;<br>            size[rootP] += size[rootQ];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[rootP] = rootQ;<br>            size[rootQ] += size[rootP];<br>        &#125;<br>        count--;<br>    &#125;<br>    <span class="hljs-comment">/* 判断 p 和 q 是否互相连通 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rootP = find(p);<br>        <span class="hljs-keyword">int</span> rootQ = find(q);<br>        <span class="hljs-comment">// 处于同一棵树上的节点，相互连通</span><br>        <span class="hljs-keyword">return</span> rootP == rootQ;<br>    &#125;<br>    <span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (parent[x] != x) &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x] = parent[parent[x]];<br>            x = parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法的关键点有 3 个：<br>1、用 <code>parent</code> 数组记录每个节点的父节点，相当于指向父节点的指针，所以 <code>parent</code> 数组内实际存储着一个森林（若干棵多叉树）。<br>2、用 <code>size</code> 数组记录着每棵树的重量，目的是让 <code>union</code> 后树依然拥有平衡性，而不会退化成链表，影响操作效率。<br>3、在 <code>find</code> 函数中进行路径压缩，保证任意树的高度保持在常数，使得 <code>union</code> 和 <code>connected</code> API 时间复杂度为 O(1)。<br>有的读者问，<strong>既然有了路径压缩，<code>size</code> 数组的重量平衡还需要吗</strong>？这个问题很有意思，因为路径压缩保证了树高为常数（不超过 3），那么树就算不平衡，高度也是常数，基本没什么影响。<br>我认为，论时间复杂度的话，确实，不需要重量平衡也是 O(1)。但是如果加上 <code>size</code> 数组辅助，效率还是略微高一些，比如下面这种情况：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/unionfind%E5%BA%94%E7%94%A8/1.jpg"><br>如果带有重量平衡优化，一定会得到情况一，而不带重量优化，可能出现情况二。高度为 3 时才会触发路径压缩那个 <code>while</code> 循环，所以情况一根本不会触发路径压缩，而情况二会多执行很多次路径压缩，将第三层节点压缩到第二层。<br>也就是说，去掉重量平衡，虽然对于单个的 <code>find</code> 函数调用，时间复杂度依然是 O(1)，但是对于 API 调用的整个过程，效率会有一定的下降。当然，好处就是减少了一些空间，不过对于 Big O 表示法来说，时空复杂度都没变。<br>下面言归正传，来看看这个算法有什么实际应用。</p><h3 id="一、DFS-的替代方案"><a href="#一、DFS-的替代方案" class="headerlink" title="一、DFS 的替代方案"></a>一、DFS 的替代方案</h3><p>很多使用 DFS 深度优先算法解决的问题，也可以用 Union-Find 算法解决。<br>比如第 130 题，被围绕的区域：给你一个 M×N 的二维矩阵，其中包含字符 <code>X</code> 和 <code>O</code>，让你找到矩阵中<strong>四面</strong>被 <code>X</code> 围住的 <code>O</code>，并且把它们替换成 <code>X</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span></span>;<br></code></pre></td></tr></table></figure><p>注意哦，必须是四面被围的 <code>O</code> 才能被换成 <code>X</code>，也就是说边角上的 <code>O</code> 一定不会被围，进一步，与边角上的 <code>O</code> 相连的 <code>O</code> 也不会被 <code>X</code> 围四面，也不会被替换。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/unionfind%E5%BA%94%E7%94%A8/2.jpg"><br>PS：这让我想起小时候玩的棋类游戏「黑白棋」，只要你用两个棋子把对方的棋子夹在中间，对方的子就被替换成你的子。可见，占据四角的棋子是无敌的，与其相连的边棋子也是无敌的（无法被夹掉）。<br>解决这个问题的传统方法也不困难，先用 for 循环遍历棋盘的<strong>四边</strong>，用 DFS 算法把那些与边界相连的 <code>O</code> 换成一个特殊字符，比如 <code>#</code>；然后再遍历整个棋盘，把剩下的 <code>O</code> 换成 <code>X</code>，把 <code>#</code> 恢复成 <code>O</code>。这样就能完成题目的要求，时间复杂度 O(MN)。<br>这个问题也可以用 Union-Find 算法解决，虽然实现复杂一些，甚至效率也略低，但这是使用 Union-Find 算法的通用思想，值得一学。<br><strong>你可以把那些不需要被替换的 <code>O</code> 看成一个拥有独门绝技的门派，它们有一个共同祖师爷叫 <code>dummy</code>，这些 <code>O</code> 和 <code>dummy</code> 互相连通，而那些需要被替换的 <code>O</code> 与 <code>dummy</code> 不连通</strong>。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/unionfind%E5%BA%94%E7%94%A8/3.jpg"><br>这就是 Union-Find 的核心思路，明白这个图，就很容易看懂代码了。<br>首先要解决的是，根据我们的实现，Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。<br>这个很简单，二维坐标 <code>(x,y)</code> 可以转换成 <code>x * n + y</code> 这个数（<code>m</code> 是棋盘的行数，<code>n</code> 是棋盘的列数）。敲黑板，<strong>这是将二维坐标映射到一维的常用技巧</strong>。<br>其次，我们之前描述的「祖师爷」是虚构的，需要给他老人家留个位置。索引 <code>[0.. m*n-1]</code> 都是棋盘内坐标的一维映射，那就让这个虚拟的 <code>dummy</code> 节点占据索引 <code>m * n</code> 好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (board.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> m = board.length;<br>    <span class="hljs-keyword">int</span> n = board[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-comment">// 给 dummy 留一个额外位置</span><br>    UF uf = <span class="hljs-keyword">new</span> UF(m * n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> dummy = m * n;<br>    <span class="hljs-comment">// 将首列和末列的 O 与 dummy 连通</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>            uf.union(i * n, dummy);<br>        <span class="hljs-keyword">if</span> (board[i][n - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>            uf.union(i * n + n - <span class="hljs-number">1</span>, dummy);<br>    &#125;<br>    <span class="hljs-comment">// 将首行和末行的 O 与 dummy 连通</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (board[<span class="hljs-number">0</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>            uf.union(j, dummy);<br>        <span class="hljs-keyword">if</span> (board[m - <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>            uf.union(n * (m - <span class="hljs-number">1</span>) + j, dummy);<br>    &#125;<br>    <span class="hljs-comment">// 方向数组 d 是上下左右搜索的常用手法</span><br>    <span class="hljs-keyword">int</span>[][] d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m - <span class="hljs-number">1</span>; i++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; j++) <br>            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                <span class="hljs-comment">// 将此 O 与上下左右的 O 连通</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                    <span class="hljs-keyword">int</span> x = i + d[k][<span class="hljs-number">0</span>];<br>                    <span class="hljs-keyword">int</span> y = j + d[k][<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (board[x][y] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                        uf.union(x * n + y, i * n + j);<br>                &#125;<br>    <span class="hljs-comment">// 所有不和 dummy 连通的 O，都要被替换</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m - <span class="hljs-number">1</span>; i++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; j++) <br>            <span class="hljs-keyword">if</span> (!uf.connected(dummy, i * n + j))<br>                board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码很长，其实就是刚才的思路实现，只有和边界 <code>O</code> 相连的 <code>O</code> 才具有和 <code>dummy</code> 的连通性，他们不会被替换。<br>说实话，Union-Find 算法解决这个简单的问题有点杀鸡用牛刀，它可以解决更复杂，更具有技巧性的问题，<strong>主要思路是适时增加虚拟节点，想办法让元素「分门别类」，建立动态连通关系</strong>。</p><h3 id="二、判定合法等式"><a href="#二、判定合法等式" class="headerlink" title="二、判定合法等式"></a>二、判定合法等式</h3><p>这个问题用 Union-Find 算法就显得十分优美了。题目是这样：<br>给你一个数组 <code>equations</code>，装着若干字符串表示的算式。每个算式 <code>equations[i]</code> 长度都是 4，而且只有这两种情况：<code>a==b</code> 或者 <code>a!=b</code>，其中 <code>a,b</code> 可以是任意小写字母。你写一个算法，如果 <code>equations</code> 中所有算式都不会互相冲突，返回 true，否则返回 false。<br>比如说，输入 <code>[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]</code>，算法返回 false，因为这三个算式不可能同时正确。<br>再比如，输入 <code>[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]</code>，算法返回 true，因为这三个算式并不会造成逻辑冲突。<br>我们前文说过，动态连通性其实就是一种等价关系，具有「自反性」「传递性」和「对称性」，其实 <code>==</code> 关系也是一种等价关系，具有这些性质。所以这个问题用 Union-Find 算法就很自然。<br>核心思想是，<strong>将 <code>equations</code> 中的算式根据 <code>==</code> 和 <code>!=</code> 分成两部分，先处理 <code>==</code> 算式，使得他们通过相等关系各自勾结成门派；然后处理 <code>!=</code> 算式，检查不等关系是否破坏了相等关系的连通性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equationsPossible</span><span class="hljs-params">(String[] equations)</span> </span>&#123;<br>    <span class="hljs-comment">// 26 个英文字母</span><br>    UF uf = <span class="hljs-keyword">new</span> UF(<span class="hljs-number">26</span>);<br>    <span class="hljs-comment">// 先让相等的字母形成连通分量</span><br>    <span class="hljs-keyword">for</span> (String eq : equations) &#123;<br>        <span class="hljs-keyword">if</span> (eq.charAt(<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;=&#x27;</span>) &#123;<br>            <span class="hljs-keyword">char</span> x = eq.charAt(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">char</span> y = eq.charAt(<span class="hljs-number">3</span>);<br>            uf.union(x - <span class="hljs-string">&#x27;a&#x27;</span>, y - <span class="hljs-string">&#x27;a&#x27;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查不等关系是否打破相等关系的连通性</span><br>    <span class="hljs-keyword">for</span> (String eq : equations) &#123;<br>        <span class="hljs-keyword">if</span> (eq.charAt(<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;!&#x27;</span>) &#123;<br>            <span class="hljs-keyword">char</span> x = eq.charAt(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">char</span> y = eq.charAt(<span class="hljs-number">3</span>);<br>            <span class="hljs-comment">// 如果相等关系成立，就是逻辑冲突</span><br>            <span class="hljs-keyword">if</span> (uf.connected(x - <span class="hljs-string">&#x27;a&#x27;</span>, y - <span class="hljs-string">&#x27;a&#x27;</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，这道判断算式合法性的问题就解决了，借助 Union-Find 算法，是不是很简单呢？</p><h3 id="三、简单总结"><a href="#三、简单总结" class="headerlink" title="三、简单总结"></a>三、简单总结</h3><p>使用 Union-Find 算法，主要是如何把原问题转化成图的动态连通性问题。对于算式合法性问题，可以直接利用等价关系，对于棋盘包围问题，则是利用一个虚拟节点，营造出动态连通特性。<br>另外，将二维数组映射到一维数组，利用方向数组 <code>d</code> 来简化代码量，都是在写算法时常用的一些小技巧，如果没见过可以注意一下。<br>很多更复杂的 DFS 算法问题，都可以利用 Union-Find 算法更漂亮的解决。LeetCode 上 Union-Find 相关的问题也就二十多道，有兴趣的读者可以去做一做。</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3">上一篇：Union-Find算法详解</a><br><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E7%9A%84%E6%99%BA%E5%8A%9B%E9%A2%98">下一篇：一行代码就能解决的算法题</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnionFind算法详解</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Union-Find算法详解"><a href="#Union-Find算法详解" class="headerlink" title="Union-Find算法详解"></a>Union-Find算法详解</h1><p>今天讲讲 Union-Find 算法，也就是常说的并查集算法，主要是解决图论中「动态连通性」问题的。名词很高端，其实特别好理解，等会解释，另外这个算法的应用都非常有趣。<br>说起这个 Union-Find，应该算是我的「启蒙算法」了，因为《算法4》的开头就介绍了这款算法，可是把我秀翻了，感觉好精妙啊！后来刷了 LeetCode，并查集相关的算法题目都非常有意思，而且《算法4》给的解法竟然还可以进一步优化，只要加一个微小的修改就可以把时间复杂度降到 O(1)。<br>废话不多说，直接上干货，先解释一下什么叫动态连通性吧。</p><h3 id="一、问题介绍"><a href="#一、问题介绍" class="headerlink" title="一、问题介绍"></a>一、问题介绍</h3><p>简单说，动态连通性其实可以抽象成给一幅图连线。比如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/unionfind/1.jpg"><br>现在我们的 Union-Find 算法主要需要实现这两个 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span> </span>&#123;<br>    <span class="hljs-comment">/* 将 p 和 q 连接 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>;<br>    <span class="hljs-comment">/* 判断 p 和 q 是否连通 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>;<br>    <span class="hljs-comment">/* 返回图中有多少个连通分量 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：<br>1、自反性：节点<code>p</code>和<code>p</code>是连通的。<br>2、对称性：如果节点<code>p</code>和<code>q</code>连通，那么<code>q</code>和<code>p</code>也连通。<br>3、传递性：如果节点<code>p</code>和<code>q</code>连通，<code>q</code>和<code>r</code>连通，那么<code>p</code>和<code>r</code>也连通。<br>比如说之前那幅图，0～9 任意两个<strong>不同</strong>的点都不连通，调用<code>connected</code>都会返回 false，连通分量为 10 个。<br>如果现在调用<code>union(0, 1)</code>，那么 0 和 1 被连通，连通分量降为 9 个。<br>再调用<code>union(1, 2)</code>，这时 0,1,2 都被连通，调用<code>connected(0, 2)</code>也会返回 true，连通分量变为 8 个。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/unionfind/2.jpg"><br>判断这种「等价关系」非常实用，比如说编译器判断同一个变量的不同引用，比如社交网络中的朋友圈计算等等。<br>这样，你应该大概明白什么是动态连通性了，Union-Find 算法的关键就在于<code>union</code>和<code>connected</code>函数的效率。那么用什么模型来表示这幅图的连通状态呢？用什么数据结构来实现代码呢？</p><h3 id="二、基本思路"><a href="#二、基本思路" class="headerlink" title="二、基本思路"></a>二、基本思路</h3><p>注意我刚才把「模型」和具体的「数据结构」分开说，这么做是有原因的。因为我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。<br>怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。比如说刚才那幅 10 个节点的图，一开始的时候没有相互连通，就是这样：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/unionfind/3.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span> </span>&#123;<br>    <span class="hljs-comment">// 记录连通分量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-comment">// 节点 x 的节点是 parent[x]</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br>    <span class="hljs-comment">/* 构造函数，n 为图的节点总数 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 一开始互不连通</span><br>        <span class="hljs-keyword">this</span>.count = n;<br>        <span class="hljs-comment">// 父节点指针初始指向自己</span><br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            parent[i] = i;<br>    &#125;<br>    <span class="hljs-comment">/* 其他函数 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上</strong>：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/unionfind/4.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rootP = find(p);<br>    <span class="hljs-keyword">int</span> rootQ = find(q);<br>    <span class="hljs-keyword">if</span> (rootP == rootQ)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 将两棵树合并为一棵</span><br>    parent[rootP] = rootQ;<br>    <span class="hljs-comment">// parent[rootQ] = rootP 也一样</span><br>    count--; <span class="hljs-comment">// 两个分量合二为一</span><br>&#125;<br><span class="hljs-comment">/* 返回某个节点 x 的根节点 */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">// 根节点的 parent[x] == x</span><br>    <span class="hljs-keyword">while</span> (parent[x] != x)<br>        x = parent[x];<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">/* 返回当前的连通分量个数 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这样，如果节点<code>p</code>和<code>q</code>连通的话，它们一定拥有相同的根节点</strong>：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/unionfind/5.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rootP = find(p);<br>    <span class="hljs-keyword">int</span> rootQ = find(q);<br>    <span class="hljs-keyword">return</span> rootP == rootQ;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，Union-Find 算法就基本完成了。是不是很神奇？竟然可以这样使用数组来模拟出一个森林，如此巧妙的解决这个比较复杂的问题！<br>那么这个算法的复杂度是多少呢？我们发现，主要 API<code>connected</code>和<code>union</code>中的复杂度都是<code>find</code>函数造成的，所以说它们的复杂度和<code>find</code>一样。<br><code>find</code>主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是<code>logN</code>，但这并不一定。<code>logN</code>的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成<code>N</code>。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/unionfind/6.jpg"><br>所以说上面这种解法，<code>find</code>,<code>union</code>,<code>connected</code>的时间复杂度都是 O(N)。这个复杂度很不理想的，你想图论解决的都是诸如社交网络这样数据规模巨大的问题，对于<code>union</code>和<code>connected</code>的调用非常频繁，每次调用需要线性时间完全不可忍受。<br><strong>问题的关键在于，如何想办法避免树的不平衡呢</strong>？只需要略施小计即可。</p><h3 id="三、平衡性优化"><a href="#三、平衡性优化" class="headerlink" title="三、平衡性优化"></a>三、平衡性优化</h3><p>我们要知道哪种情况下可能出现不平衡现象，关键在于<code>union</code>过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rootP = find(p);<br>    <span class="hljs-keyword">int</span> rootQ = find(q);<br>    <span class="hljs-keyword">if</span> (rootP == rootQ)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 将两棵树合并为一棵</span><br>    parent[rootP] = rootQ;<br>    <span class="hljs-comment">// parent[rootQ] = rootP 也可以</span><br>    count--; <br></code></pre></td></tr></table></figure><p>我们一开始就是简单粗暴的把<code>p</code>所在的树接到<code>q</code>所在的树的根节点下面，那么这里就可能出现「头重脚轻」的不平衡状况，比如下面这种局面：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/unionfind/7.jpg"><br>长此以往，树可能生长得很不平衡。<strong>我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些</strong>。解决方法是额外使用一个<code>size</code>数组，记录每棵树包含的节点数，我们不妨称为「重量」：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br>    <span class="hljs-comment">// 新增一个数组记录树的“重量”</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.count = n;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-comment">// 最初每棵树只有一个节点</span><br>        <span class="hljs-comment">// 重量应该初始化 1</span><br>        size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 其他函数 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如说<code>size[3] = 5</code>表示，以节点<code>3</code>为根的那棵树，总共有<code>5</code>个节点。这样我们可以修改一下<code>union</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rootP = find(p);<br>    <span class="hljs-keyword">int</span> rootQ = find(q);<br>    <span class="hljs-keyword">if</span> (rootP == rootQ)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>    <span class="hljs-keyword">if</span> (size[rootP] &gt; size[rootQ]) &#123;<br>        parent[rootQ] = rootP;<br>        size[rootP] += size[rootQ];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        parent[rootP] = rootQ;<br>        size[rootQ] += size[rootP];<br>    &#125;<br>    count--;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在<code>logN</code>这个数量级，极大提升执行效率。<br>此时，<code>find</code>,<code>union</code>,<code>connected</code>的时间复杂度都下降为 O(logN)，即便数据规模上亿，所需时间也非常少。</p><h3 id="四、路径压缩"><a href="#四、路径压缩" class="headerlink" title="四、路径压缩"></a>四、路径压缩</h3><p>这步优化特别简单，所以非常巧妙。我们能不能进一步压缩每棵树的高度，使树高始终保持为常数？<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/unionfind/8.jpg"><br>这样<code>find</code>就能以 O(1) 的时间找到某一节点的根节点，相应的，<code>connected</code>和<code>union</code>复杂度都下降为 O(1)。<br>要做到这一点，非常简单，只需要在<code>find</code>中加一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (parent[x] != x) &#123;<br>        <span class="hljs-comment">// 进行路径压缩</span><br>        parent[x] = parent[parent[x]];<br>        x = parent[x];<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个操作有点匪夷所思，看个 GIF 就明白它的作用了（为清晰起见，这棵树比较极端）：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/unionfind/9.gif"><br>可见，调用<code>find</code>函数每次向树根遍历的同时，顺手将树高缩短了，最终所有树高都不会超过 3（<code>union</code>的时候树高可能达到 3）。<br>PS：读者可能会问，这个 GIF 图的find过程完成之后，树高恰好等于 3 了，但是如果更高的树，压缩后高度依然会大于 3 呀？不能这么想。这个 GIF 的情景是我编出来方便大家理解路径压缩的，但是实际中，每次find都会进行路径压缩，所以树本来就不可能增长到这么高，你的这种担心应该是多余的。</p><h3 id="五、最后总结"><a href="#五、最后总结" class="headerlink" title="五、最后总结"></a>五、最后总结</h3><p>我们先来看一下完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span> </span>&#123;<br>    <span class="hljs-comment">// 连通分量个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-comment">// 存储一棵树</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br>    <span class="hljs-comment">// 记录树的“重量”</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.count = n;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rootP = find(p);<br>        <span class="hljs-keyword">int</span> rootQ = find(q);<br>        <span class="hljs-keyword">if</span> (rootP == rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span> (size[rootP] &gt; size[rootQ]) &#123;<br>            parent[rootQ] = rootP;<br>            size[rootP] += size[rootQ];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[rootP] = rootQ;<br>            size[rootQ] += size[rootP];<br>        &#125;<br>        count--;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rootP = find(p);<br>        <span class="hljs-keyword">int</span> rootQ = find(q);<br>        <span class="hljs-keyword">return</span> rootP == rootQ;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (parent[x] != x) &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x] = parent[parent[x]];<br>            x = parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Union-Find 算法的复杂度可以这样分析：构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；连通两个节点<code>union</code>、判断两个节点的连通性<code>connected</code>、计算连通分量<code>count</code>所需的时间复杂度均为 O(1)。</p><p><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%BA%A7%E4%BD%8D%E8%B0%83%E5%BA%A6">上一篇：如何调度考生的座位</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8">下一篇：Union-Find算法应用</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>twoSum问题的核心思想</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/twoSum%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/twoSum%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="twoSum问题的核心思想"><a href="#twoSum问题的核心思想" class="headerlink" title="twoSum问题的核心思想"></a>twoSum问题的核心思想</h1><p>Two Sum 系列问题在 LeetCode 上有好几道，这篇文章就挑出有代表性的几道，介绍一下这种问题怎么解决。</p><h3 id="TwoSum-I"><a href="#TwoSum-I" class="headerlink" title="TwoSum I"></a>TwoSum I</h3><p>这个问题的<strong>最基本形式</strong>是这样：给你一个数组和一个整数 <code>target</code>，可以保证数组中<strong>存在</strong>两个数的和为 <code>target</code>，请你返回这两个数的索引。<br>比如输入 <code>nums = [3,1,3,6], target = 6</code>，算法应该返回数组 <code>[0,2]</code>，因为 3 + 3 = 6。<br>这个问题如何解决呢？首先最简单粗暴的办法当然是穷举了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) <br>            <span class="hljs-keyword">if</span> (nums[j] == target - nums[i]) <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; i, j &#125;;<br>    <span class="hljs-comment">// 不存在这么两个数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个解法非常直接，时间复杂度 O(N^2)，空间复杂度 O(1)。<br>可以通过一个哈希表减少时间复杂度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    index&lt;Integer, Integer&gt; index = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">// 构造一个哈希表：元素映射到相应的索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        index.put(nums[i], i);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> other = target - nums[i];<br>        <span class="hljs-comment">// 如果 other 存在且不是 nums[i] 本身</span><br>        <span class="hljs-keyword">if</span> (index.containsKey(other) &amp;&amp; index.get(other) != i)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;i, index.get(other)&#125;;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，由于哈希表的查询时间为 O(1)，算法的时间复杂度降低到 O(N)，但是需要 O(N) 的空间复杂度来存储哈希表。不过综合来看，是要比暴力解法高效的。<br><strong>我觉得 Two Sum 系列问题就是想教我们如何使用哈希表处理问题</strong>。我们接着往后看。</p><h3 id="TwoSum-II"><a href="#TwoSum-II" class="headerlink" title="TwoSum II"></a>TwoSum II</h3><p>这里我们稍微修改一下上面的问题。我们设计一个类，拥有两个 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoSum</span> </span>&#123;<br>    <span class="hljs-comment">// 向数据结构中添加一个数 number</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>;<br>    <span class="hljs-comment">// 寻找当前数据结构中是否存在两个数的和为 value</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何实现这两个 API 呢，我们可以仿照上一道题目，使用一个哈希表辅助 <code>find</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoSum</span> </span>&#123;<br>    Map&lt;Integer, Integer&gt; freq = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-comment">// 记录 number 出现的次数</span><br>        freq.put(number, freq.getOrDefault(number, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Integer key : freq.keySet()) &#123;<br>            <span class="hljs-keyword">int</span> other = value - key;<br>            <span class="hljs-comment">// 情况一</span><br>            <span class="hljs-keyword">if</span> (other == key &amp;&amp; freq.get(key) &gt; <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">// 情况二</span><br>            <span class="hljs-keyword">if</span> (other != key &amp;&amp; freq.containsKey(other))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行 <code>find</code> 的时候有两种情况，举个例子：<br>情况一：<code>add</code> 了 <code>[3,3,2,5]</code> 之后，执行 <code>find(6)</code>，由于 3 出现了两次，3 + 3 = 6，所以返回 true。<br>情况二：<code>add</code> 了 <code>[3,3,2,5]</code> 之后，执行 <code>find(7)</code>，那么 <code>key</code> 为 2，<code>other</code> 为 5 时算法可以返回 true。<br>除了上述两种情况外，<code>find</code> 只能返回 false 了。<br>对于这个解法的时间复杂度呢，<code>add</code> 方法是 O(1)，<code>find</code> 方法是 O(N)，空间复杂度为 O(N)，和上一道题目比较类似。<br><strong>但是对于 API 的设计，是需要考虑现实情况的</strong>。比如说，我们设计的这个类，使用 <code>find</code> 方法非常频繁，那么每次都要 O(N) 的时间，岂不是很浪费费时间吗？对于这种情况，我们是否可以做些优化呢？<br>是的，对于频繁使用 <code>find</code> 方法的场景，我们可以进行优化。我们可以参考上一道题目的暴力解法，借助<strong>哈希集合</strong>来针对性优化 <code>find</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoSum</span> </span>&#123;<br>    Set&lt;Integer&gt; sum = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    List&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-comment">// 记录所有可能组成的和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : nums)<br>            sum.add(n + number);<br>        nums.add(number);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sum.contains(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样 <code>sum</code> 中就储存了所有加入数字可能组成的和，每次 <code>find</code> 只要花费 O(1) 的时间在集合中判断一下是否存在就行了，显然非常适合频繁使用 <code>find</code> 的场景。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>对于 TwoSum 问题，一个难点就是给的数组<strong>无序</strong>。对于一个无序的数组，我们似乎什么技巧也没有，只能暴力穷举所有可能。<br><strong>一般情况下，我们会首先把数组排序再考虑双指针技巧</strong>。TwoSum 启发我们，HashMap 或者 HashSet 也可以帮助我们处理无序数组相关的简单问题。<br>另外，设计的核心在于权衡，利用不同的数据结构，可以得到一些针对性的加强。<br>最后，如果 TwoSum I 中给的数组是有序的，应该如何编写算法呢？答案很简单，前文「双指针技巧汇总」写过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> sum = nums[left] + nums[right];<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left, right&#125;;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>            left++; <span class="hljs-comment">// 让 sum 大一点</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>            right--; <span class="hljs-comment">// 让 sum 小一点</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 不存在这样两个数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7">上一篇：滑动窗口技巧</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BD%8D%E6%93%8D%E4%BD%9C">下一篇：常用的位操作</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么推荐算法4</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%954/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%954/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么我推荐《算法4》"><a href="#为什么我推荐《算法4》" class="headerlink" title="为什么我推荐《算法4》"></a>为什么我推荐《算法4》</h1><p>咱们的公众号有很多硬核的算法文章，今天就聊点轻松的，就具体聊聊我非常“鼓吹”的《算法4》。这本书我在之前的文章多次推荐过，但是没有具体的介绍，今天就来正式介绍一下。。<br>我的推荐不会直接甩一大堆书目，而是会联系实际生活，讲一些书中有趣有用的知识，无论你最后会不会去看这本书，本文都会给你带来一些收获。<br><strong>首先这本书是适合初学者的</strong>。总是有很多读者问，我只会 C 语言，能不能看《算法4》？学算法最好用什么语言？诸如此类的问题。<br>经常看咱们公众号的读者应该体会到了，算法其实是一种思维模式，和你用什么语言没啥关系。我们的文章也不会固定用某一种语言，而是什么语言写出来容易理解就用什么语言。再退一步说，到底适不适合你，网上找个 PDF 亲自看一下不就知道了？<br>《算法4》看起来挺厚的，但是前面几十页是教你 Java 的；每章后面还有习题，占了不少页数；每章还有一些数学证明，这些都可以忽略。这样算下来，剩下的就是基础知识和疑难解答之类的内容，含金量很高，把这些基础知识动手实践一遍，真的就可以达到不错的水平了。<br>我觉得这本书之所以能有这么高的评分，一个是因为讲解详细，还有大量配图，另一个原因就是书中把一些算法和现实生活中的使用场景联系起来，你不仅知道某个算法怎么实现，也知道它大概能运用到什么场景，下面我就来介绍两个图算法的简单应用。</p><h3 id="一、二分图的应用"><a href="#一、二分图的应用" class="headerlink" title="一、二分图的应用"></a>一、二分图的应用</h3><p>我想举的第一个例子是<strong>二分图</strong>。简单来说，二分图就是一幅拥有特殊性质的图：能够用两种颜色为所有顶点着色，使得任何一条边的两个顶点颜色不同。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/algo4/1.jpg"><br>明白了二分图是什么，能解决什么实际问题呢？<strong>算法方面，常见的操作是如何判定一幅图是不是二分图</strong>。比如说下面这道 LeetCode 题目：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/algo4/title.png"><br>你想想，如果我们把每个人视为一个顶点，边代表讨厌；相互讨厌的两个人之间连接一条边，就可以形成一幅图。那么根据刚才二分图的定义，如果这幅图是一幅二分图，就说明这些人可以被分为两组，否则的话就不行。<br>这是判定二分图算法的一个应用，<strong>其实二分图在数据结构方面也有一些不错的特性</strong>。<br>比如说我们需要一种数据结构来储存电影和演员之间的关系：某一部电影肯定是由多位演员出演的，且某一位演员可能会出演多部电影。你使用什么数据结构来存储这种关系呢？<br>既然是存储映射关系，最简单的不就是使用哈希表嘛，我们可以使用一个 <code>HashMap&lt;String, List&lt;String&gt;&gt;</code> 来存储电影到演员列表的映射，如果给一部电影的名字，就能快速得到出演该电影的演员。<br>但是如果给出一个演员的名字，我们想快速得到该演员演出的所有电影，怎么办呢？这就需要「反向索引」，对之前的哈希表进行一些操作，新建另一个哈希表，把演员作为键，把电影列表作为值。<br>对于上面这个例子，可以使用二分图来取代哈希表。电影和演员是具有二分图性质的：如果把电影和演员视为图中的顶点，出演关系作为边，那么与电影顶点相连的一定是演员，与演员相邻的一定是电影，不存在演员和演员相连，电影和电影相连的情况。<br>回顾二分图的定义，如果对演员和电影顶点着色，肯定就是一幅二分图：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/algo4/2.jpg"><br>如果这幅图构建完成，就不需要反向索引，对于演员顶点，其直接连接的顶点就是他出演的电影，对于电影顶点，其直接连接的顶点就是出演演员。<br>当然，对于这个问题，书中还提到了一些其他有趣的玩法，比如说社交网络中「间隔度数」的计算（六度空间理论应该听说过）等等，其实就是一个 BFS 广度优先搜索寻找最短路径的问题，具体代码实现这里就不展开了。</p><h3 id="二、套汇的算法"><a href="#二、套汇的算法" class="headerlink" title="二、套汇的算法"></a>二、套汇的算法</h3><p>如果我们说货币 A 到货币 B 的汇率是 10，意思就是 1 单位的货币 A 可以换 10 单位货币 B。如果我们把每种货币视为一幅图的顶点，货币之间的汇率视为加权有向边，那么整个汇率市场就是一幅「完全加权有向图」。<br>一旦把现实生活中的情景抽象成图，就有可能运用算法解决一些问题。比如说图中可能存在下面的情况：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/algo4/3.jpg"><br>图中的加权有向边代表汇率，我们可以发现如果把 100 单位的货币 A 换成 B，再换成 C，最后换回 A，就可以得到 100×0.9×0.8×1.4 = 100.8 单位的 A！如果交易的金额大一些的话，赚的钱是很可观的，这种空手套白狼的操作就是套汇。<br>现实中交易会有种种限制，而且市场瞬息万变，但是套汇的利润还是很高的，关键就在于如何<strong>快速</strong>找到这种套汇机会呢？<br>借助图的抽象，我们发现套汇机会其实就是一个环，且这个环上的权重之积大于 1，只要在顺着这个环交易一圈就能空手套白狼。<br>图论中有一个经典算法叫做 <strong>Bellman-Ford 算法，可以用于寻找负权重环</strong>。对于我们说的套汇问题，可以先把所有边的权重 w 替换成 -ln(w)，这样「寻找权重乘积大于 1 的环」就转化成了「寻找权重和小于 0 的环」，就可以使用 Bellman-Ford 算法在 O(EV) 的时间内寻找负权重环，也就是寻找套汇机会。<br>《算法4》就介绍到这里，关于上面两个例子的具体内容，可以自己去看书，公众号后台回复关键词「算法4」就有 PDF。</p><h3 id="三、最后说几句"><a href="#三、最后说几句" class="headerlink" title="三、最后说几句"></a>三、最后说几句</h3><p>首先，前文说对于数学证明、章后习题可以忽略，可能有人要抬杠了：难道习题和数学证明不重要吗？<br>那我想说，就是不重要，起码对大多数人来说不重要。我觉得吧，学习就要带着目的性去学，大部分人学算法不就是巩固计算机知识，对付面试题目吗？<strong>如果是这个目的</strong>，那就学些基本的数据结构和经典算法，明白它们的时间复杂度，然后去刷题就好了，何必和习题、证明过不去？<br>这也是我从来不推荐《算法导论》这本书的原因。如果有人给你推荐这本书，只可能有两个原因，要么他是真大佬，要么他在装大佬。《算法导论》中充斥大量数学证明，而且很多数据结构是很少用到的，顶多当个字典用。你说你学了那些有啥用呢，饶过自己呗。<br>另外，读书在精不在多。你花时间《算法4》过个大半（最后小半部分有点困难），同时刷点题，看看咱们的公众号文章，算法这块真就够了，别对细节问题太较真。<br><strong>致力于把算法讲清楚！欢迎关注我的微信公众号 labuladong，查看更多通俗易懂的文章</strong>，公众号后台回复关键词「算法4」可以获得 PDF 下载：</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E6%95%88%E6%96%B9%E6%B3%95">上一篇：学习算法和刷题的框架思维</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6">下一篇：动态规划解题框架</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信封嵌套问题</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="信封嵌套问题"><a href="#信封嵌套问题" class="headerlink" title="信封嵌套问题"></a>信封嵌套问题</h1><p>很多算法问题都需要排序技巧，其难点不在于排序本身，而是需要巧妙地排序进行预处理，将算法问题进行转换，为之后的操作打下基础。<br>信封嵌套问题就需要先按特定的规则排序，之后就转换为一个 <a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">最长递增子序列问题</a>，可以用前文 <a href="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3">二分查找详解</a> 的技巧来解决了。</p><h3 id="一、题目概述"><a href="#一、题目概述" class="headerlink" title="一、题目概述"></a>一、题目概述</h3><p>信封嵌套问题是个很有意思且经常出现在生活中的问题，先看下题目：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97/title.png" alt="title"><br>这道题目其实是最长递增子序列（Longes Increasing Subsequence，简写为 LIS）的一个变种，因为很显然，每次合法的嵌套是大的套小的，相当于找一个最长递增的子序列，其长度就是最多能嵌套的信封个数。<br>但是难点在于，标准的 LIS 算法只能在数组中寻找最长子序列，而我们的信封是由 <code>(w, h)</code> 这样的二维数对形式表示的，如何把 LIS 算法运用过来呢？<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97/0.jpg" alt="0"><br>读者也许会想，通过 <code>w × h</code> 计算面积，然后对面积进行标准的 LIS 算法。但是稍加思考就会发现这样不行，比如 <code>1 × 10</code> 大于 <code>3 × 3</code>，但是显然这样的两个信封是无法互相嵌套的。</p><h3 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h3><p>这道题的解法是比较巧妙的：<br><strong>先对宽度 <code>w</code> 进行升序排序，如果遇到 <code>w</code> 相同的情况，则按照高度 <code>h</code> 降序排序。之后把所有的 <code>h</code> 作为一个数组，在这个数组上计算 LIS 的长度就是答案。</strong><br>画个图理解一下，先对这些数对进行排序：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97/1.jpg" alt="1"><br>然后在 <code>h</code> 上寻找最长递增子序列：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97/2.jpg" alt="2"><br>这个子序列就是最优的嵌套方案。<br>这个解法的关键在于，对于宽度 <code>w</code> 相同的数对，要对其高度 <code>h</code> 进行降序排序。因为两个宽度相同的信封不能相互包含的，逆序排序保证在 <code>w</code> 相同的数对中最多只选取一个。<br>下面看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// envelopes = [[w, h], [w, h]...]</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] envelopes)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = envelopes.length;<br>    <span class="hljs-comment">// 按宽度升序排列，如果宽度一样，则按高度降序排列</span><br>    Arrays.sort(envelopes, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() <br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>] ? <br>                b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>] : a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 对高度数组寻找 LIS</span><br>    <span class="hljs-keyword">int</span>[] height = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        height[i] = envelopes[i][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> lengthOfLIS(height);<br>&#125;<br></code></pre></td></tr></table></figure><p>关于最长递增子序列的寻找方法，在前文中详细介绍了动态规划解法,并用扑克牌游戏解释了二分查找解法，本文就不展开了，直接套用算法模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 返回 nums 中 LIS 的长度 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> piles = <span class="hljs-number">0</span>, n = nums.length;<br>    <span class="hljs-keyword">int</span>[] top = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 要处理的扑克牌</span><br>        <span class="hljs-keyword">int</span> poker = nums[i];<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = piles;<br>        <span class="hljs-comment">// 二分查找插入位置</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (top[mid] &gt;= poker)<br>                right = mid;<br>            <span class="hljs-keyword">else</span><br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left == piles) piles++;<br>        <span class="hljs-comment">// 把这张牌放到牌堆顶</span><br>        top[left] = poker;<br>    &#125;<br>    <span class="hljs-comment">// 牌堆数就是 LIS 长度</span><br>    <span class="hljs-keyword">return</span> piles;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了清晰，我将代码分为了两个函数， 你也可以合并，这样可以节省下 <code>height</code> 数组的空间。<br>此算法的时间复杂度为 $O(NlogN)$，因为排序和计算 LIS 各需要 $O(NlogN)$ 的时间。<br>空间复杂度为 $O(N)$，因为计算 LIS 的函数中需要一个 <code>top</code> 数组。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>这个问题是个 Hard 级别的题目，难就难在排序，正确地排序后此问题就被转化成了一个标准的 LIS 问题，容易解决一些。<br>其实这种问题还可以拓展到三维，比如说现在不是让你嵌套信封，而是嵌套箱子，每个箱子有长宽高三个维度，请你算算最多能嵌套几个箱子？<br>我们可能会这样想，先把前两个维度（长和宽）按信封嵌套的思路求一个嵌套序列，最后在这个序列的第三个维度（高度）找一下 LIS，应该能算出答案。<br>实际上，这个思路是错误的。这类问题叫做「偏序问题」，上升到三维会使难度巨幅提升，需要借助一种高级数据结构「树状数组」，有兴趣的读者可以自行搜索。<br>有很多算法问题都需要排序后进行处理，阿东正在进行整理总结。希望本文对你有帮助。</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8C%BA%E9%97%B4%E4%BA%A4%E9%9B%86%E9%97%AE%E9%A2%98">上一篇：区间调度之区间交集问题</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%87%A0%E4%B8%AA%E5%8F%8D%E7%9B%B4%E8%A7%89%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98">下一篇：几个反直觉的概率问题</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几个反直觉的概率问题</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%87%A0%E4%B8%AA%E5%8F%8D%E7%9B%B4%E8%A7%89%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%87%A0%E4%B8%AA%E5%8F%8D%E7%9B%B4%E8%A7%89%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="几个反直觉的概率问题"><a href="#几个反直觉的概率问题" class="headerlink" title="几个反直觉的概率问题"></a>几个反直觉的概率问题</h1><p>上篇文章 <a href="./%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95">洗牌算法详解</a> 讲到了验证概率算法的蒙特卡罗方法，今天聊点轻松的内容：几个和概率相关的有趣问题。<br>计算概率有下面两个最简单的原则：<br>原则一、计算概率一定要有一个参照系，称作「样本空间」，即随机事件可能出现的所有结果。事件 A 发生的概率 = A 包含的样本点 / 样本空间的样本总数。<br>原则二、计算概率一定要明白，概率是一个连续的整体，不可以把连续的概率分割开，也就是所谓的条件概率。<br>上述两个原则高中就学过，但是我们还是很容易犯错，而且犯错的流程也有异曲同工之妙：<br>先是忽略了原则二，错误地计算了样本空间，然后通过原则一算出了错误的答案。<br>下面介绍几个简单却具有迷惑性的问题，分别是男孩女孩问题、生日悖论、三门问题。当然，三门问题可能是大家最耳熟的，所以就多说一些有趣的思考。</p><h3 id="一、男孩女孩问题"><a href="#一、男孩女孩问题" class="headerlink" title="一、男孩女孩问题"></a>一、男孩女孩问题</h3><p>假设有一个家庭，有两个孩子，现在告诉你其中有一个男孩，请问另一个也是男孩的概率是多少？<br>很多人，包括我在内，不假思索地回答：1/2 啊，因为另一个孩子要么是男孩，要么是女孩，而且概率相等呀。但是实际上，答案是 1/3。<br>上述思想为什么错误呢？因为没有正确计算样本空间，导致原则一计算错误。有两个孩子，那么样本空间为 4，即哥哥妹妹，哥哥弟弟，姐姐妹妹，姐姐弟弟这四种情况。已知有一个男孩，那么排除姐姐妹妹这种情况，所以样本空间变成 3。另一个孩子也是男孩只有哥哥弟弟这 1 种情况，所以概率为 1/3。<br>为什么计算样本空间会出错呢？因为我们忽略了条件概率，即混淆了下面两个问题：<br>这个家庭只有一个孩子，这个孩子是男孩的概率是多少？<br>这个家庭有两个孩子，其中一个是男孩，另一个孩子是男孩的概率是多少？<br>根据原则二，概率问题是连续的，不可以把上述两个问题混淆。第二个问题需要用条件概率，即求一个孩子是男孩的条件下，另一个也是男孩的概率。运用条件概率的公式也很好算，就不多说了。<br>通过这个问题，读者应该理解两个概率计算原则的关系了，最具有迷惑性的就是条件概率的忽视。为了不要被迷惑，最简单的办法就是把所有可能结果穷举出来。<br>最后，对于此问题我见过一个很奇葩的质疑：如果这两个孩子是双胞胎，不存在年龄上的差异怎么办？<br>我竟然觉得有那么一丝道理！但其实，我们只是通过年龄差异来表示两个孩子的独立性，也就是说即便两个孩子同性，也有两种可能。所以不要用双胞胎抬杠了。</p><h3 id="二、生日悖论"><a href="#二、生日悖论" class="headerlink" title="二、生日悖论"></a>二、生日悖论</h3><p>生日悖论是由这样一个问题引出的：一个屋子里需要有多少人，才能使得存在至少两个人生日是同一天的概率达到 50%？<br>答案是 23 个人，也就是说房子里如果有 23 个人，那么就有 50% 的概率会存在两个人生日相同。这个结论看起来不可思议，所以被称为悖论。按照直觉，要得到 50% 的概率，起码得有 183 个人吧，因为一年有 365 天呀？其实不是的，觉得这个结论不可思议主要有两个思维误区：<br><strong>第一个误区是误解「存在」这个词的含义。</strong><br>读者可能认为，如果 23 个人中出现相同生日的概率就能达到 50%，是不是意味着：<br>假设现在屋子里坐着 22 个人，然后我走进去，那么有 50% 的概率我可以找到一个人和我生日相同。但这怎么可能呢？<br>并不是的，你这种想法是以自我为中心，而题目的概率是在描述整体。也就是说「存在」的含义是指 23 人中的任意两个人，涉及排列组合，大概率和你没啥关系。<br>如果你非要计算存在和自己生日相同的人的概率是多少，可以这样计算：<br>1 - P(22 个人都和我的生日不同) = 1 -(364/365)^22 = 0.06<br>这样计算得到的结果是不是看起来合理多了？生日悖论计算对象的不是某一个人，而是一个整体，其中包含了所有人的排列组合，它们的概率之和当然会大得多。<br><strong>第二个误区是认为概率是线性变化的。</strong><br>读者可能认为，如果 23 个人中出现相同生日的概率就能达到 50%，是不是意味着 46 个人的概率就能达到 100%？<br>不是的，就像中奖率 50% 的游戏，你玩两次的中奖率就是 100% 吗？显然不是，你玩两次的中奖率是 75%：<br>$P(两次能中奖) = P(第一次就中了) + P(第一次没中但第二次中了) = 1/2 + 1/2*1/2 = 75%$<br>那么换到生日悖论也是一个道理，概率不是简单叠加，而要考虑一个连续的过程，所以这个结论并没有什么不合常理之处。<br>那为什么只要 23 个人出现相同生日的概率就能大于 50% 了呢？我们先计算 23 个人生日都唯一（不重复）的概率。只有 1 个人的时候，生日唯一的概率是 $365/365$，2 个人时，生日唯一的概率是 $365/365 × 364/365$，以此类推可知 23 人的生日都唯一的概率：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/p.png"><br>算出来大约是 0.493，所以存在相同生日的概率就是 0.507，差不多就是 50% 了。实际上，按照这个算法，当人数达到 70 时，存在两个人生日相同的概率就上升到了 99.9%，基本可以认为是 100% 了。所以从概率上说，一个几十人的小团体中存在生日相同的人真没啥稀奇的。</p><h3 id="三、三门问题"><a href="#三、三门问题" class="headerlink" title="三、三门问题"></a>三、三门问题</h3><p>这个游戏很经典了：游戏参与者面对三扇门，其中两扇门后面是山羊，一扇门后面是跑车。参与者只要随便选一扇门，门后面的东西就归他（跑车的价值当然更大）。但是主持人决定帮一下参与者：在他选择之后，先不急着打开这扇门，而是由主持人打开剩下两扇门中的一扇，展示其中的山羊（主持人知道每扇门后面是什么），然后给参与者一次换门的机会，此时参与者应该换门还是不换门呢？<br>为了防止第一次看到这个问题的读者迷惑，再具体描述一下这个问题：<br>你是游戏参与者，现在有门 1,2,3，假设你随机选择了门 1，然后主持人打开了门 3 告诉你那后面是山羊。现在，你是坚持你最初的选择门 1，还是选择换成门 2 呢？<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/sanmen.png"><br>答案是应该换门，换门之后抽到跑车的概率是 2/3，不换的话是 1/3。又一次反直觉，感觉换不换的中奖概率应该都一样啊，因为最后肯定就剩两个门，一个是羊，一个是跑车，这是事实，所以不管选哪个的概率不都是 1/2 吗？<br>类似前面说的男孩女孩问题，最简单稳妥的方法就是把所有可能结果穷举出来：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/tree.png" alt="穷举树"><br>很容易看到选择换门中奖的概率是 2/3，不换的话是 1/3。<br>关于这个问题还有更简单的方法：主持人开门实际上在「浓缩」概率。一开始你选择到跑车的概率当然是 1/3，剩下两个门中包含跑车的概率当然是 2/3，这没啥可说的。但是主持人帮你排除了一个含有山羊的门，相当于把那 2/3 的概率浓缩到了剩下的这一扇门上。那么，你说你是抱着原来那扇 1/3 的门，还是换成那扇经过「浓缩」的 2/3 概率的门呢？<br>再直观一点，假设你三选一，剩下 2 扇门，再给你加入 98 扇装山羊的门，把这 100 扇门随机打乱，问你换不换？肯定不换对吧，这明摆着把概率稀释了，肯定抱着原来的那扇门是最可能中跑车的。再假设，初始有 100 扇门，你选了一扇，然后主持人在剩下 99 扇门中帮你排除 98 个山羊，问你换不换一扇门？肯定换对吧，你手上那扇门是 1%，另一扇门是 99%，或者也可以这样理解，不换只是选择了 1 扇门，换门相当于选择了 99 扇门，这样结果很明显了吧？<br>以上思想，也许有的读者都思考过，下面我们思考这样一个问题：假设你在决定是否换门的时候，小明破门而入，要求帮你做出选择。他完全不知道之前发生的事，他只知道面前有两扇门，一扇是跑车一扇是山羊，那么他抽中跑车的概率是多大？<br>当然是 1/2，这也是很多人做错三门问题的根本原因。类似生日悖论，人们总是容易以自我为中心，通过这个小明的视角来计算是否换门，这显然会进入误区。<br>就好比有两个箱子，一号箱子有 4 个黑球 2 个红球，二号箱子有 2 个黑球 4 个红球，随便选一个箱子，随便摸一个球，问你摸出红球的概率。<br>对于不知情的小明，他会随机选择一个箱子，随机摸球，摸到红球的概率是：1/2 × 2/6 + 1/2 × 4/6 = 1/2<br>对于知情的你，你知道在二号箱子摸球概率大，所以只在二号箱摸，摸到红球的概率是：0 × 2/6 + 1 × 4/6 = 2/3<br>三门问题是有指导意义的。比如你蒙选择题，先蒙了 A，后来灵机一动排除了 B 和 C，请问你是否要把 A 换成 D？答案是，换！<br>也许读者会问，如果只排除了一个答案，比如说 B，那么我是否应该把 A 换成 C 或者 D 呢？答案是，换！<br>因为按照刚才「浓缩」概率这个思想，只要进行了排除，都是在进行「浓缩」，均摊下来肯定比你一开始蒙的那个答案概率 1/4 高。比如刚才的例子，C 和 D 的正确概率都是 3/8，而你开始蒙的 A 只有 1/4。<br>当然，运用此策略蒙题的前提是你真的抓瞎，真的随机乱选答案，这样概率才能作为最后的杀手锏。</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98">上一篇：信封嵌套问题</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95">下一篇：洗牌算法</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和技巧</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%89%8D%E7%BC%80%E5%92%8C%E6%8A%80%E5%B7%A7/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%89%8D%E7%BC%80%E5%92%8C%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和技巧"><a href="#前缀和技巧" class="headerlink" title="前缀和技巧"></a>前缀和技巧</h1><p>今天来聊一道简单却十分巧妙的算法问题：算出一共有几个和为 k 的子数组。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%89%8D%E7%BC%80%E5%92%8C/title.png"><br>那我把所有子数组都穷举出来，算它们的和，看看谁的和等于 k 不就行了。<br>关键是，<strong>如何快速得到某个子数组的和呢</strong>，比如说给你一个数组 <code>nums</code>，让你实现一个接口 <code>sum(i, j)</code>，这个接口要返回 <code>nums[i..j]</code> 的和，而且会被多次调用，你怎么实现这个接口呢？<br>因为接口要被多次调用，显然不能每次都去遍历 <code>nums[i..j]</code>，有没有一种快速的方法在 O(1) 时间内算出 <code>nums[i..j]</code> 呢？这就需要<strong>前缀和</strong>技巧了。</p><h3 id="一、什么是前缀和"><a href="#一、什么是前缀和" class="headerlink" title="一、什么是前缀和"></a>一、什么是前缀和</h3><p>前缀和的思路是这样的，对于一个给定的数组 <code>nums</code>，我们额外开辟一个前缀和数组进行预处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = nums.length;<br><span class="hljs-comment">// 前缀和数组</span><br><span class="hljs-keyword">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>preSum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    preSum[i + <span class="hljs-number">1</span>] = preSum[i] + nums[i];<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%89%8D%E7%BC%80%E5%92%8C/1.jpg"><br>这个前缀和数组 <code>preSum</code> 的含义也很好理解，<code>preSum[i]</code> 就是 <code>nums[0..i-1]</code> 的和。那么如果我们想求 <code>nums[i..j]</code> 的和，只需要一步操作 <code>preSum[j+1]-preSum[i]</code> 即可，而不需要重新去遍历数组了。<br>回到这个子数组问题，我们想求有多少个子数组的和为 k，借助前缀和技巧很容易写出一个解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">// 构造前缀和</span><br>    <span class="hljs-keyword">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    sum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        sum[i + <span class="hljs-number">1</span>] = sum[i] + nums[i];<br>    <br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 穷举所有子数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>            <span class="hljs-comment">// sum of nums[j..i-1]</span><br>            <span class="hljs-keyword">if</span> (sum[i] - sum[j] == k)<br>                ans++;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个解法的时间复杂度 $O(N^2)$ 空间复杂度 $O(N)$，并不是最优的解法。不过通过这个解法理解了前缀和数组的工作原理之后，可以使用一些巧妙的办法把时间复杂度进一步降低。</p><h3 id="二、优化解法"><a href="#二、优化解法" class="headerlink" title="二、优化解法"></a>二、优化解法</h3><p>前面的解法有嵌套的 for 循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>        <span class="hljs-keyword">if</span> (sum[i] - sum[j] == k)<br>            ans++;<br></code></pre></td></tr></table></figure><p>第二层 for 循环在干嘛呢？翻译一下就是，<strong>在计算，有几个 <code>j</code> 能够使得 <code>sum[i]</code> 和 <code>sum[j]</code> 的差为 k。</strong>毎找到一个这样的 <code>j</code>，就把结果加一。<br>我们可以把 if 语句里的条件判断移项，这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (sum[j] == sum[i] - k)<br>    ans++;<br></code></pre></td></tr></table></figure><p>优化的思路是：<strong>我直接记录下有几个 <code>sum[j]</code> 和 <code>sum[i] - k</code> 相等，直接更新结果，就避免了内层的 for 循环</strong>。我们可以用哈希表，在记录前缀和的同时记录该前缀和出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">// map：前缀和 -&gt; 该前缀和出现的次数</span><br>    HashMap&lt;Integer, Integer&gt; <br>        preSum = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">// base case</span><br>    preSum.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, sum0_i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        sum0_i += nums[i];<br>        <span class="hljs-comment">// 这是我们想找的前缀和 nums[0..j]</span><br>        <span class="hljs-keyword">int</span> sum0_j = sum0_i - k;<br>        <span class="hljs-comment">// 如果前面有这个前缀和，则直接更新答案</span><br>        <span class="hljs-keyword">if</span> (preSum.containsKey(sum0_j))<br>            ans += preSum.get(sum0_j);<br>        <span class="hljs-comment">// 把前缀和 nums[0..i] 加入并记录出现次数</span><br>        preSum.put(sum0_i, <br>            preSum.getOrDefault(sum0_i, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如说下面这个情况，需要前缀和 8 就能找到和为 k 的子数组了，之前的暴力解法需要遍历数组去数有几个 8，而优化解法借助哈希表可以直接得知有几个前缀和为 8。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%89%8D%E7%BC%80%E5%92%8C/2.jpg"><br>这样，就把时间复杂度降到了 $O(N)$，是最优解法了。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>前缀和不难，却很有用，主要用于处理数组区间的问题。<br>比如说，让你统计班上同学考试成绩在不同分数段的百分比，也可以利用前缀和技巧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] scores; <span class="hljs-comment">// 存储着所有同学的分数</span><br><span class="hljs-comment">// 试卷满分 150 分</span><br><span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">150</span> + <span class="hljs-number">1</span>]<br><span class="hljs-comment">// 记录每个分数有几个同学</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> score : scores)<br>    count[score]++<br><span class="hljs-comment">// 构造前缀和</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; count.length; i++)<br>    count[i] = count[i] + count[i-<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>这样，给你任何一个分数段，你都能通过前缀和相减快速计算出这个分数段的人数，百分比也就很容易计算了。<br>但是，稍微复杂一些的算法问题，不止考察简单的前缀和技巧。比如本文探讨的这道题目，就需要借助前缀和的思路做进一步的优化，借助哈希表去除不必要的嵌套循环。可见对题目的理解和细节的分析能力对于算法的优化是至关重要的。<br>希望本文对你有帮助。</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E7%83%A7%E9%A5%BC%E6%8E%92%E5%BA%8F">上一篇：烧饼排序</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95">下一篇：字符串乘法</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间交集问题</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8C%BA%E9%97%B4%E4%BA%A4%E9%9B%86%E9%97%AE%E9%A2%98/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8C%BA%E9%97%B4%E4%BA%A4%E9%9B%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="区间交集问题"><a href="#区间交集问题" class="headerlink" title="区间交集问题"></a>区间交集问题</h1><p>本文是区间系列问题的第三篇，前两篇分别讲了区间的最大不相交子集和重叠区间的合并，今天再写一个算法，可以快速找出两组区间的交集。<br>先看下题目，LeetCode 第 986 题就是这个问题：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/intersection/title.png" alt="title"><br>题目很好理解，就是让你找交集，注意区间都是闭区间。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>解决区间问题的思路一般是先排序，以便操作，不过题目说已经排好序了，那么可以用两个索引指针在 <code>A</code> 和 <code>B</code> 中游走，把交集找出来，代码大概是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># A, B 形如 [[0,2],[5,10]...]</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intervalIntersection</span>(<span class="hljs-params">A, B</span>):</span><br>    i, j = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    res = []<br>    <span class="hljs-keyword">while</span> i &lt; len(A) <span class="hljs-keyword">and</span> j &lt; len(B):<br>        <span class="hljs-comment"># ...</span><br>        j += <span class="hljs-number">1</span><br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>不难，我们先老老实实分析一下各种情况。<br>首先，<strong>对于两个区间</strong>，我们用 <code>[a1,a2]</code> 和 <code>[b1,b2]</code> 表示在 <code>A</code> 和 <code>B</code> 中的两个区间，那么什么情况下这两个区间<strong>没有交集</strong>呢：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/intersection/1.jpg"><br>只有这两种情况，写成代码的条件判断就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> b2 &lt; a1 <span class="hljs-keyword">or</span> a2 &lt; b1:<br>    [a1,a2] 和 [b1,b2] 无交集<br></code></pre></td></tr></table></figure><p>那么，什么情况下，两个区间存在交集呢？根据命题的否定，上面逻辑的否命题就是存在交集的条件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不等号取反，or 也要变成 and</span><br><span class="hljs-keyword">if</span> b2 &gt;= a1 <span class="hljs-keyword">and</span> a2 &gt;= b1:<br>    [a1,a2] 和 [b1,b2] 存在交集<br></code></pre></td></tr></table></figure><p>接下来，两个区间存在交集的情况有哪些呢？穷举出来：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/intersection/2.jpg"><br>这很简单吧，就这四种情况而已。那么接下来思考，这几种情况下，交集是否有什么共同点呢？<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/intersection/3.jpg"><br>我们惊奇地发现，交集区间是有规律的！如果交集区间是 <code>[c1,c2]</code>，那么 <code>c1=max(a1,b1)</code>，<code>c2=min(a2,b2)</code>！这一点就是寻找交集的核心，我们把代码更进一步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> i &lt; len(A) <span class="hljs-keyword">and</span> j &lt; len(B):<br>    a1, a2 = A[i][<span class="hljs-number">0</span>], A[i][<span class="hljs-number">1</span>]<br>    b1, b2 = B[j][<span class="hljs-number">0</span>], B[j][<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> b2 &gt;= a1 <span class="hljs-keyword">and</span> a2 &gt;= b1:<br>        res.append([max(a1, b1), min(a2, b2)])<br>    <span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><p>最后一步，我们的指针 <code>i</code> 和 <code>j</code> 肯定要前进（递增）的，什么时候应该前进呢？<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/intersection/4.gif"><br>结合动画示例就很好理解了，是否前进，只取决于 <code>a2</code> 和 <code>b2</code> 的大小关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> i &lt; len(A) <span class="hljs-keyword">and</span> j &lt; len(B):<br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-keyword">if</span> b2 &lt; a2:<br>        j += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        i += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># A, B 形如 [[0,2],[5,10]...]</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intervalIntersection</span>(<span class="hljs-params">A, B</span>):</span><br>    i, j = <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <span class="hljs-comment"># 双指针</span><br>    res = []<br>    <span class="hljs-keyword">while</span> i &lt; len(A) <span class="hljs-keyword">and</span> j &lt; len(B):<br>        a1, a2 = A[i][<span class="hljs-number">0</span>], A[i][<span class="hljs-number">1</span>]<br>        b1, b2 = B[j][<span class="hljs-number">0</span>], B[j][<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 两个区间存在交集</span><br>        <span class="hljs-keyword">if</span> b2 &gt;= a1 <span class="hljs-keyword">and</span> a2 &gt;= b1:<br>            <span class="hljs-comment"># 计算出交集，加入 res</span><br>            res.append([max(a1, b1), min(a2, b2)])<br>        <span class="hljs-comment"># 指针前进</span><br>        <span class="hljs-keyword">if</span> b2 &lt; a2: j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:       i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>总结一下，区间类问题看起来都比较复杂，情况很多难以处理，但实际上通过观察各种不同情况之间的共性可以发现规律，用简洁的代码就能处理。<br>另外，区间问题没啥特别厉害的奇技淫巧，其操作也朴实无华，但其应用却十分广泛，接之前的几篇文章：</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98%E4%B9%8B%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6">上一篇：区间调度之区间合并问题</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98">下一篇：信封嵌套问题</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间调度问题之区间合并</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98%E4%B9%8B%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98%E4%B9%8B%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="区间调度问题之区间合并"><a href="#区间调度问题之区间合并" class="headerlink" title="区间调度问题之区间合并"></a>区间调度问题之区间合并</h1><p>上篇文章用贪心算法解决了区间调度问题：给你很多区间，让你求其中的最大不重叠子集。<br>其实对于区间相关的问题，还有很多其他类型，本文就来讲讲区间合并问题（Merge Interval）。<br>LeetCode 第 56 题就是一道相关问题，题目很好理解：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/mergeInterval/title.png" alt="title"><br>我们解决区间问题的一般思路是先排序，然后观察规律。</p><h3 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h3><p>一个区间可以表示为 <code>[start, end]</code>，前文聊的区间调度问题，需要按 <code>end</code> 排序，以便满足贪心选择性质。而对于区间合并问题，其实按 <code>end</code> 和 <code>start</code> 排序都可以，不过为了清晰起见，我们选择按 <code>start</code> 排序。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/mergeInterval/1.jpg" alt="1"><br><strong>显然，对于几个相交区间合并后的结果区间 <code>x</code>，<code>x.start</code> 一定是这些相交区间中 <code>start</code> 最小的，<code>x.end</code> 一定是这些相交区间中 <code>end</code> 最大的。</strong><br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/mergeInterval/2.jpg" alt="2"><br>由于已经排了序，<code>x.start</code> 很好确定，求 <code>x.end</code> 也很容易，可以类比在数组中找最大值的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> max_ele = arr[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) <br>    max_ele = max(max_ele, arr[i]);<br><span class="hljs-keyword">return</span> max_ele;<br></code></pre></td></tr></table></figure><h3 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># intervals 形如 [[1,3],[2,6]...]</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">intervals</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> intervals: <span class="hljs-keyword">return</span> []<br>    <span class="hljs-comment"># 按区间的 start 升序排列</span><br>    intervals.sort(key=<span class="hljs-keyword">lambda</span> intv: intv[<span class="hljs-number">0</span>])<br>    res = []<br>    res.append(intervals[<span class="hljs-number">0</span>])<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(intervals)):<br>        curr = intervals[i]<br>        <span class="hljs-comment"># res 中最后一个元素的引用</span><br>        last = res[<span class="hljs-number">-1</span>]<br>        <span class="hljs-keyword">if</span> curr[<span class="hljs-number">0</span>] &lt;= last[<span class="hljs-number">1</span>]:<br>            <span class="hljs-comment"># 找到最大的 end</span><br>            last[<span class="hljs-number">1</span>] = max(last[<span class="hljs-number">1</span>], curr[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 处理下一个待合并区间</span><br>            res.append(curr)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>看下动画就一目了然了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/mergeInterval/3.gif" alt="3"><br>至此，区间合并问题就解决了。本文篇幅短小，因为区间合并只是区间问题的一个类型，后续还有一些区间问题。本想把所有问题类型都总结在一篇文章，但有读者反应，长文只会收藏不会看… 所以还是分成小短文吧，读者有什么看法可以在留言板留言交流。<br>本文终，希望对你有帮助。</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/FloodFill%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8">上一篇：FloodFill算法详解及应用</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8C%BA%E9%97%B4%E4%BA%A4%E9%9B%86%E9%97%AE%E9%A2%98">下一篇：区间调度之区间交集问题</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针技巧</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针技巧总结"><a href="#双指针技巧总结" class="headerlink" title="双指针技巧总结"></a>双指针技巧总结</h1><p>我把双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。</p><h3 id="一、快慢指针的常见算法"><a href="#一、快慢指针的常见算法" class="headerlink" title="一、快慢指针的常见算法"></a>一、快慢指针的常见算法</h3><p>快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。<br><strong>1、判定链表中是否含有环</strong><br>这应该属于链表最基本的操作了，如果读者已经知道这个技巧，可以跳过。<br>单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。<br>如果链表中不含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)<br>        head = head.next;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。<br>经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode fast, slow;<br>    fast = slow = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>        <br>        <span class="hljs-keyword">if</span> (fast == slow) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、已知链表中含有环，返回这个环的起始位置</strong><br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8F%8C%E6%8C%87%E9%92%88/1.png" alt="1"><br>这个问题一点都不困难，有点类似脑筋急转弯，先直接看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode fast, slow;<br>    fast = slow = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>        <span class="hljs-keyword">if</span> (fast == slow) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 上面的代码类似 hasCycle 函数</span><br>    slow = head;<br>    <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>        fast = fast.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？<br>第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8F%8C%E6%8C%87%E9%92%88/2.png" alt="2"><br>设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。<br>巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8F%8C%E6%8C%87%E9%92%88/3.png" alt="3"><br>所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了。<br><strong>3、寻找链表的中点</strong><br>类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>    fast = fast.next.next;<br>    slow = slow.next;<br>&#125;<br><span class="hljs-comment">// slow 就在中间位置</span><br><span class="hljs-keyword">return</span> slow;<br></code></pre></td></tr></table></figure><p>当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8F%8C%E6%8C%87%E9%92%88/center.png" alt="center"><br>寻找链表中点的一个重要作用是对链表进行归并排序。<br>回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。<br>但是现在你学会了找到链表的中点，就能实现链表的二分了。关于归并排序的具体内容本文就不具体展开了。</p><p><strong>4、寻找链表的倒数第 k 个元素</strong><br>我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode slow, fast;<br>slow = fast = head;<br><span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">0</span>) <br>    fast = fast.next;<br><span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span>) &#123;<br>    slow = slow.next;<br>    fast = fast.next;<br>&#125;<br><span class="hljs-keyword">return</span> slow;<br></code></pre></td></tr></table></figure><h3 id="二、左右指针的常用算法"><a href="#二、左右指针的常用算法" class="headerlink" title="二、左右指针的常用算法"></a>二、左右指针的常用算法</h3><p>左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。<br><strong>1、二分查找</strong><br>前文「二分查找」有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = (right + left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、两数之和</strong><br>直接看一道 LeetCode 题目吧：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8F%8C%E6%8C%87%E9%92%88/title.png" alt="title"><br>只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 可以调整 sum 的大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> sum = nums[left] + nums[right];<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            <span class="hljs-comment">// 题目要求的索引是从 1 开始的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>            left++; <span class="hljs-comment">// 让 sum 大一点</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>            right--; <span class="hljs-comment">// 让 sum 小一点</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3、反转数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// swap(nums[left], nums[right])</span><br>        <span class="hljs-keyword">int</span> temp = nums[left];<br>        nums[left] = nums[right];<br>        nums[right] = temp;<br>        left++; right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4、滑动窗口算法</strong><br>这也许是双指针技巧的最高境界了，如果掌握了此算法，可以解决一大类子字符串匹配的问题，不过「滑动窗口」稍微比上述的这些算法复杂些。<br>幸运的是，这类算法是有框架模板的，而且<a href="%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7">这篇文章</a>就讲解了「滑动窗口」算法模板，帮大家秒杀几道 LeetCode 子串匹配的问题。</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7">上一篇：滑动窗口解题框架</a><br><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B">下一篇：Linux的进程、线程、文件描述符是什么</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法详解修订版</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法详解"><a href="#回溯算法详解" class="headerlink" title="回溯算法详解"></a>回溯算法详解</h1><p>这篇文章是很久之前的一篇《回溯算法详解》的进阶版，之前那篇不够清楚，就不必看了，看这篇就行。把框架给你讲清楚，你会发现回溯算法问题都是一个套路。<br>废话不多说，直接上回溯算法框架。<strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。你只需要思考 3 个问题：<br>1、路径：也就是已经做出的选择。<br>2、选择列表：也就是你当前可以做的选择。<br>3、结束条件：也就是到达决策树底层，无法再做选择的条件。<br>如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。<br>代码方面，回溯算法的框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">result = []<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">路径, 选择列表</span>):</span><br>    <span class="hljs-keyword">if</span> 满足结束条件:<br>        result.add(路径)<br>        <span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br></code></pre></td></tr></table></figure><p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong>，特别简单。<br>什么叫做选择和撤销选择呢，这个框架的底层原理是什么呢？下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！</p><h3 id="一、全排列问题"><a href="#一、全排列问题" class="headerlink" title="一、全排列问题"></a>一、全排列问题</h3><p>我们在高中的时候就做过排列组合的数学题，我们也知道 <code>n</code> 个不重复的数，全排列共有 n! 个。<br>PS：<strong>为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字</strong>。<br>那么我们当时是怎么穷举全排列的呢？比方说给三个数 <code>[1,2,3]</code>，你肯定不会无规律地乱穷举，一般是这样：<br>先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……<br>其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/backtracking/1.jpg"><br>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。<strong>我们不妨把这棵树称为回溯算法的「决策树」</strong>。<br><strong>为啥说这是决策树呢，因为你在每个节点上其实都在做决策</strong>。比如说你站在下图的红色节点上：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/backtracking/2.jpg"><br>你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。<br><strong>现在可以解答开头的几个名词：<code>[2]</code> 就是「路径」，记录你已经做过的选择；<code>[1,3]</code> 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候</strong>。<br>如果明白了这几个名词，<strong>可以把「路径」和「选择」列表作为决策树上每个节点的属性</strong>，比如下图列出了几个节点的属性：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/backtracking/3.jpg"><br><strong>我们定义的 <code>backtrack</code> 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列</strong>。<br>再进一步，如何遍历一棵树？这个应该不难吧。回忆一下之前「学习数据结构的框架思维」写过，各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (TreeNode child : root.childern)<br>        <span class="hljs-comment">// 前序遍历需要的操作</span><br>        traverse(child);<br>        <span class="hljs-comment">// 后序遍历需要的操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，我给你画张图你就明白了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/backtracking/4.jpg"><br><strong>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行</strong>。<br>回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/backtracking/5.jpg"><br>现在，你是否理解了回溯算法的这段核心框架？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>    <span class="hljs-comment"># 做选择</span><br>    将该选择从选择列表移除<br>    路径.add(选择)<br>    backtrack(路径, 选择列表)<br>    <span class="hljs-comment"># 撤销选择</span><br>    路径.remove(选择)<br>    将该选择再加入选择列表<br></code></pre></td></tr></table></figure><p><strong>我们只要在递归之前做出选择，在递归之后撤销刚才的选择</strong>，就能正确得到每个节点的选择列表和路径。<br>下面，直接看全排列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span><br>List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-comment">// 记录「路径」</span><br>    LinkedList&lt;Integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    backtrack(nums, track);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">// 路径：记录在 track 中</span><br><span class="hljs-comment">// 选择列表：nums 中不存在于 track 的那些元素</span><br><span class="hljs-comment">// 结束条件：nums 中的元素全都在 track 中出现</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;<br>    <span class="hljs-comment">// 触发结束条件</span><br>    <span class="hljs-keyword">if</span> (track.size() == nums.length) &#123;<br>        res.add(<span class="hljs-keyword">new</span> LinkedList(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 排除不合法的选择</span><br>        <span class="hljs-keyword">if</span> (track.contains(nums[i]))<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 做选择</span><br>        track.add(nums[i]);<br>        <span class="hljs-comment">// 进入下一层决策树</span><br>        backtrack(nums, track);<br>        <span class="hljs-comment">// 取消选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 <code>nums</code> 和 <code>track</code> 推导出当前的选择列表：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/backtracking/6.jpg"><br>至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 <code>contains</code> 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。<br>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。<strong>这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高</strong>。<br>明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。</p><h3 id="二、N-皇后问题"><a href="#二、N-皇后问题" class="headerlink" title="二、N 皇后问题"></a>二、N 皇后问题</h3><p>这个问题很经典了，简单解释一下：给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。<br>PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。<br>这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。<br>直接套用框架:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; res;<br><span class="hljs-comment">/* 输入棋盘边长 n，返回所有合法的放置 */</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">solveNQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// &#x27;.&#x27; 表示空，&#x27;Q&#x27; 表示皇后，初始化空棋盘。</span><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">board</span><span class="hljs-params">(n, <span class="hljs-built_in">string</span>(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>    backtrack(board, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span><br><span class="hljs-comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span><br><span class="hljs-comment">// 结束条件：row 超过 board 的最后一行</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; board, <span class="hljs-keyword">int</span> row)</span> </span>&#123;<br>    <span class="hljs-comment">// 触发结束条件</span><br>    <span class="hljs-keyword">if</span> (row == board.size()) &#123;<br>        res.push_back(board);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> n = board[row].size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>        <span class="hljs-comment">// 排除不合法选择</span><br>        <span class="hljs-keyword">if</span> (!isValid(board, row, col)) <br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 做选择</span><br>        board[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>        <span class="hljs-comment">// 进入下一行决策</span><br>        backtrack(board, row + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 撤销选择</span><br>        board[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分主要代码，其实跟全排列问题差不多，<code>isValid</code> 函数的实现也很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 是否可以在 board[row][col] 放置皇后？ */</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = board.size();<br>    <span class="hljs-comment">// 检查列是否有皇后互相冲突</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (board[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 检查右上方是否有皇后互相冲突</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; <br>            i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;<br>        <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 检查左上方是否有皇后互相冲突</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>;<br>            i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>        <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数 <code>backtrack</code> 依然像个在决策树上游走的指针，通过 <code>row</code> 和 <code>col</code> 就可以表示函数遍历到的位置，通过 <code>isValid</code> 函数可以将不符合条件的情况剪枝：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/backtracking/7.jpg"><br>如果直接给你这么一大段解法代码，可能是懵逼的。但是现在明白了回溯算法的框架套路，还有啥难理解的呢？无非是改改做选择的方式，排除不合法选择的方式而已，只要框架存于心，你面对的只剩下小问题了。<br>当 <code>N = 8</code> 时，就是八皇后问题，数学大佬高斯穷尽一生都没有数清楚八皇后问题到底有几种可能的放置方法，但是我们的算法只需要一秒就可以算出来所有可能的结果。<br>不过真的不怪高斯。这个问题的复杂度确实非常高，看看我们的决策树，虽然有 <code>isValid</code> 函数剪枝，但是最坏时间复杂度仍然是 O(N^(N+1))，而且无法优化。如果 <code>N = 10</code> 的时候，计算就已经很耗时了。<br><strong>有的时候，我们并不想得到所有合法的答案，只想要一个答案，怎么办呢</strong>？比如解数独的算法，找所有解法复杂度太高，只要找到一种解法就可以。<br>其实特别简单，只要稍微修改一下回溯算法的代码即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 函数找到一个答案后就返回 true</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; board, <span class="hljs-keyword">int</span> row)</span> </span>&#123;<br>    <span class="hljs-comment">// 触发结束条件</span><br>    <span class="hljs-keyword">if</span> (row == board.size()) &#123;<br>        res.push_back(board);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>        ...<br>        board[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (backtrack(board, row + <span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        board[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样修改后，只要找到一个答案，for 循环的后续递归穷举都会被阻断。也许你可以在 N 皇后问题的代码框架上，稍加修改，写一个解数独的算法？</p><h3 id="三、最后总结"><a href="#三、最后总结" class="headerlink" title="三、最后总结"></a>三、最后总结</h3><p>回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">...</span>):</span><br>    <span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>        做选择<br>        backtrack(...)<br>        撤销选择<br></code></pre></td></tr></table></figure><p><strong>写 <code>backtrack</code> 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集</strong>。<br>其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？<br>某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。</p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84">上一篇：动态规划答疑篇</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3">下一篇：二分查找解题框架</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串乘法</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串乘法"><a href="#字符串乘法" class="headerlink" title="字符串乘法"></a>字符串乘法</h1><p>对于比较小的数字，做运算可以直接使用编程语言提供的运算符，但是如果相乘的两个因数非常大，语言提供的数据类型可能就会溢出。一种替代方案就是，运算数以字符串的形式输入，然后模仿我们小学学习的乘法算术过程计算出结果，并且也用字符串表示。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/title.png"><br>需要注意的是，<code>num1</code> 和 <code>num2</code> 可以非常长，所以不可以把他们直接转成整型然后运算，唯一的思路就是模仿我们手算乘法。<br>比如说我们手算 <code>123 × 45</code>，应该会这样计算：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/1.jpg"><br>计算 <code>123 × 5</code>，再计算 <code>123 × 4</code>，最后错一位相加。这个流程恐怕小学生都可以熟练完成，但是你是否能<strong>把这个运算过程进一步机械化</strong>，写成一套算法指令让没有任何智商的计算机来执行呢？<br>你看这个简单过程，其中涉及乘法进位，涉及错位相加，还涉及加法进位；而且还有一些不易察觉的问题，比如说两位数乘以两位数，结果可能是四位数，也可能是三位数，你怎么想出一个标准化的处理方式？这就是算法的魅力，如果没有计算机思维，简单的问题可能都没办法自动化处理。<br>首先，我们这种手算方式还是太「高级」了，我们要再「低级」一点，<code>123 × 5</code> 和 <code>123 × 4</code> 的过程还可以进一步分解，最后再相加：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/2.jpg"><br>现在 <code>123</code> 并不大，如果是个很大的数字的话，是无法直接计算乘积的。我们可以用一个数组在底下接收相加结果：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/3.jpg"><br>整个计算过程大概是这样，<strong>有两个指针 <code>i，j</code> 在 <code>num1</code> 和 <code>num2</code> 上游走，计算乘积，同时将乘积叠加到 <code>res</code> 的正确位置</strong>：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/4.gif"><br>现在还有一个关键问题，如何将乘积叠加到 <code>res</code> 的正确位置，或者说，如何通过 <code>i，j</code> 计算 <code>res</code> 的对应索引呢？<br>其实，细心观察之后就发现，**<code>num1[i]</code> 和 <code>num2[j]</code> 的乘积对应的就是 <code>res[i+j]</code> 和 <code>res[i+j+1]</code> 这两个位置**。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/6.jpg"><br>明白了这一点，就可以用代码模仿出这个计算过程了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">string <span class="hljs-title">multiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = num1.size(), n = num2.size();<br>    <span class="hljs-comment">// 结果最多为 m + n 位数</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(m + n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-comment">// 从个位数开始逐位相乘</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-keyword">int</span> mul = (num1[i]-<span class="hljs-string">&#x27;0&#x27;</span>) * (num2[j]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-comment">// 乘积在 res 对应的索引位置</span><br>            <span class="hljs-keyword">int</span> p1 = i + j, p2 = i + j + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 叠加到 res 上</span><br>            <span class="hljs-keyword">int</span> sum = mul + res[p2];<br>            res[p2] = sum % <span class="hljs-number">10</span>;<br>            res[p1] += sum / <span class="hljs-number">10</span>;<br>        &#125;<br>    <span class="hljs-comment">// 结果前缀可能存的 0（未使用的位）</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; res.size() &amp;&amp; res[i] == <span class="hljs-number">0</span>)<br>        i++;<br>    <span class="hljs-comment">// 将计算结果转化成字符串</span><br>    string str;<br>    <span class="hljs-keyword">for</span> (; i &lt; res.size(); i++)<br>        str.push_back(<span class="hljs-string">&#x27;0&#x27;</span> + res[i]);<br>    <br>    <span class="hljs-keyword">return</span> str.size() == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;0&quot;</span> : str;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，字符串乘法算法就完成了。<br><strong>总结一下</strong>，我们习以为常的一些思维方式，在计算机看来是非常难以做到的。比如说我们习惯的算术流程并不复杂，但是如果让你再进一步，翻译成代码逻辑，并不简单。算法需要将计算流程再简化，通过边算边叠加的方式来得到结果。<br>俗话教育我们，不要陷入思维定式，不要程序化，要发散思维，要创新。但我觉得程序化并不是坏事，可以大幅提高效率，减小失误率。算法不就是一套程序化的思维吗，只有程序化才能让计算机帮助我们解决复杂问题呀！<br>也许算法就是一种<strong>寻找思维定式的思维</strong>吧，希望本文对你有帮助。</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%89%8D%E7%BC%80%E5%92%8C%E6%8A%80%E5%B7%A7">上一篇：前缀和技巧</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/FloodFill%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8">下一篇：FloodFill算法详解及应用</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习数据结构和算法的高效方法</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E6%95%88%E6%96%B9%E6%B3%95/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E6%95%88%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="学习数据结构和算法的框架思维"><a href="#学习数据结构和算法的框架思维" class="headerlink" title="学习数据结构和算法的框架思维"></a>学习数据结构和算法的框架思维</h1><p>这是好久之前的一篇文章「学习数据结构和算法的框架思维」的修订版。之前那篇文章收到广泛好评，没看过也没关系，这篇文章会涵盖之前的所有内容，并且会举很多代码的实例，教你如何使用框架思维。<br>首先，这里讲的都是普通的数据结构，咱不是搞算法竞赛的，野路子出生，我只会解决常规的问题。另外，以下是我个人的经验的总结，没有哪本算法书会写这些东西，所以请读者试着理解我的角度，别纠结于细节问题，因为这篇文章就是希望对数据结构和算法建立一个框架性的认识。<br>从整体到细节，自顶向下，从抽象到具体的框架思维是通用的，不只是学习数据结构和算法，学习其他任何知识都是高效的。</p><h3 id="一、数据结构的存储方式"><a href="#一、数据结构的存储方式" class="headerlink" title="一、数据结构的存储方式"></a>一、数据结构的存储方式</h3><p><strong>数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）</strong>。<br>这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？<br>我们分析问题，一定要有递归的思想，自顶向下，从抽象到具体。你上来就列出这么多，那些都属于「上层建筑」，而数组和链表才是「结构基础」。因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API 不同而已。<br>比如说「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。<br>「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。<br>「散列表」就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。<br>「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。<br>了解 Redis 数据库的朋友可能也知道，Redis 提供列表、字符串、集合等等几种常用数据结构，但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。<br>综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，<strong>二者的优缺点如下</strong>：<br><strong>数组</strong>由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。<br><strong>链表</strong>因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。</p><h3 id="二、数据结构的基本操作"><a href="#二、数据结构的基本操作" class="headerlink" title="二、数据结构的基本操作"></a>二、数据结构的基本操作</h3><p>对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改。<br><strong>数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改</strong>。话说这不就是数据结构的使命么？<br>如何遍历 + 访问？我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式：线性的和非线性的。<br>线性就是 for/while 迭代为代表，非线性就是递归为代表。再具体一步，无非以下几种框架：<br>数组遍历框架，典型的线性迭代结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-comment">// 迭代访问 arr[i]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>链表遍历框架，兼具迭代和递归结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 基本的单链表节点 */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (ListNode p = head; p != <span class="hljs-keyword">null</span>; p = p.next) &#123;<br>        <span class="hljs-comment">// 迭代访问 p.val</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归访问 head.val</span><br>    traverse(head.next)<br>&#125;<br></code></pre></td></tr></table></figure><p>二叉树遍历框架，典型的非线性递归遍历结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 基本的二叉树节点 */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode left, right;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    traverse(root.left)<br>    traverse(root.right)<br>&#125;<br></code></pre></td></tr></table></figure><p>你看二叉树的递归遍历方式和链表的递归遍历方式，相似不？再看看二叉树结构和单链表结构，相似不？如果再多几条叉，N 叉树你会不会遍历？<br>二叉树框架可以扩展为 N 叉树的遍历框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 基本的 N 叉树节点 */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode[] children;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (TreeNode child : root.children)<br>        traverse(child)<br>&#125;<br></code></pre></td></tr></table></figure><p>N 叉树的遍历又可以扩展为图的遍历，因为图就是好几 N 叉棵树的结合体。你说图是可能出现环的？这个很好办，用个布尔数组 visited 做标记就行了，这里就不写代码了。<br><strong>所谓框架，就是套路。不管增删查改，这些代码都是永远无法脱离的结构，你可以把这个结构作为大纲，根据具体问题在框架上添加代码就行了，下面会具体举例</strong>。</p><h3 id="三、算法刷题指南"><a href="#三、算法刷题指南" class="headerlink" title="三、算法刷题指南"></a>三、算法刷题指南</h3><p>首先要明确的是，<strong>数据结构是工具，算法是通过合适的工具解决特定问题的方法</strong>。也就是说，学习算法之前，最起码得了解那些常用的数据结构，了解它们的特性和缺陷。<br>那么该如何在 LeetCode 刷题呢？之前的文章<a href="%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF">算法学习之路</a>写过一些，什么按标签刷，坚持下去云云。现在距那篇文章已经过去将近一年了，我不说那些不痛不痒的话，直接说具体的建议：<br><strong>先刷二叉树，先刷二叉树，先刷二叉树</strong>！<br>这是我这刷题一年的亲身体会，下图是去年十月份的提交截图：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/others/leetcode.jpeg"><br>公众号文章的阅读数据显示，大部分人对数据结构相关的算法文章不感兴趣，而是更关心动规回溯分治等等技巧。为什么要先刷二叉树呢，<strong>因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题</strong>。<br>刷二叉树看到题目没思路？根据很多读者的问题，其实大家不是没思路，只是没有理解我们说的「框架」是什么。<strong>不要小看这几行破代码，几乎所有二叉树的题目都是一套这个框架就出来了</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">// 前序遍历</span><br>    traverse(root.left)<br>    <span class="hljs-comment">// 中序遍历</span><br>    traverse(root.right)<br>    <span class="hljs-comment">// 后序遍历</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如说我随便拿几道题的解法出来，不用管具体的代码逻辑，只要看看框架在其中是如何发挥作用的就行。<br>LeetCode 124 题，难度 Hard，让你求二叉树中最大路径和，主要代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ans = INT_MIN;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">oneSideMax</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> left = max(<span class="hljs-number">0</span>, oneSideMax(root-&gt;left));<br>    <span class="hljs-keyword">int</span> right = max(<span class="hljs-number">0</span>, oneSideMax(root-&gt;right));<br>    ans = max(ans, left + right + root-&gt;val);<br>    <span class="hljs-keyword">return</span> max(left, right) + root-&gt;val;<br>&#125;<br></code></pre></td></tr></table></figure><p>你看，这就是个后序遍历嘛。<br>LeetCode 105 题，难度 Medium，让你根据前序遍历和中序遍历的结果还原一棵二叉树，很经典的问题吧，主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> preStart, <span class="hljs-keyword">int</span> preEnd, </span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span> inStart, <span class="hljs-keyword">int</span> inEnd, Map&lt;Integer, Integer&gt; inMap)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(preStart &gt; preEnd || inStart &gt; inEnd) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[preStart]);<br>    <span class="hljs-keyword">int</span> inRoot = inMap.get(root.val);<br>    <span class="hljs-keyword">int</span> numsLeft = inRoot - inStart;<br>    root.left = buildTree(preorder, preStart + <span class="hljs-number">1</span>, preStart + numsLeft, <br>                          inorder, inStart, inRoot - <span class="hljs-number">1</span>, inMap);<br>    root.right = buildTree(preorder, preStart + numsLeft + <span class="hljs-number">1</span>, preEnd, <br>                          inorder, inRoot + <span class="hljs-number">1</span>, inEnd, inMap);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>不要看这个函数的参数很多，只是为了控制数组索引而已，本质上该算法也就是一个前序遍历。<br>LeetCode 99 题，难度 Hard，恢复一棵 BST，主要代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br>    traverse(node-&gt;left);<br>    <span class="hljs-keyword">if</span> (node-&gt;val &lt; prev-&gt;val) &#123;<br>        s = (s == <span class="hljs-literal">NULL</span>) ? prev : s;<br>        t = node;<br>    &#125;<br>    prev = node;<br>    traverse(node-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><p>这不就是个中序遍历嘛，对于一棵 BST 中序遍历意味着什么，应该不需要解释了吧。<br>你看，Hard 难度的题目不过如此，而且还这么有规律可循，只要把框架写出来，然后往相应的位置加东西就行了，这不就是思路吗。<br>对于一个理解二叉树的人来说，刷一道二叉树的题目花不了多长时间。那么如果你对刷题无从下手或者有畏惧心理，不妨从二叉树下手，前 10 道也许有点难受；结合框架再做 20 道，也许你就有点自己的理解了；刷完整个专题，再去做什么回溯动规分治专题，<strong>你就会发现只要涉及递归的问题，都是树的问题</strong>。<br>再举例吧，说几道我们之前文章写过的问题。<br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6">动态规划详解</a>说过凑零钱问题，暴力解法就是遍历一棵 N 叉树：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/5.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coinChange</span>(<span class="hljs-params">coins: List[int], amount: int</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">n</span>):</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        res = float(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>        <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:<br>            subproblem = dp(n - coin)<br>            <span class="hljs-comment"># 子问题无解，跳过</span><br>            <span class="hljs-keyword">if</span> subproblem == <span class="hljs-number">-1</span>: <span class="hljs-keyword">continue</span><br>            res = min(res, <span class="hljs-number">1</span> + subproblem)<br>        <span class="hljs-keyword">return</span> res <span class="hljs-keyword">if</span> res != float(<span class="hljs-string">&#x27;INF&#x27;</span>) <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span><br>    <br>    <span class="hljs-keyword">return</span> dp(amount)<br></code></pre></td></tr></table></figure><p>这么多代码看不懂咋办？直接提取出框架，就能看出核心思路了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不过是一个 N 叉树的遍历问题而已</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:<br>        dp(n - coin)<br></code></pre></td></tr></table></figure><p>其实很多动态规划问题就是在遍历一棵树，你如果对树的遍历操作烂熟于心，起码知道怎么把思路转化成代码，也知道如何提取别人解法的核心思路。<br>再看看回溯算法，前文<a href="%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88">回溯算法详解</a>干脆直接说了，回溯算法就是个 N 叉树的前后序遍历问题，没有例外。<br>比如 N 皇后问题吧，主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (track.size() == nums.length) &#123;<br>        res.add(<span class="hljs-keyword">new</span> LinkedList(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (track.contains(nums[i]))<br>            <span class="hljs-keyword">continue</span>;<br>        track.add(nums[i]);<br>        <span class="hljs-comment">// 进入下一层决策树</span><br>        backtrack(nums, track);<br>        track.removeLast();<br>    &#125;<br><span class="hljs-comment">/* 提取出 N 叉树遍历框架 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        backtrack(nums, track);<br>&#125;<br></code></pre></td></tr></table></figure><p>N 叉树的遍历框架，找出来了把～你说，树这种结构重不重要？<br><strong>综上，对于畏惧算法的朋友来说，可以先刷树的相关题目，试着从框架上看问题，而不要纠结于细节问题</strong>。<br>纠结细节问题，就比如纠结 i 到底应该加到 n 还是加到 n - 1，这个数组的大小到底应该开 n 还是 n + 1 ？<br>从框架上看问题，就是像我们这样基于框架进行抽取和扩展，既可以在看别人解法时快速理解核心逻辑，也有助于找到我们自己写解法时的思路方向。<br>当然，如果细节出错，你得不到正确的答案，但是只要有框架，你再错也错不到哪去，因为你的方向是对的。<br>但是，你要是心中没有框架，那么你根本无法解题，给了你答案，你也不会发现这就是个树的遍历问题。<br>这种思维是很重要的，<a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6">动态规划详解</a>中总结的找状态转移方程的几步流程，有时候按照流程写出解法，说实话我自己都不知道为啥是对的，反正它就是对了。。。<br><strong>这就是框架的力量，能够保证你在快睡着的时候，依然能写出正确的程序；就算你啥都不会，都能比别人高一个级别。</strong></p><h3 id="四、总结几句"><a href="#四、总结几句" class="headerlink" title="四、总结几句"></a>四、总结几句</h3><p>数据结构的基本存储方式就是链式和顺序两种，基本操作就是增删查改，遍历方式无非迭代和递归。<br>刷算法题建议从「树」分类开始刷，结合框架思维，把这几十道题刷完，对于树结构的理解应该就到位了。这时候去看回溯、动规、分治等算法专题，对思路的理解可能会更加深刻一些。</p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">上一篇：最长公共子序列</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%954">下一篇：学习数据结构和算法读什么书</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的位操作</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="常用的位操作"><a href="#常用的位操作" class="headerlink" title="常用的位操作"></a>常用的位操作</h1><p>本文分两部分，第一部分列举几个有趣的位操作，第二部分讲解算法中常用的 n &amp; (n - 1) 操作，顺便把用到这个技巧的算法题列出来讲解一下。因为位操作很简单，所以假设读者已经了解与、或、异或这三种基本操作。<br>位操作（Bit Manipulation）可以玩出很多奇技淫巧，但是这些技巧大部分都过于晦涩，没必要深究，读者只要记住一些有用的操作即可。</p><h3 id="一、几个有趣的位操作"><a href="#一、几个有趣的位操作" class="headerlink" title="一、几个有趣的位操作"></a>一、几个有趣的位操作</h3><ol><li>利用或操作 <code>|</code> 和空格将英文字符转换为小写<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">(<span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27; &#x27;</span>) = <span class="hljs-string">&#x27;a&#x27;</span><br>(<span class="hljs-string">&#x27;A&#x27;</span> | <span class="hljs-string">&#x27; &#x27;</span>) = <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure></li><li>利用与操作 <code>&amp;</code> 和下划线将英文字符转换为大写<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">(<span class="hljs-string">&#x27;b&#x27;</span> &amp; <span class="hljs-string">&#x27;_&#x27;</span>) = <span class="hljs-string">&#x27;B&#x27;</span><br>(<span class="hljs-string">&#x27;B&#x27;</span> &amp; <span class="hljs-string">&#x27;_&#x27;</span>) = <span class="hljs-string">&#x27;B&#x27;</span><br></code></pre></td></tr></table></figure></li><li>利用异或操作 <code>^</code> 和空格进行英文字符大小写互换<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">(<span class="hljs-string">&#x27;d&#x27;</span> ^ <span class="hljs-string">&#x27; &#x27;</span>) = <span class="hljs-string">&#x27;D&#x27;</span><br>(<span class="hljs-string">&#x27;D&#x27;</span> ^ <span class="hljs-string">&#x27; &#x27;</span>) = <span class="hljs-string">&#x27;d&#x27;</span><br></code></pre></td></tr></table></figure>PS：以上操作能够产生奇特效果的原因在于 ASCII 编码。字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果，有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了。</li><li>判断两个数是否异号<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> x = <span class="hljs-number">-1</span>, y = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">bool</span> f = ((x ^ y) &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br><span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>, y = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">bool</span> f = ((x ^ y) &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>PS：这个技巧还是很实用的，利用的是补码编码的符号位。如果不用位运算来判断是否异号，需要使用 if else 分支，还挺麻烦的。读者可能想利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出现错误。（关于补码编码和溢出，参见前文）</li><li>交换两个数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>a ^= b;<br>b ^= a;<br>a ^= b;<br><span class="hljs-comment">// 现在 a = 2, b = 1</span><br></code></pre></td></tr></table></figure></li><li>加一<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>;<br>n = -~n;<br><span class="hljs-comment">// 现在 n = 2</span><br></code></pre></td></tr></table></figure></li><li>减一<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> n = <span class="hljs-number">2</span>;<br>n = ~-n;<br><span class="hljs-comment">// 现在 n = 1</span><br></code></pre></td></tr></table></figure>PS：上面这三个操作就纯属装逼用的，没啥实际用处，大家了解了解乐呵一下就行。<h3 id="二、算法常用操作-n-amp-n-1"><a href="#二、算法常用操作-n-amp-n-1" class="headerlink" title="二、算法常用操作 n&amp;(n-1)"></a>二、算法常用操作 n&amp;(n-1)</h3>这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个 1。<br>看个图就很容易理解了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E4%BD%8D%E6%93%8D%E4%BD%9C/1.png" alt="n"></li><li>计算汉明权重（Hamming Weight）<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E4%BD%8D%E6%93%8D%E4%BD%9C/title.png" alt="title"><br>就是让你返回 n 的二进制表示中有几个 1。因为 n &amp; (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>        n = n &amp; (n - <span class="hljs-number">1</span>);<br>        res++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>判断一个数是不是 2 的指数<br>一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2</span>^<span class="hljs-number">0</span> = <span class="hljs-number">1</span> = <span class="hljs-number">0b0001</span><br><span class="hljs-number">2</span>^<span class="hljs-number">1</span> = <span class="hljs-number">2</span> = <span class="hljs-number">0b0010</span><br><span class="hljs-number">2</span>^<span class="hljs-number">2</span> = <span class="hljs-number">4</span> = <span class="hljs-number">0b0100</span><br></code></pre></td></tr></table></figure>如果使用位运算技巧就很简单了（注意运算符优先级，括号不可以省略）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>以上便是一些有趣/常用的位操作。其实位操作的技巧很多，有一个叫做 Bit Twiddling Hacks 的外国网站收集了几乎所有位操作的黑科技玩法，感兴趣的读者可以点击「阅读原文」按钮查看。</li></ol><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/twoSum%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3">上一篇：twoSum问题的核心思想</a><br><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8">下一篇：拆解复杂问题：实现计算器</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洗牌算法</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h1><p>我知道大家会各种花式排序算法，但是如果叫你打乱一个数组，你是否能做到胸有成竹？即便你拍脑袋想出一个算法，怎么证明你的算法就是正确的呢？乱序算法不像排序算法，结果唯一可以很容易检验，因为「乱」可以有很多种，你怎么能证明你的算法是「真的乱」呢？<br>所以我们面临两个问题：</p><ol><li>什么叫做「真的乱」？</li><li>设计怎样的算法来打乱数组才能做到「真的乱」？<br>这种算法称为「随机乱置算法」或者「洗牌算法」。<br>本文分两部分，第一部分详解最常用的洗牌算法。因为该算法的细节容易出错，且存在好几种变体，虽有细微差异但都是正确的，所以本文要介绍一种简单的通用思想保证你写出正确的洗牌算法。第二部分讲解使用「蒙特卡罗方法」来检验我们的打乱结果是不是真的乱。蒙特卡罗方法的思想不难，但是实现方式也各有特点的。<h3 id="一、洗牌算法"><a href="#一、洗牌算法" class="headerlink" title="一、洗牌算法"></a>一、洗牌算法</h3>此类算法都是靠随机选取元素交换来获取随机性，直接看代码（伪码），该算法有 4 种形式，都是正确的：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 得到一个在闭区间 [min, max] 内的随机整数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">randInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span> max)</span></span>;<br><span class="hljs-comment">// 第一种写法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = arr.length();<br>    <span class="hljs-comment">/******** 区别只有这两行 ********/</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 从 i 到最后随机选一个元素</span><br>        <span class="hljs-keyword">int</span> rand = randInt(i, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">/*************************/</span><br>        swap(arr[i], arr[rand]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 第二种写法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n - <span class="hljs-number">1</span>; i++)<br>        <span class="hljs-keyword">int</span> rand = randInt(i, n - <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 第三种写法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">int</span> rand = randInt(<span class="hljs-number">0</span>, i);<br><span class="hljs-comment">// 第四种写法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span> ; i &gt; <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">int</span> rand = randInt(<span class="hljs-number">0</span>, i);<br></code></pre></td></tr></table></figure></li></ol><p><strong>分析洗牌算法正确性的准则：产生的结果必须有 n! 种可能，否则就是错误的。</strong>这个很好解释，因为一个长度为 n 的数组的全排列就有 n! 种，也就是说打乱结果总共有 n! 种。算法必须能够反映这个事实，才是正确的。<br>我们先用这个准则分析一下<strong>第一种写法</strong>的正确性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设传入这样一个 arr</span><br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = arr.length(); <span class="hljs-comment">// 5</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> rand = randInt(i, n - <span class="hljs-number">1</span>);<br>        swap(arr[i], arr[rand]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>for 循环第一轮迭代时，<code>i = 0</code>，<code>rand</code> 的取值范围是 <code>[0, 4]</code>，有 5 个可能的取值。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/1.png" alt="第一次"><br>for 循环第二轮迭代时，<code>i = 1</code>，<code>rand</code> 的取值范围是 <code>[1, 4]</code>，有 4 个可能的取值。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/2.png" alt="第二次"><br>后面以此类推，直到最后一次迭代，<code>i = 4</code>，<code>rand</code> 的取值范围是 <code>[4, 4]</code>，只有 1 个可能的取值。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/3.png" alt="最后一次"><br>可以看到，整个过程产生的所有可能结果有 <code>n! = 5! = 5*4*3*2*1</code> 种，所以这个算法是正确的。<br>分析<strong>第二种写法</strong>，前面的迭代都是一样的，少了一次迭代而已。所以最后一次迭代时 <code>i = 3</code>，<code>rand</code> 的取值范围是 <code>[3, 4]</code>，有 2 个可能的取值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第二种写法</span><br><span class="hljs-comment">// arr = &#123;1,3,5,7,9&#125;, n = 5</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n - <span class="hljs-number">1</span>; i++)<br>        <span class="hljs-keyword">int</span> rand = randInt(i, n - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>所以整个过程产生的所有可能结果仍然有 <code>5*4*3*2 = 5! = n!</code> 种，因为乘以 1 可有可无嘛。所以这种写法也是正确的。<br>如果以上内容你都能理解，那么你就能发现<strong>第三种写法</strong>就是第一种写法，只是将数组从后往前迭代而已；<strong>第四种写法</strong>是第二种写法从后往前来。所以它们都是正确的。<br>如果读者思考过洗牌算法，可能会想出如下的算法，但是<strong>这种写法是错误的</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = arr.length();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 每次都从闭区间 [0, n-1]</span><br>        <span class="hljs-comment">// 中随机选取元素进行交换</span><br>        <span class="hljs-keyword">int</span> rand = randInt(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        swap(arr[i], arr[rand]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在你应该明白这种写法为什么会错误了。因为这种写法得到的所有可能结果有 $n^n$ 种，而不是 $n!$ 种，而且 $n^n$ 不可能是 $n!$ 的整数倍。<br>比如说 <code>arr = &#123;1,2,3&#125;</code>，正确的结果应该有 $3!= 6$ 种可能，而这种写法总共有 $3^3 = 27$ 种可能结果。因为 27 不能被 6 整除，所以一定有某些情况被「偏袒」了，也就是说某些情况出现的概率会大一些，所以这种打乱结果不算「真的乱」。<br>上面我们从直觉上简单解释了洗牌算法正确的准则，没有数学证明，我想大家也懒得证明。对于概率问题我们可以使用「蒙特卡罗方法」进行简单验证。</p><h3 id="二、蒙特卡罗方法验证正确性"><a href="#二、蒙特卡罗方法验证正确性" class="headerlink" title="二、蒙特卡罗方法验证正确性"></a>二、蒙特卡罗方法验证正确性</h3><p>洗牌算法，或者说随机乱置算法的<strong>正确性衡量标准是：对于每种可能的结果出现的概率必须相等，也就是说要足够随机。</strong><br>如果不用数学严格证明概率相等，可以用蒙特卡罗方法近似地估计出概率是否相等，结果是否足够随机。<br>记得高中有道数学题：往一个正方形里面随机打点，这个正方形里紧贴着一个圆，告诉你打点的总数和落在圆里的点的数量，让你计算圆周率。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/4.png" alt="正方形"><br>这其实就是利用了蒙特卡罗方法：当打的点足够多的时候，点的数量就可以近似代表图形的面积。通过面积公式，由正方形和圆的面积比值是可以很容易推出圆周率的。当然打的点越多，算出的圆周率越准确，充分体现了大力出奇迹的真理。<br>类似的，我们可以对同一个数组进行一百万次洗牌，统计各种结果出现的次数，把频率作为概率，可以很容易看出洗牌算法是否正确。整体思想很简单，不过实现起来也有些技巧的，下面简单分析几种实现思路。<br><strong>第一种思路</strong>，我们把数组 arr 的所有排列组合都列举出来，做成一个直方图（假设 arr = {1,2,3}）：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/5.jpg" alt="直方图"><br>每次进行洗牌算法后，就把得到的打乱结果对应的频数加一，重复进行 100 万次，如果每种结果出现的总次数差不多，那就说明每种结果出现的概率应该是相等的。写一下这个思路的伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>;<br><span class="hljs-comment">// 蒙特卡罗</span><br><span class="hljs-keyword">int</span> N = <span class="hljs-number">1000000</span>;<br>HashMap count; <span class="hljs-comment">// 作为直方图</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    shuffle(arr);<br>    <span class="hljs-comment">// 此时 arr 已被打乱</span><br>    count[arr] += <span class="hljs-number">1</span>；<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> feq : count.values()) <br>    print(feq / N + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 频率</span><br></code></pre></td></tr></table></figure><p>这种检验方案是可行的，不过可能有读者会问，arr 的全部排列有 n! 种（n 为 arr 的长度），如果 n 比较大，那岂不是空间复杂度爆炸了？<br>是的，不过作为一种验证方法，我们不需要 n 太大，一般用长度为 5 或 6 的 arr 试下就差不多了吧，因为我们只想比较概率验证一下正确性而已。<br><strong>第二种思路</strong>，可以这样想，arr 数组中全都是 0，只有一个 1。我们对 arr 进行 100 万次打乱，记录每个索引位置出现 1 的次数，如果每个索引出现的次数差不多，也可以说明每种打乱结果的概率是相等的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>;<br><span class="hljs-comment">// 蒙特卡罗方法</span><br><span class="hljs-keyword">int</span> N = <span class="hljs-number">1000000</span>;    <br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    shuffle(arr); <span class="hljs-comment">// 打乱 arr</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length; j++) <br>        <span class="hljs-keyword">if</span> (arr[j] == <span class="hljs-number">1</span>) &#123;<br>            count[j]++;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> feq : count) <br>    print(feq / N + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 频率</span><br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/6.png" alt="直方图"><br>这种思路也是可行的，而且避免了阶乘级的空间复杂度，但是多了嵌套 for 循环，时间复杂度高一点。不过由于我们的测试数据量不会有多大，这些问题都可以忽略。<br>另外，细心的读者可能发现一个问题，上述两种思路声明 arr 的位置不同，一个在 for 循环里，一个在 for 循环之外。其实效果都是一样的，因为我们的算法总要打乱 arr，所以 arr 的顺序并不重要，只要元素不变就行。</p><h3 id="三、最后总结"><a href="#三、最后总结" class="headerlink" title="三、最后总结"></a>三、最后总结</h3><p>本文第一部分介绍了洗牌算法（随机乱置算法），通过一个简单的分析技巧证明了该算法的四种正确形式，并且分析了一种常见的错误写法，相信你一定能够写出正确的洗牌算法了。<br>第二部分写了洗牌算法正确性的衡量标准，即每种随机结果出现的概率必须相等。如果我们不用严格的数学证明，可以通过蒙特卡罗方法大力出奇迹，粗略验证算法的正确性。蒙特卡罗方法也有不同的思路，不过要求不必太严格，因为我们只是寻求一个简单的验证。</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%87%A0%E4%B8%AA%E5%8F%8D%E7%9B%B4%E8%A7%89%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98">上一篇：几个反直觉的概率问题</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E9%80%92%E5%BD%92%E8%AF%A6%E8%A7%A3">下一篇：递归详解</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口技巧</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口技巧"><a href="#滑动窗口技巧" class="headerlink" title="滑动窗口技巧"></a>滑动窗口技巧</h1><p>本文详解「滑动窗口」这种高级双指针技巧的算法框架，带你秒杀几道高难度的子字符串匹配问题。<br>LeetCode 上至少有 9 道题目可以用此方法高效解决。但是有几道是 VIP 题目，有几道题目虽不难但太复杂，所以本文只选择点赞最高，较为经典的，最能够讲明白的三道题来讲解。第一题为了让读者掌握算法模板，篇幅相对长，后两题就基本秒杀了。<br>本文代码为 C++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解：<br><code>unordered_map</code> 就是哈希表（字典），它的一个方法 count(key) 相当于 containsKey(key) 可以判断键 key 是否存在。<br>可以使用方括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，C++ 会自动创建这个 key，并把 map[key] 赋值为 0。<br>所以代码中多次出现的 <code>map[key]++</code> 相当于 Java 的 <code>map.put(key, map.getOrDefault(key, 0) + 1)</code>。<br>本文大部分代码都是图片形式，可以点开放大，更重要的是可以左右滑动方便对比代码。下面进入正题。</p><h3 id="一、最小覆盖子串"><a href="#一、最小覆盖子串" class="headerlink" title="一、最小覆盖子串"></a>一、最小覆盖子串</h3><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/title1.png" alt="题目链接"><br>题目不难理解，就是说要在 S(source) 中找到包含 T(target) 中全部字母的一个子串，顺序无所谓，但这个子串一定是所有可能子串中最短的。<br>如果我们使用暴力解法，代码大概是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; s.size(); j++)<br>        <span class="hljs-keyword">if</span> s[i:j] 包含 t 的所有字母:<br>            更新答案<br></code></pre></td></tr></table></figure><p>思路很直接吧，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。<br>滑动窗口算法的思路是这样：<br>1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。<br>2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。<br>3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。<br>4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。<br>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。</strong>左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。<br>下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和窗口中的相应字符的出现次数。<br>初始状态：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/0.png" alt="0"><br>增加 right，直到窗口 [left, right] 包含了 T 中所有字符：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/1.png" alt="0"></p><p>现在开始增加 left，缩小窗口 [left, right]。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/2.png" alt="0"><br>直到窗口中的字符串不再符合要求，left 不再继续移动。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/3.png" alt="0"></p><p>之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。<br>如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。至于如何具体到问题，如何得出此题的答案，都是编程问题，等会提供一套模板，理解一下就会了。<br>上述过程可以简单地写出如下伪码框架：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s, t;<br><span class="hljs-comment">// 在 s 中寻找 t 的「最小覆盖子串」</span><br><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">string</span> res = s;<br><span class="hljs-keyword">while</span>(right &lt; s.size()) &#123;<br>    window.add(s[right]);<br>    right++;<br>    <span class="hljs-comment">// 如果符合要求，移动 left 缩小窗口</span><br>    <span class="hljs-keyword">while</span> (window 符合要求) &#123;<br>        <span class="hljs-comment">// 如果这个窗口的子串更短，则更新 res</span><br>        res = minLen(res, window);<br>        window.remove(s[left]);<br>        left++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure><p>如果上述代码你也能够理解，那么你离解题更近了一步。现在就剩下一个比较棘手的问题：如何判断 window 即子串 s[left…right] 是否符合要求，是否包含 t 的所有字符呢？<br>可以用两个哈希表当作计数器解决。用一个哈希表 needs 记录字符串 t 中包含的字符及出现次数，用另一个哈希表 window 记录当前「窗口」中包含的字符及出现的次数，如果 window 包含所有 needs 中的键，且这些键对应的值都大于等于 needs 中的值，那么就可以知道当前「窗口」符合要求了，可以开始移动 left 指针了。<br>现在将上面的框架继续细化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s, t;<br><span class="hljs-comment">// 在 s 中寻找 t 的「最小覆盖子串」</span><br><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">string</span> res = s;<br><span class="hljs-comment">// 相当于两个计数器</span><br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; window;<br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; needs;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) needs[c]++;<br><span class="hljs-comment">// 记录 window 中已经有多少字符符合要求了</span><br><span class="hljs-keyword">int</span> match = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;<br>    <span class="hljs-keyword">char</span> c1 = s[right];<br>    <span class="hljs-keyword">if</span> (needs.count(c1)) &#123;<br>        window[c1]++; <span class="hljs-comment">// 加入 window</span><br>        <span class="hljs-keyword">if</span> (window[c1] == needs[c1])<br>            <span class="hljs-comment">// 字符 c1 的出现次数符合要求了</span><br>            match++;<br>    &#125;<br>    right++;<br>    <span class="hljs-comment">// window 中的字符串已符合 needs 的要求了</span><br>    <span class="hljs-keyword">while</span> (match == needs.size()) &#123;<br>        <span class="hljs-comment">// 更新结果 res</span><br>        res = minLen(res, window);<br>        <span class="hljs-keyword">char</span> c2 = s[left];<br>        <span class="hljs-keyword">if</span> (needs.count(c2)) &#123;<br>            window[c2]--; <span class="hljs-comment">// 移出 window</span><br>            <span class="hljs-keyword">if</span> (window[c2] &lt; needs[c2])<br>                <span class="hljs-comment">// 字符 c2 出现次数不再符合要求</span><br>                match--;<br>        &#125;<br>        left++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure><p>上述代码已经具备完整的逻辑了，只有一处伪码，即更新 res 的地方，不过这个问题太好解决了，直接看解法吧！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">minWindow</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> </span>&#123;<br>    <span class="hljs-comment">// 记录最短子串的开始位置和长度</span><br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, minLen = INT_MAX;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; window;<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; needs;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) needs[c]++;<br>    <br>    <span class="hljs-keyword">int</span> match = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;<br>        <span class="hljs-keyword">char</span> c1 = s[right];<br>        <span class="hljs-keyword">if</span> (needs.count(c1)) &#123;<br>            window[c1]++;<br>            <span class="hljs-keyword">if</span> (window[c1] == needs[c1]) <br>                match++;<br>        &#125;<br>        right++;<br>        <br>        <span class="hljs-keyword">while</span> (match == needs.size()) &#123;<br>            <span class="hljs-keyword">if</span> (right - left &lt; minLen) &#123;<br>                <span class="hljs-comment">// 更新最小子串的位置和长度</span><br>                start = left;<br>                minLen = right - left;<br>            &#125;<br>            <span class="hljs-keyword">char</span> c2 = s[left];<br>            <span class="hljs-keyword">if</span> (needs.count(c2)) &#123;<br>                window[c2]--;<br>                <span class="hljs-keyword">if</span> (window[c2] &lt; needs[c2])<br>                    match--;<br>            &#125;<br>            left++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> minLen == INT_MAX ?<br>                <span class="hljs-string">&quot;&quot;</span> : s.substr(start, minLen);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果直接甩给你这么一大段代码，我想你的心态是爆炸的，但是通过之前的步步跟进，你是否能够理解这个算法的内在逻辑呢？你是否能清晰看出该算法的结构呢？<br>这个算法的时间复杂度是 O(M + N)，M 和 N 分别是字符串 S 和 T 的长度。因为我们先用 for 循环遍历了字符串 T 来初始化 needs，时间 O(N)，之后的两个 while 循环最多执行 2M 次，时间 O(M)。<br>读者也许认为嵌套的 while 循环复杂度应该是平方级，但是你这样想，while 执行的次数就是双指针 left 和 right 走的总路程，最多是 2M 嘛。</p><h3 id="二、找到字符串中所有字母异位词"><a href="#二、找到字符串中所有字母异位词" class="headerlink" title="二、找到字符串中所有字母异位词"></a>二、找到字符串中所有字母异位词</h3><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/title2.png" alt="题目链接"><br>这道题的难度是 Easy，但是评论区点赞最多的一条是这样：<br><code>How can this problem be marked as easy???</code><br>实际上，这个 Easy 是属于了解双指针技巧的人的，只要把上一道题的代码改中更新 res 部分的代码稍加修改就成了这道题的解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> </span>&#123;<br>    <span class="hljs-comment">// 用数组记录答案</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; needs;<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; window;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) needs[c]++;<br>    <span class="hljs-keyword">int</span> match = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;<br>        <span class="hljs-keyword">char</span> c1 = s[right];<br>        <span class="hljs-keyword">if</span> (needs.count(c1)) &#123;<br>            window[c1]++;<br>            <span class="hljs-keyword">if</span> (window[c1] == needs[c1])<br>                match++;<br>        &#125;<br>        right++;<br>        <span class="hljs-keyword">while</span> (match == needs.size()) &#123;<br>            <span class="hljs-comment">// 如果 window 的大小合适</span><br>            <span class="hljs-comment">// 就把起始索引 left 加入结果</span><br>            <span class="hljs-keyword">if</span> (right - left == t.size()) &#123;<br>                res.push_back(left);<br>            &#125;<br>            <span class="hljs-keyword">char</span> c2 = s[left];<br>            <span class="hljs-keyword">if</span> (needs.count(c2)) &#123;<br>                window[c2]--;<br>                <span class="hljs-keyword">if</span> (window[c2] &lt; needs[c2])<br>                    match--;<br>            &#125;<br>            left++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为这道题和上一道的场景类似，也需要 window 中包含串 t 的所有字符，但上一道题要找长度最短的子串，这道题要找长度相同的子串，也就是「字母异位词」嘛。</p><h3 id="三、无重复字符的最长子串"><a href="#三、无重复字符的最长子串" class="headerlink" title="三、无重复字符的最长子串"></a>三、无重复字符的最长子串</h3><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/title3.png" alt="题目链接"><br>遇到子串问题，首先想到的就是滑动窗口技巧。<br>类似之前的思路，使用 window 作为计数器记录窗口中的字符出现次数，然后先向右移动 right，当 window 中出现重复字符时，开始移动 left 缩小窗口，如此往复：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; window;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最长长度</span><br>    <span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;<br>        <span class="hljs-keyword">char</span> c1 = s[right];<br>        window[c1]++;<br>        right++;<br>        <span class="hljs-comment">// 如果 window 中出现重复字符</span><br>        <span class="hljs-comment">// 开始移动 left 缩小窗口</span><br>        <span class="hljs-keyword">while</span> (window[c1] &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">char</span> c2 = s[left];<br>            window[c2]--;<br>            left++;<br>        &#125;<br>        res = max(res, right - left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，因为我们要求的是最长子串，所以需要在每次移动 right 增大窗口时更新 res，而不是像之前的题目在移动 left 缩小窗口时更新 res。</p><h3 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h3><p>通过上面三道题，我们可以总结出滑动窗口算法的抽象思想：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;<br>    window.add(s[right]);<br>    right++;<br>    <br>    <span class="hljs-keyword">while</span> (valid) &#123;<br>        window.remove(s[left]);<br>        left++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 window 的数据类型可以视具体情况而定，比如上述题目都使用哈希表充当计数器，当然你也可以用一个数组实现同样效果，因为我们只处理英文字母。<br>稍微麻烦的地方就是这个 valid 条件，为了实现这个条件的实时更新，我们可能会写很多代码。比如前两道题，看起来解法篇幅那么长，实际上思想还是很简单，只是大多数代码都在处理这个问题而已。</p><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/labuladong.png" alt="公众号 labuladong"><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3">上一篇：二分查找解题框架</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7">下一篇：双指针技巧解题框架</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>烧饼排序</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E7%83%A7%E9%A5%BC%E6%8E%92%E5%BA%8F/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E7%83%A7%E9%A5%BC%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="烧饼排序"><a href="#烧饼排序" class="headerlink" title="烧饼排序"></a>烧饼排序</h1><p>烧饼排序是个很有意思的实际问题：假设盘子上有 <code>n</code> 块<strong>面积大小不一</strong>的烧饼，你如何用一把锅铲进行若干次翻转，让这些烧饼的大小有序（小的在上，大的在下）？<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/pancakeSort/1.jpg"><br>设想一下用锅铲翻转一堆烧饼的情景，其实是有一点限制的，我们每次只能将最上面的若干块饼子翻转：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/pancakeSort/2.png"><br>我们的问题是，<strong>如何使用算法得到一个翻转序列，使得烧饼堆变得有序</strong>？<br>首先，需要把这个问题抽象，用数组来表示烧饼堆：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/pancakeSort/title.png"><br>如何解决这个问题呢？其实类似上篇文章 <a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">递归反转链表的一部分</a>，这也是需要<strong>递归思想</strong>的。</p><h3 id="一、思路分析"><a href="#一、思路分析" class="headerlink" title="一、思路分析"></a>一、思路分析</h3><p>为什么说这个问题有递归性质呢？比如说我们需要实现这样一个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// cakes 是一堆烧饼，函数会将前 n 个烧饼排序</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cakes, <span class="hljs-keyword">int</span> n)</span></span>;<br></code></pre></td></tr></table></figure><p>如果我们找到了前 <code>n</code> 个烧饼中最大的那个，然后设法将这个饼子翻转到最底下：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/pancakeSort/3.jpg"><br>那么，原问题的规模就可以减小，递归调用 <code>pancakeSort(A, n-1)</code> 即可：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/pancakeSort/4.jpg"><br>接下来，对于上面的这 <code>n - 1</code> 块饼，如何排序呢？还是先从中找到最大的一块饼，然后把这块饼放到底下，再递归调用 <code>pancakeSort(A, n-1-1)</code>……<br>你看，这就是递归性质，总结一下思路就是：<br>1、找到 <code>n</code> 个饼中最大的那个。<br>2、把这个最大的饼移到最底下。<br>3、递归调用 <code>pancakeSort(A, n - 1)</code>。<br>base case：<code>n == 1</code> 时，排序 1 个饼时不需要翻转。<br>那么，最后剩下个问题，<strong>如何设法将某块烧饼翻到最后呢</strong>？<br>其实很简单，比如第 3 块饼是最大的，我们想把它换到最后，也就是换到第 <code>n</code> 块。可以这样操作：<br>1、用锅铲将前 3 块饼翻转一下，这样最大的饼就翻到了最上面。<br>2、用锅铲将前 <code>n</code> 块饼全部翻转，这样最大的饼就翻到了第 <code>n</code> 块，也就是最后一块。<br>以上两个流程理解之后，基本就可以写出解法了，不过题目要求我们写出具体的反转操作序列，这也很简单，只要在每次翻转烧饼时记录下来就行了。    </p><h3 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h3><p>只要把上述的思路用代码实现即可，唯一需要注意的是，数组索引从 0 开始，而我们要返回的结果是从 1 开始算的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 记录反转操作序列</span><br>LinkedList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-function">List&lt;Integer&gt; <span class="hljs-title">pancakeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cakes)</span> </span>&#123;<br>    sort(cakes, cakes.length);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cakes, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 寻找最大饼的索引</span><br>    <span class="hljs-keyword">int</span> maxCake = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> maxCakeIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">if</span> (cakes[i] &gt; maxCake) &#123;<br>            maxCakeIndex = i;<br>            maxCake = cakes[i];<br>        &#125;<br>    <br>    <span class="hljs-comment">// 第一次翻转，将最大饼翻到最上面</span><br>    reverse(cakes, <span class="hljs-number">0</span>, maxCakeIndex);<br>    res.add(maxCakeIndex + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 第二次翻转，将最大饼翻到最下面</span><br>    reverse(cakes, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    res.add(n);<br>    <span class="hljs-comment">// 递归调用</span><br>    sort(cakes, n - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">int</span> temp = arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>        i++; j--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过刚才的详细解释，这段代码应该是很清晰了。<br>算法的时间复杂度很容易计算，因为递归调用的次数是 <code>n</code>，每次递归调用都需要一次 for 循环，时间复杂度是 O(n)，所以总的复杂度是 O(n^2)。<br><strong>最后，我们可以思考一个问题​</strong>：按照我们这个思路，得出的操作序列长度应该为​ <code>2(n - 1)</code>，因为每次递归都要进行 2 次翻转并记录操作，总共有 <code>n</code> 层递归，但由于 base case 直接返回结果，不进行翻转，所以最终的操作序列长度应该是固定的 <code>2(n - 1)</code>。<br>显然，这个结果不是最优的（最短的），比如说一堆煎饼 <code>[3,2,4,1]</code>，我们的算法得到的翻转序列是 <code>[3,4,2,3,1,2]</code>，但是最快捷的翻转方法应该是 <code>[2,3,4]</code>：<br>初始状态 ：[3,2,4,1]<br>翻前 2 个：[2,3,4,1]<br>翻前 3 个：[4,3,2,1]<br>翻前 4 个：[1,2,3,4]<br>如果要求你的算法计算排序烧饼的<strong>最短</strong>操作序列，你该如何计算呢？或者说，解决这种求最优解法的问题，核心思路什么，一定需要使用什么算法技巧呢？<br>不妨分享一下你的思考。</p><p><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8">上一篇：拆解复杂问题：实现计算器</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%89%8D%E7%BC%80%E5%92%8C%E6%8A%80%E5%B7%A7">下一篇：前缀和技巧</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习之路</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="算法学习之路"><a href="#算法学习之路" class="headerlink" title="算法学习之路"></a>算法学习之路</h1><p>之前发的那篇关于框架性思维的文章，我也发到了不少其他圈子，受到了大家的普遍好评，这一点我真的没想到，首先感谢大家的认可，我会更加努力，写出通俗易懂的算法文章。<br>有很多朋友问我数据结构和算法到底该怎么学，尤其是很多朋友说自己是「小白」，感觉这些东西好难啊，就算看了之前的「框架思维」，也感觉自己刷题乏力，希望我能聊聊我从一个非科班小白一路是怎么学过来的。<br>首先要给怀有这样疑问的朋友鼓掌，因为你现在已经「知道自己不知道」，而且开始尝试学习、刷题、寻求帮助，能做到这一点本身就是及其困难的。<br>关于「框架性思维」，对于一个小白来说，可能暂时无法完全理解（如果你能理解，说明你水平已经不错啦，不是小白啦）。就像软件工程，对于我这种没带过项目的人来说，感觉其内容枯燥乏味，全是废话，但是对于一个带过团队的人，他就会觉得软件工程里的每一句话都是精华。暂时不太理解没关系，留个印象，功夫到了很快就明白了。<br>下面写一写我一路过来的一些经验。如果你已经看过很多「如何高效刷题」「如何学习算法」的文章，却还是没有开始行动并坚持下去，本文的第五点就是写给你的。<br>我觉得之所以有时候认为自己是「小白」，是由于知识某些方面的空白造成的。具体到数据结构的学习，无非就是两个问题搞得不太清楚：<strong>这是啥？有啥用？</strong><br>举个例子，比如说你看到了「栈」这个名词，老师可能会讲这些关键词：先进后出、函数堆栈等等。但是，对于初学者，这些描述属于文学词汇，没有实际价值，没有解决最基本的两个问题。如何回答这两个基本问题呢？回答「这是啥」需要看教科书，回答「有啥用」需要刷算法题。<br><strong>一、这是啥？</strong><br>这个问题最容易解决，就像一层窗户纸，你只要随便找本书看两天，自己动手实现一个「队列」「栈」之类的数据结构，就能捅破这层窗户纸。<br>这时候你就能理解「框架思维」文章中的前半部分了：数据结构无非就是数组、链表为骨架的一些特定操作而已；每个数据结构实现的功能无非增删查改罢了。<br>比如说「列队」这个数据结构，无非就是基于数组或者链表，实现 enqueue 和 dequeue 两个方法。这两个方法就是增和删呀，连查和改的方法都不需要。<br><strong>二、有啥用？</strong><br>解决这个问题，就涉及算法的设计了，是个持久战，需要经常进行抽象思考，刷算法题，培养「计算机思维」。<br>之前的文章讲了，算法就是对数据结构准确而巧妙的运用。常用算法问题也就那几大类，算法题无非就是不断变换场景，给那几个算法框架套上不同的皮。刷题，就是在锻炼你的眼力，看你能不能看穿问题表象揪出相应的解法框架。<br>比如说，让你求解一个迷宫，你要把这个问题层层抽象：迷宫 -&gt; 图的遍历 -&gt; N 叉树的遍历 -&gt; 二叉树的遍历。然后让框架指导你写具体的解法。<br>抽象问题，直击本质，是刷题中你需要刻意培养的能力。<br><strong>三、如何看书</strong><br>直接推荐一本公认的好书，《算法第 4 版》，我一般简写成《算法4》。不要蜻蜓点水，这本书你能选择性的看上 50%，基本上就达到平均水平了。别怕这本书厚，因为起码有三分之一不用看，下面讲讲怎么看这本书。<br>看书仍然遵循递归的思想：自顶向下，逐步求精。<br>这本书知识结构合理，讲解也清楚，所以可以按顺序学习。<strong>书中正文的算法代码一定要亲自敲一遍</strong>，因为这些真的是扎实的基础，要认真理解。不要以为自己看一遍就看懂了，不动手的话理解不了的。但是，开头部分的基础可以酌情跳过；书中的数学证明，如不影响对算法本身的理解，完全可以跳过；章节最后的练习题，也可以全部跳过。这样一来，这本书就薄了很多。<br>相信读者现在已经认可了「框架性思维」的重要性，这种看书方式也是一种框架性策略，抓大放小，着重理解整体的知识架构，而忽略证明、练习题这种细节问题，即<strong>保持自己对新知识的好奇心，避免陷入无限的细节被劝退。</strong><br>当然，《算法4》到后面的内容也比较难了，比如那几个著名的串算法，以及正则表达式算法。这些属于「经典算法」，看个人接受能力吧，单说刷 LeetCode 的话，基本用不上，量力而行即可。<br><strong>四、如何刷题</strong><br>首先声明一下，<strong>算法和数学水平没关系，和编程语言也没关系</strong>，你爱用什么语言用什么。算法，主要是培养一种新的思维方式。所谓「计算机思维」，就跟你考驾照一样，你以前骑自行车，有一套自行车的规则和技巧，现在你开汽车，就需要适应并练习开汽车的规则和技巧。<br>LeetCode 上的算法题和前面说的「经典算法」不一样，我们权且称为「解闷算法」吧，因为很多题目都比较有趣，有种在做奥数题或者脑筋急转弯的感觉。比如说，让你用队列实现一个栈，或者用栈实现一个队列，以及不用加号做加法，开脑洞吧？<br>当然，这些问题虽然看起来无厘头，实际生活中也用不到，但是想解决这些问题依然要靠数据结构以及对基础知识的理解，也许这就是很多公司面试都喜欢出这种「智力题」的原因。下面说几点技巧吧。<br><strong>尽量刷英文版的 LeetCode</strong>，中文版的“力扣”是阉割版，不仅很多题目没有答案，而且连个讨论区都没有。英文版的是真的很良心了，很多问题都有官方解答，详细易懂。而且讨论区（Discuss）也沉淀了大量优质内容，甚至好过官方解答。真正能打开你思路的，很可能是讨论区各路大神的思路荟萃。<br>PS：<strong>如果有的英文题目实在看不懂，有个小技巧</strong>，你在题目页面的 url 里加一个 -cn，即 <a href="https://leetcode.com/xxx">https://leetcode.com/xxx</a> 改成 <a href="https://leetcode-cn.com/xxx%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E8%83%BD%E5%88%87%E6%8D%A2%E5%88%B0%E7%9B%B8%E5%BA%94%E7%9A%84%E4%B8%AD%E6%96%87%E7%89%88%E9%A1%B5%E9%9D%A2%E6%9F%A5%E7%9C%8B%E3%80%82">https://leetcode-cn.com/xxx，这样就能切换到相应的中文版页面查看。</a><br>对于初学者，<strong>强烈建议从 Explore 菜单里最下面的 Learn 开始刷</strong>，这个专题就是专门教你学习数据结构和基本算法的，教学篇和相应的练习题结合，不要太良心。<br>最近 Learn 专题里新增了一些内容，我们挑数据结构相关的内容刷就行了，像 Ruby，Machine Learning 就没必要刷了。刷完 Learn 专题的基础内容，基本就有能力去 Explore 菜单的 Interview 专题刷面试题，或者去 Problem 菜单，在真正的题海里遨游了。<br>无论刷 Explore 还是 Problems 菜单，<strong>最好一个分类一个分类的刷，不要蜻蜓点水</strong>。比如说这几天就刷链表，刷完链表再去连刷几天二叉树。这样做是为了帮助你提取「框架」。一旦总结出针对一类问题的框架，解决同类问题可谓是手到擒来。<br><strong>五、道理我都懂，还是不能坚持下去</strong><br>这其实无关算法了，还是老生常谈的执行力的问题。不说什么破鸡汤了，我觉得<strong>解决办法就是「激起欲望」</strong>，注意我说的是欲望，而不是常说的兴趣，拿我自己说说吧。<br>半年前我开始刷题，目的和大部分人都一样的，就是为毕业找工作做准备。只不过，大部分人是等到临近毕业了才开始刷，而我离毕业还有一阵子。这不是炫耀我多有觉悟，而是我承认自己的极度平凡。<br>首先，我真的想找到一份不错的工作（谁都想吧？），我想要高薪呀！否则我在朋友面前，女神面前放下的骚话，最终都会反过来啪啪地打我的脸。我也是要恰饭，要面子，要虚荣心的嘛。赚钱，虚荣心，足以激起我的欲望了。<br>但是，我不擅长 deadline 突击，我理解东西真的慢，所以干脆笨鸟先飞了。智商不够，拿时间来补，我没能力两个月突击，干脆拉长战线，打他个两年游击战，我还不信耗不死算法这个强敌。事实证明，你如果认真学习一个月，就能够取得肉眼可见的进步了。<br>现在，我依然在坚持刷题，而且为了另外一个原因，这个公众号。我没想到自己的文字竟然能够帮助到他人，甚至能得到认可。这也是虚荣心啊，我不能让读者失望啊，我想让更多的人认可（夸）我呀！<br>以上，不光是坚持刷算法题吧，很多场景都适用。执行力是要靠「欲望」支撑的，我也是一凡人，只有那些看得见摸得着的东西才能使我快乐呀。读者不妨也尝试把刷题学习和自己的切身利益联系起来，这恐怕是坚持下去最简单直白的理由了。</p><p><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">上一篇：队列实现栈|栈实现队列</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88">下一篇：回溯算法详解</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法思维系列</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="算法思维系列"><a href="#算法思维系列" class="headerlink" title="算法思维系列"></a>算法思维系列</h1><ul><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF">算法学习之路</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88">回溯算法详解</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%AD%90%E9%9B%86%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88">回溯算法团灭排列、组合、子集问题</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3">二分查找详解</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7">双指针技巧总结</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7">滑动窗口技巧</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/twoSum%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3">twoSum问题的核心思想</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BD%8D%E6%93%8D%E4%BD%9C">常用的位操作</a></li><li><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8">拆解复杂问题：实现计算器</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E7%83%A7%E9%A5%BC%E6%8E%92%E5%BA%8F">烧饼排序</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%89%8D%E7%BC%80%E5%92%8C%E6%8A%80%E5%B7%A7">前缀和技巧</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95">字符串乘法</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/FloodFill%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8">FloodFill算法详解及应用</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98%E4%B9%8B%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6">区间调度之区间合并问题</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8C%BA%E9%97%B4%E4%BA%A4%E9%9B%86%E9%97%AE%E9%A2%98">区间调度之区间交集问题</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98">信封嵌套问题</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%87%A0%E4%B8%AA%E5%8F%8D%E7%9B%B4%E8%A7%89%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98">几个反直觉的概率问题</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95">洗牌算法</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E9%80%92%E5%BD%92%E8%AF%A6%E8%A7%A3">递归详解</a><br>本章包含一些常用的算法技巧，比如前缀和、回溯思想、位操作、双指针、如何正确书写二分查找等等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU算法</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/LRU%E7%AE%97%E6%B3%95/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/LRU%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="LRU算法详解"><a href="#LRU算法详解" class="headerlink" title="LRU算法详解"></a>LRU算法详解</h1><h3 id="一、什么是-LRU-算法"><a href="#一、什么是-LRU-算法" class="headerlink" title="一、什么是 LRU 算法"></a>一、什么是 LRU 算法</h3><p>就是一种缓存淘汰策略。<br>计算机的缓存容量有限，如果缓存满了就要删除一些内容，给新内容腾位置。但问题是，删除哪些内容呢？我们肯定希望删掉哪些没什么用的缓存，而把有用的数据继续留在缓存里，方便之后继续使用。那么，什么样的数据，我们判定为「有用的」的数据呢？<br>LRU 缓存淘汰算法就是一种常用策略。LRU 的全称是 Least Recently Used，也就是说我们认为最近使用过的数据应该是是「有用的」，很久都没用过的数据应该是无用的，内存满了就优先删那些很久没用过的数据。<br>举个简单的例子，安卓手机都可以把软件放到后台运行，比如我先后打开了「设置」「手机管家」「日历」，那么现在他们在后台排列的顺序是这样的：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/LRU%E7%AE%97%E6%B3%95/1.jpg" alt="jietu"><br>但是这时候如果我访问了一下「设置」界面，那么「设置」就会被提前到第一个，变成这样：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/LRU%E7%AE%97%E6%B3%95/2.jpg" alt="jietu"><br>假设我的手机只允许我同时开 3 个应用程序，现在已经满了。那么如果我新开了一个应用「时钟」，就必须关闭一个应用为「时钟」腾出一个位置，关那个呢？<br>按照 LRU 的策略，就关最底下的「手机管家」，因为那是最久未使用的，然后把新开的应用放到最上面：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/LRU%E7%AE%97%E6%B3%95/3.jpg" alt="jietu"><br>现在你应该理解 LRU（Least Recently Used）策略了。当然还有其他缓存淘汰策略，比如不要按访问的时序来淘汰，而是按访问频率（LFU 策略）来淘汰等等，各有应用场景。本文讲解 LRU 算法策略。</p><h3 id="二、LRU-算法描述"><a href="#二、LRU-算法描述" class="headerlink" title="二、LRU 算法描述"></a>二、LRU 算法描述</h3><p>LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。<br>注意哦，get 和 put 方法必须都是 $O(1)$ 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 缓存容量为 2 */</span><br>LRUCache cache = <span class="hljs-keyword">new</span> LRUCache(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 你可以把 cache 理解成一个队列</span><br><span class="hljs-comment">// 假设左边是队头，右边是队尾</span><br><span class="hljs-comment">// 最近使用的排在队头，久未使用的排在队尾</span><br><span class="hljs-comment">// 圆括号表示键值对 (key, val)</span><br>cache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">// cache = [(1, 1)]</span><br>cache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">// cache = [(2, 2), (1, 1)]</span><br>cache.get(<span class="hljs-number">1</span>);       <span class="hljs-comment">// 返回 1</span><br><span class="hljs-comment">// cache = [(1, 1), (2, 2)]</span><br><span class="hljs-comment">// 解释：因为最近访问了键 1，所以提前至队头</span><br><span class="hljs-comment">// 返回键 1 对应的值 1</span><br>cache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">// cache = [(3, 3), (1, 1)]</span><br><span class="hljs-comment">// 解释：缓存容量已满，需要删除内容空出位置</span><br><span class="hljs-comment">// 优先删除久未使用的数据，也就是队尾的数据</span><br><span class="hljs-comment">// 然后把新的数据插入队头</span><br>cache.get(<span class="hljs-number">2</span>);       <span class="hljs-comment">// 返回 -1 (未找到)</span><br><span class="hljs-comment">// cache = [(3, 3), (1, 1)]</span><br><span class="hljs-comment">// 解释：cache 中不存在键为 2 的数据</span><br>cache.put(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);    <br><span class="hljs-comment">// cache = [(1, 4), (3, 3)]</span><br><span class="hljs-comment">// 解释：键 1 已存在，把原始值 1 覆盖为 4</span><br><span class="hljs-comment">// 不要忘了也要将键值对提前到队头</span><br></code></pre></td></tr></table></figure><h3 id="三、LRU-算法设计"><a href="#三、LRU-算法设计" class="headerlink" title="三、LRU 算法设计"></a>三、LRU 算法设计</h3><p>分析上面的操作过程，要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分。<br>因为显然 cache 必须有顺序之分，以区分最近使用的和久未使用的数据；而且我们要在 cache 中查找键是否已存在；如果容量满了要删除最后一个数据；每次访问还要把数据插入到队头。<br>那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。<br>LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/LRU%E7%AE%97%E6%B3%95/4.jpg" alt="HashLinkedList"><br>思想很简单，就是借助哈希表赋予了链表快速查找的特性嘛：可以快速查找某个 key 是否存在缓存（链表）中，同时可以快速删除、添加节点。回想刚才的例子，这种数据结构是不是完美解决了 LRU 缓存的需求？<br>也许读者会问，为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了 key，为什么链表中还要存键值对呢，只存值不就行了？<br>想的时候都是问题，只有做的时候才有答案。这样设计的原因，必须等我们亲自实现 LRU 算法之后才能理解，所以我们开始看代码吧～</p><h3 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h3><p>很多编程语言都有内置的哈希链表或者类似 LRU 功能的库函数，但是为了帮大家理解算法的细节，我们用 Java 自己造轮子实现一遍 LRU 算法。<br>首先，我们把双链表的节点类写出来，为了简化，key 和 val 都认为是 int 类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> key, val;<br>    <span class="hljs-keyword">public</span> Node next, prev;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.key = k;<br>        <span class="hljs-keyword">this</span>.val = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后依靠我们的 Node 类型构建一个双链表，实现几个需要的 API（这些操作的时间复杂度均为 $O(1)$)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleList</span> </span>&#123;  <br>    <span class="hljs-comment">// 在链表头部添加节点 x，时间 O(1)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(Node x)</span></span>;<br>    <span class="hljs-comment">// 删除链表中的 x 节点（x 一定存在）</span><br>    <span class="hljs-comment">// 由于是双链表且给的是目标 Node 节点，时间 O(1)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node x)</span></span>;<br>    <br>    <span class="hljs-comment">// 删除链表中最后一个节点，并返回该节点，时间 O(1)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-comment">// 返回链表长度，时间 O(1)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>PS：这就是普通双向链表的实现，为了让读者集中精力理解 LRU 算法的逻辑，就省略链表的具体代码。<br>到这里就能回答刚才“为什么必须要用双向链表”的问题了，因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 $O(1)$。<br>有了双向链表的实现，我们只需要在 LRU 算法中把它和哈希表结合起来即可。我们先把逻辑理清楚：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// key 映射到 Node(key, val)</span><br>HashMap&lt;Integer, Node&gt; map;<br><span class="hljs-comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span><br>DoubleList cache;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (key 不存在) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;        <br>        将数据 (key, val) 提到开头；<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    Node x = <span class="hljs-keyword">new</span> Node(key, val);<br>    <span class="hljs-keyword">if</span> (key 已存在) &#123;<br>        把旧的数据删除；<br>        将新节点 x 插入到开头；<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (cache 已满) &#123;<br>            删除链表的最后一个数据腾位置；<br>            删除 map 中映射到该数据的键；<br>        &#125; <br>        将新节点 x 插入到开头；<br>        map 中新建 key 对新节点 x 的映射；<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果能够看懂上述逻辑，翻译成代码就很容易理解了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <span class="hljs-comment">// key -&gt; Node(key, val)</span><br>    <span class="hljs-keyword">private</span> HashMap&lt;Integer, Node&gt; map;<br>    <span class="hljs-comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span><br>    <span class="hljs-keyword">private</span> DoubleList cache;<br>    <span class="hljs-comment">// 最大容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cap;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cap = capacity;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        cache = <span class="hljs-keyword">new</span> DoubleList();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(key))<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> val = map.get(key).val;<br>        <span class="hljs-comment">// 利用 put 方法把该数据提前</span><br>        put(key, val);<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 先把新节点 x 做出来</span><br>        Node x = <span class="hljs-keyword">new</span> Node(key, val);<br>        <br>        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 删除旧的节点，新的插到头部</span><br>            cache.remove(map.get(key));<br>            cache.addFirst(x);<br>            <span class="hljs-comment">// 更新 map 中对应的数据</span><br>            map.put(key, x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (cap == cache.size()) &#123;<br>                <span class="hljs-comment">// 删除链表最后一个数据</span><br>                Node last = cache.removeLast();<br>                map.remove(last.key);<br>            &#125;<br>            <span class="hljs-comment">// 直接添加到头部</span><br>            cache.addFirst(x);<br>            map.put(key, x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就能回答之前的问答题“为什么要在链表中同时存储 key 和 val，而不是只存储 val”，注意这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (cap == cache.size()) &#123;<br>    <span class="hljs-comment">// 删除链表最后一个数据</span><br>    Node last = cache.removeLast();<br>    map.remove(last.key);<br>&#125;<br></code></pre></td></tr></table></figure><p>当缓存容量已满，我们不仅仅要删除最后一个 Node 节点，还要把 map 中映射到该节点的 key 同时删除，而这个 key 只能由 Node 得到。如果 Node 结构中只存储 val，那么我们就无法得知 key 是什么，就无法删除 map 中的键，造成错误。<br>至此，你应该已经掌握 LRU 算法的思想和实现了，很容易犯错的一点是：处理链表节点的同时不要忘了更新哈希表中对节点的映射。</p><p><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">上一篇：二叉堆详解实现优先级队列</a><br><a href="/2016/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%93%8D%E4%BD%9C%E9%9B%86%E9%94%A6">下一篇：二叉搜索树操作集锦</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归详解</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E9%80%92%E5%BD%92%E8%AF%A6%E8%A7%A3/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E9%80%92%E5%BD%92%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="递归详解"><a href="#递归详解" class="headerlink" title="递归详解"></a>递归详解</h1><p>首先说明一个问题，简单阐述一下递归，分治算法，动态规划，贪心算法这几个东西的区别和联系，心里有个印象就好。<br>递归是一种编程技巧，一种解决问题的思维方式；分治算法和动态规划很大程度上是递归思想基础上的（虽然动态规划的最终版本大都不是递归了，但解题思想还是离不开递归），解决更具体问题的两类算法思想；贪心算法是动态规划算法的一个子集，可以更高效解决一部分更特殊的问题。<br>分治算法将在这节讲解，以最经典的归并排序为例，它把待排序数组不断二分为规模更小的子问题处理，这就是 “分而治之” 这个词的由来。显然，排序问题分解出的子问题是不重复的，如果有的问题分解后的子问题有重复的（重叠子问题性质），那么就交给动态规划算法去解决！</p><h2 id="递归详解-1"><a href="#递归详解-1" class="headerlink" title="递归详解"></a>递归详解</h2><p>介绍分治之前，首先要弄清楚递归这个概念。<br>递归的基本思想是某个函数直接或者间接地调用自身，这样就把原问题的求解转换为许多性质相同但是规模更小的子问题。我们只需要关注如何把原问题划分成符合条件的子问题，而不需要去研究这个子问题是如何被解决的。递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题，而递归是把问题逐级分解，是纵向的拆分。<br>以下会举例说明我对递归的一点理解，<strong>如果你不想看下去了，请记住这几个问题怎么回答：</strong></p><ol><li>如何给一堆数字排序？ 答：分成两半，先排左半边再排右半边，最后合并就行了，至于怎么排左边和右边，请重新阅读这句话。</li><li>孙悟空身上有多少根毛？ 答：一根毛加剩下的毛。</li><li>你今年几岁？ 答：去年的岁数加一岁,1999 年我出生。<br>递归代码最重要的两个特征：结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(你今年几岁)</span> </span>&#123;<br>    <span class="hljs-comment">// 最简子问题，结束条件</span><br>    <span class="hljs-keyword">if</span> (你<span class="hljs-number">1999</span>年几岁) <span class="hljs-keyword">return</span> 我<span class="hljs-number">0</span>岁;<br>    <span class="hljs-comment">// 自我调用，缩小规模</span><br>    <span class="hljs-keyword">return</span> func(你去年几岁) + <span class="hljs-number">1</span>;   <br>&#125;<br></code></pre></td></tr></table></figure>其实仔细想想，<strong>递归运用最成功的是什么？我认为是数学归纳法。</strong>我们高中都学过数学归纳法，使用场景大概是：我们推不出来某个求和公式，但是我们试了几个比较小的数，似乎发现了一点规律，然后编了一个公式，看起来应该是正确答案。但是数学是很严谨的，你哪怕穷举了一万个数都是正确的，但是第一万零一个数正确吗？这就要数学归纳法发挥神威了，可以假设我们编的这个公式在第 k 个数时成立，如果证明在第 k + 1 时也成立，那么我们编的这个公式就是正确的。<br>那么数学归纳法和递归有什么联系？我们刚才说了，递归代码必须要有结束条件，如果没有的话就会进入无穷无尽的自我调用，直到内存耗尽。而数学证明的难度在于，你可以尝试有穷种情况，但是难以将你的结论延伸到无穷大。这里就可以看出联系了 —— 无穷。<br>递归代码的精髓在于调用自己去解决规模更小的子问题，直到到达结束条件；而数学归纳法之所以有用，就在于不断把我们的猜测向上加一，扩大结论的规模，没有结束条件，从而把结论延伸到无穷无尽，也就完成了猜测正确性的证明。<h3 id="为什么要写递归"><a href="#为什么要写递归" class="headerlink" title="为什么要写递归"></a>为什么要写递归</h3>首先为了训练逆向思考的能力。递推的思维是正常人的思维，总是看着眼前的问题思考对策，解决问题是将来时；递归的思维，逼迫我们倒着思考，看到问题的尽头，把解决问题的过程看做过去时。<br>第二，练习分析问题的结构，当问题可以被分解成相同结构的小问题时，你能敏锐发现这个特点，进而高效解决问题。<br>第三，跳出细节，从整体上看问题。再说说归并排序，其实可以不用递归来划分左右区域的，但是代价就是代码极其难以理解，大概看一下代码（归并排序在后面讲，这里大致看懂意思就行，体会递归的妙处）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span></span>&#123;    <br>    <span class="hljs-keyword">int</span> N = a.length;<br>    <span class="hljs-comment">// 这么复杂，是对排序的不尊重。我拒绝研究这样的代码。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sz = <span class="hljs-number">1</span>; sz &lt; N; sz = sz + sz)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>; lo &lt; N - sz; lo += sz + sz)<br>            merge(a, lo, lo + sz - <span class="hljs-number">1</span>, Math.min(lo + sz + sz - <span class="hljs-number">1</span>, N - <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-comment">/* 我还是选择递归，简单，漂亮 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (lo &gt;= hi) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;<br>    sort(a, lo, mid); <span class="hljs-comment">// 排序左半边</span><br>    sort(a, mid + <span class="hljs-number">1</span>, hi); <span class="hljs-comment">// 排序右半边</span><br>    merge(a, lo, mid, hi); <span class="hljs-comment">// 合并两边</span><br>&#125;<br></code></pre></td></tr></table></figure>看起来简洁漂亮是一方面，关键是<strong>可解释性很强</strong>：把左半边排序，把右半边排序，最后合并两边。而非递归版本看起来不知所云，充斥着各种难以理解的边界计算细节，特别容易出 bug 且难以调试，人生苦短，我更倾向于递归版本。<br>显然有时候递归处理是高效的，比如归并排序，<strong>有时候是低效的</strong>，比如数孙悟空身上的毛，因为堆栈会消耗额外空间，而简单的递推不会消耗空间。比如这个例子，给一个链表头，计算它的长度：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 典型的递推遍历框架，需要额外空间 O(1) */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node p = head; p != <span class="hljs-keyword">null</span>; p = p.next) size++;<br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><span class="hljs-comment">/* 我偏要递归，万物皆递归，需要额外空间 O(N) */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> size(head.next) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="写递归的技巧"><a href="#写递归的技巧" class="headerlink" title="写递归的技巧"></a>写递归的技巧</h3>我的一点心得是：<strong>明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节。</strong>千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。<br>先举个最简单的例子：遍历二叉树。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    traverse(root-&gt;left);<br>    traverse(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure>这几行代码就足以扫荡任何一棵二叉树了。我想说的是，对于递归函数<code>traverse(root)</code>，我们只要相信：给它一个根节点<code>root</code>，它就能遍历这棵树，因为写这个函数不就是为了这个目的吗？所以我们只需要把这个节点的左右节点再甩给这个函数就行了，因为我相信它能完成任务的。那么遍历一棵N叉数呢？太简单了好吧，和二叉树一模一样啊。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (child : root-&gt;children)<br>        traverse(child);<br>&#125;<br></code></pre></td></tr></table></figure>至于遍历的什么前、中、后序，那都是显而易见的，对于N叉树，显然没有中序遍历。</li></ol><p>以下<strong>详解 LeetCode 的一道题来说明</strong>：给一课二叉树，和一个目标值，节点上的值有正有负，返回树中和等于目标值的路径条数，让你编写 pathSum 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;* 来源于 LeetCode PathSum III： https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;path-sum-iii&#x2F; *&#x2F;<br>root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1],<br>sum &#x3D; 8<br>      10<br>     &#x2F;  \<br>    5   -3<br>   &#x2F; \    \<br>  3   2   11<br> &#x2F; \   \<br>3  -2   1<br>Return 3. The paths that sum to 8 are:<br>1.  5 -&gt; 3<br>2.  5 -&gt; 2 -&gt; 1<br>3. -3 -&gt; 11<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 看不懂没关系，底下有更详细的分析版本，这里突出体现递归的简洁优美 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> count(root, sum) + <br>        pathSum(root.left, sum) + pathSum(root.right, sum);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == null) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> (node.val == sum) + <br>        count(node.left, sum - node.val) + count(node.right, sum - node.val);<br>&#125;<br></code></pre></td></tr></table></figure><p>题目看起来很复杂吧，不过代码却极其简洁，这就是递归的魅力。我来简单总结这个问题的<strong>解决过程</strong>：<br>首先明确，递归求解树的问题必然是要遍历整棵树的，所以<strong>二叉树的遍历框架</strong>（分别对左右孩子递归调用函数本身）必然要出现在主函数 pathSum 中。那么对于每个节点，他们应该干什么呢？他们应该看看，自己和脚底下的小弟们包含多少条符合条件的路径。好了，这道题就结束了。<br>按照前面说的技巧，根据刚才的分析来定义清楚每个递归函数应该做的事：<br>PathSum 函数：给他一个节点和一个目标值，他返回以这个节点为根的树中，和为目标值的路径总数。<br>count 函数：给他一个节点和一个目标值，他返回以这个节点为根的树中，能凑出几个以该节点为路径开头，和为目标值的路径总数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 有了以上铺垫，详细注释一下代码 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> pathImLeading = count(root, sum); <span class="hljs-comment">// 自己为开头的路径数</span><br>    <span class="hljs-keyword">int</span> leftPathSum = pathSum(root.left, sum); <span class="hljs-comment">// 左边路径总数（相信他能算出来）</span><br>    <span class="hljs-keyword">int</span> rightPathSum = pathSum(root.right, sum); <span class="hljs-comment">// 右边路径总数（相信他能算出来）</span><br>    <span class="hljs-keyword">return</span> leftPathSum + rightPathSum + pathImLeading;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == null) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 我自己能不能独当一面，作为一条单独的路径呢？</span><br>    <span class="hljs-keyword">int</span> isMe = (node.val == sum) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 左边的小老弟，你那边能凑几个 sum - node.val 呀？</span><br>    <span class="hljs-keyword">int</span> leftBrother = count(node.left, sum - node.val); <br>    <span class="hljs-comment">// 右边的小老弟，你那边能凑几个 sum - node.val 呀？</span><br>    <span class="hljs-keyword">int</span> rightBrother = count(node.right, sum - node.val);<br>    <span class="hljs-keyword">return</span>  isMe + leftBrother + rightBrother; <span class="hljs-comment">// 我这能凑这么多个</span><br>&#125;<br></code></pre></td></tr></table></figure><p>还是那句话，明白每个函数能做的事，并相信他们能够完成。<br>总结下，PathSum 函数提供的二叉树遍历框架，在遍历中对每个节点调用 count 函数，看出先序遍历了吗（这道题什么序都是一样的）；count 函数也是一个二叉树遍历，用于寻找以该节点开头的目标值路径。好好体会吧！</p><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p><strong>归并排序</strong>，典型的分治算法；分治，典型的递归结构。<br>分治算法可以分三步走：分解 -&gt; 解决 -&gt; 合并</p><ol><li>分解原问题为结构相同的子问题。</li><li>分解到某个容易求解的边界之后，进行第归求解。</li><li>将子问题的解合并成原问题的解。<br>归并排序，我们就叫这个函数<code>merge_sort</code>吧，按照我们上面说的，要明确该函数的职责，即<strong>对传入的一个数组排序</strong>。OK，那么这个问题能不能分解呢？当然可以！给一个数组排序，不就等于给该数组的两半分别排序，然后合并就完事了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(一个数组)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (可以很容易处理) <span class="hljs-keyword">return</span>;<br>    merge_sort(左半个数组);<br>    merge_sort(右半个数组);<br>    merge(左半个数组, 右半个数组);<br>&#125;<br></code></pre></td></tr></table></figure>好了，这个算法也就这样了，完全没有任何难度。记住之前说的，相信函数的能力，传给他半个数组，那么这半个数组就已经被排好了。而且你会发现这不就是个二叉树遍历模板吗？为什么是后序遍历？因为我们分治算法的套路是 <strong>分解 -&gt; 解决（触底） -&gt; 合并（回溯）</strong> 啊，先左右分解，再处理合并，回溯就是在退栈，就相当于后序遍历了。至于<code>merge</code>函数，参考两个有序链表的合并，简直一模一样，下面直接贴代码吧。<br>下面参考《算法4》的 Java 代码，很漂亮。由此可见，不仅算法思想思想重要，编码技巧也是挺重要的吧！多思考，多模仿。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Merge</span> </span>&#123;<br>    <span class="hljs-comment">// 不要在 merge 函数里构造新数组了，因为 merge 函数会被多次调用，影响性能</span><br>    <span class="hljs-comment">// 直接一次性构造一个足够大的数组，简洁，高效</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Comparable[] aux;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span> </span>&#123;<br>        aux = <span class="hljs-keyword">new</span> Comparable[a.length];<br>        sort(a, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (lo &gt;= hi) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;<br>        sort(a, lo, mid);<br>        sort(a, mid + <span class="hljs-number">1</span>, hi);<br>        merge(a, lo, mid, hi);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> hi)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = lo, j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = lo; k &lt;= hi; k++)<br>            aux[k] = a[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = lo; k &lt;= hi; k++) &#123;<br>            <span class="hljs-keyword">if</span>      (i &gt; mid)              &#123; a[k] = aux[j++]; &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; hi)               &#123; a[k] = aux[i++]; &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (less(aux[j], aux[i])) &#123; a[k] = aux[j++]; &#125;<br>            <span class="hljs-keyword">else</span>                           &#123; a[k] = aux[i++]; &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">less</span><span class="hljs-params">(Comparable v, Comparable w)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> v.compareTo(w) &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>LeetCode 上有分治算法的专项练习，可复制到浏览器去做题：<br><a href="https://leetcode.com/tag/divide-and-conquer/">https://leetcode.com/tag/divide-and-conquer/</a></li></ol><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95">上一篇：洗牌算法</a><br><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/LRU%E7%AE%97%E6%B3%95">下一篇：如何实现LRU算法</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koko偷香蕉</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/koko%E5%81%B7%E9%A6%99%E8%95%89/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/koko%E5%81%B7%E9%A6%99%E8%95%89/</url>
      
        <content type="html"><![CDATA[<h1 id="如何运用二分查找算法"><a href="#如何运用二分查找算法" class="headerlink" title="如何运用二分查找算法"></a>如何运用二分查找算法</h1><p>二分查找到底有能运用在哪里？<br>最常见的就是教科书上的例子，在<strong>有序数组</strong>中搜索给定的某个目标值的索引。再推广一点，如果目标值存在重复，修改版的二分查找可以返回目标值的左侧边界索引或者右侧边界索引。<br>PS：以上提到的三种二分查找算法形式在前文「二分查找详解」有代码详解，如果没看过强烈建议看看。<br>抛开有序数组这个枯燥的数据结构，二分查找如何运用到实际的算法问题中呢？当搜索空间有序的时候，就可以通过二分搜索「剪枝」，大幅提升效率。<br>说起来玄乎得很，本文先用一个具体的「Koko 吃香蕉」的问题来举个例子。</p><h3 id="一、问题分析"><a href="#一、问题分析" class="headerlink" title="一、问题分析"></a>一、问题分析</h3><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E4%BA%8C%E5%88%86%E5%BA%94%E7%94%A8/title1.png"><br>也就是说，Koko 每小时最多吃一堆香蕉，如果吃不下的话留到下一小时再吃；如果吃完了这一堆还有胃口，也只会等到下一小时才会吃下一堆。在这个条件下，让我们确定 Koko 吃香蕉的<strong>最小速度</strong>（根/小时）。<br>如果直接给你这个情景，你能想到哪里能用到二分查找算法吗？如果没有见过类似的问题，恐怕是很难把这个问题和二分查找联系起来的。<br>那么我们先抛开二分查找技巧，想想如何暴力解决这个问题呢？<br>首先，算法要求的是「<code>H</code> 小时内吃完香蕉的最小速度」，我们不妨称为 <code>speed</code>，请问 <code>speed</code> 最大可能为多少，最少可能为多少呢？<br>显然最少为 1，最大为 <code>max(piles)</code>，因为一小时最多只能吃一堆香蕉。那么暴力解法就很简单了，只要从 1 开始穷举到 <code>max(piles)</code>，一旦发现发现某个值可以在 <code>H</code> 小时内吃完所有香蕉，这个值就是最小速度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] piles, <span class="hljs-keyword">int</span> H)</span> </span>&#123;<br><span class="hljs-comment">// piles 数组的最大值</span><br>    <span class="hljs-keyword">int</span> max = getMax(piles);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> speed = <span class="hljs-number">1</span>; speed &lt; max; speed++) &#123;<br>    <span class="hljs-comment">// 以 speed 是否能在 H 小时内吃完香蕉</span><br>        <span class="hljs-keyword">if</span> (canFinish(piles, speed, H))<br>            <span class="hljs-keyword">return</span> speed;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这个 for 循环，就是在<strong>连续的空间线性搜索，这就是二分查找可以发挥作用的标志</strong>。由于我们要求的是最小速度，所以可以用一个<strong>搜索左侧边界的二分查找</strong>来代替线性搜索，提升效率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] piles, <span class="hljs-keyword">int</span> H)</span> </span>&#123;<br>    <span class="hljs-comment">// 套用搜索左侧边界的算法框架</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = getMax(piles) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 防止溢出</span><br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (canFinish(piles, mid, H)) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>PS：如果对于这个二分查找算法的细节问题有疑问，建议看下前文「二分查找详解」搜索左侧边界的算法模板，这里不展开了。<br>剩下的辅助函数也很简单，可以一步步拆解实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 时间复杂度 O(N)</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] piles, <span class="hljs-keyword">int</span> speed, <span class="hljs-keyword">int</span> H)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> time = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : piles) &#123;<br>        time += timeOf(n, speed);<br>    &#125;<br>    <span class="hljs-keyword">return</span> time &lt;= H;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">timeOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> speed)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (n / speed) + ((n % speed &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] piles)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : piles)<br>        max = Math.max(n, max);<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，借助二分查找技巧，算法的时间复杂度为 O(NlogN)。</p><h3 id="二、扩展延伸"><a href="#二、扩展延伸" class="headerlink" title="二、扩展延伸"></a>二、扩展延伸</h3><p>类似的，再看一道运输问题：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E4%BA%8C%E5%88%86%E5%BA%94%E7%94%A8/title2.png"><br>要在 <code>D</code> 天内运输完所有货物，货物不可分割，如何确定运输的最小载重呢（下文称为 <code>cap</code>）？<br>其实本质上和 Koko 吃香蕉的问题一样的，首先确定 <code>cap</code> 的最小值和最大值分别为 <code>max(weights)</code> 和 <code>sum(weights)</code>。<br>我们要求<strong>最小载重</strong>，所以可以用搜索左侧边界的二分查找算法优化线性搜索：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 寻找左侧边界的二分查找</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shipWithinDays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] weights, <span class="hljs-keyword">int</span> D)</span> </span>&#123;<br><span class="hljs-comment">// 载重可能的最小值</span><br>    <span class="hljs-keyword">int</span> left = getMax(weights);<br><span class="hljs-comment">// 载重可能的最大值 + 1</span><br>    <span class="hljs-keyword">int</span> right = getSum(weights) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (canFinish(weights, D, mid)) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><span class="hljs-comment">// 如果载重为 cap，是否能在 D 天内运完货物？</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> D, <span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> day = <span class="hljs-number">0</span>; day &lt; D; day++) &#123;<br>        <span class="hljs-keyword">int</span> maxCap = cap;<br>        <span class="hljs-keyword">while</span> ((maxCap -= w[i]) &gt;= <span class="hljs-number">0</span>) &#123;<br>            i++;<br>            <span class="hljs-keyword">if</span> (i == w.length)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这两个例子，你是否明白了二分查找在实际问题中的应用？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    <span class="hljs-keyword">if</span> (isOK(i))<br>        <span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">上一篇：如何计算编辑距离</a><br><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%8E%A5%E9%9B%A8%E6%B0%B4">下一篇：如何高效解决接雨水问题</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k个一组反转链表</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="如何k个一组反转链表"><a href="#如何k个一组反转链表" class="headerlink" title="如何k个一组反转链表"></a>如何k个一组反转链表</h1><p>之前的文章「递归反转链表的一部分」讲了如何递归地反转一部分链表，有读者就问如何迭代地反转链表，这篇文章解决的问题也需要反转链表的函数，我们不妨就用迭代方式来解决。<br>本文要解决「K 个一组反转链表」，不难理解：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kgroup/title.png"><br>这个问题经常在面经中看到，而且 LeetCode 上难度是 Hard，它真的有那么难吗？<br>对于基本数据结构的算法问题其实都不难，只要结合特点一点点拆解分析，一般都没啥难点。下面我们就来拆解一下这个问题。</p><h3 id="一、分析问题"><a href="#一、分析问题" class="headerlink" title="一、分析问题"></a>一、分析问题</h3><p>首先，前文<a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E6%A1%86%E6%9E%B6%E6%80%9D%E7%BB%B4">学习数据结构的框架思维</a>提到过，链表是一种兼具递归和迭代性质的数据结构，认真思考一下可以发现<strong>这个问题具有递归性质</strong>。<br>什么叫递归性质？直接上图理解，比如说我们对这个链表调用 <code>reverseKGroup(head, 2)</code>，即以 2 个节点为一组反转链表：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kgroup/1.jpg"><br>如果我设法把前 2 个节点反转，那么后面的那些节点怎么处理？后面的这些节点也是一条链表，而且规模（长度）比原来这条链表小，这就叫<strong>子问题</strong>。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kgroup/2.jpg"><br>我们可以直接递归调用 <code>reverseKGroup(cur, 2)</code>，因为子问题和原问题的结构完全相同，这就是所谓的递归性质。<br>发现了递归性质，就可以得到大致的算法流程：<br><strong>1、先反转以 <code>head</code> 开头的 <code>k</code> 个元素</strong>。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kgroup/3.jpg"><br><strong>2、将第 <code>k + 1</code> 个元素作为 <code>head</code> 递归调用 <code>reverseKGroup</code> 函数</strong>。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kgroup/4.jpg"><br><strong>3、将上述两个过程的结果连接起来</strong>。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kgroup/5.jpg"><br>整体思路就是这样了，最后一点值得注意的是，递归函数都有个 base case，对于这个问题是什么呢？<br>题目说了，如果最后的元素不足 <code>k</code> 个，就保持不变。这就是 base case，待会会在代码里体现。</p><h3 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h3><p>首先，我们要实现一个 <code>reverse</code> 函数反转一个区间之内的元素。在此之前我们再简化一下，给定链表头结点，如何反转整个链表？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 反转以 a 为头结点的链表</span><br><span class="hljs-function">ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode a)</span> </span>&#123;<br>    ListNode pre, cur, nxt;<br>    pre = <span class="hljs-keyword">null</span>; cur = a; nxt = a;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br>        nxt = cur.next;<br>        <span class="hljs-comment">// 逐个结点反转</span><br>        cur.next = pre;<br>        <span class="hljs-comment">// 更新指针位置</span><br>        pre = cur;<br>        cur = nxt;<br>    &#125;<br>    <span class="hljs-comment">// 返回反转后的头结点</span><br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kgroup/8.gif"><br>这次使用迭代思路来实现的，借助动画理解应该很容易。<br>「反转以 <code>a</code> 为头结点的链表」其实就是「反转 <code>a</code> 到 null 之间的结点」，那么如果让你「反转 <code>a</code> 到 <code>b</code> 之间的结点」，你会不会？<br>只要更改函数签名，并把上面的代码中 <code>null</code> 改成 <code>b</code> 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 反转区间 [a, b) 的元素，注意是左闭右开 */</span><br><span class="hljs-function">ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode a, ListNode b)</span> </span>&#123;<br>    ListNode pre, cur, nxt;<br>    pre = <span class="hljs-keyword">null</span>; cur = a; nxt = a;<br>    <span class="hljs-comment">// while 终止的条件改一下就行了</span><br>    <span class="hljs-keyword">while</span> (cur != b) &#123;<br>        nxt = cur.next;<br>        cur.next = pre;<br>        pre = cur;<br>        cur = nxt;<br>    &#125;<br>    <span class="hljs-comment">// 返回反转后的头结点</span><br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们迭代实现了反转部分链表的功能，接下来就按照之前的逻辑编写 <code>reverseKGroup</code> 函数即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 区间 [a, b) 包含 k 个待反转元素</span><br>    ListNode a, b;<br>    a = b = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-comment">// 不足 k 个，不需要反转，base case</span><br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head;<br>        b = b.next;<br>    &#125;<br>    <span class="hljs-comment">// 反转前 k 个元素</span><br>    ListNode newHead = reverse(a, b);<br>    <span class="hljs-comment">// 递归反转后续链表并连接起来</span><br>    a.next = reverseKGroup(b, k);<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释一下 <code>for</code> 循环之后的几句代码，注意 <code>reverse</code> 函数是反转区间 <code>[a, b)</code>，所以情形是这样的：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kgroup/6.jpg"><br>递归部分就不展开了，整个函数递归完成之后就是这个结果，完全符合题意：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kgroup/7.jpg"></p><h3 id="三、最后说两句"><a href="#三、最后说两句" class="headerlink" title="三、最后说两句"></a>三、最后说两句</h3><p>从阅读量上看，基本数据结构相关的算法文章看的人都不多，我想说这是要吃亏的。<br>大家喜欢看动态规划相关的问题，可能因为面试很常见，但就我个人理解，很多算法思想都是源于数据结构的。我们公众号的成名之作之一，「学习数据结构的框架思维」就提过，什么动规、回溯、分治算法，其实都是树的遍历，树这种结构它不就是个多叉链表吗？你能处理基本数据结构的问题，解决一般的算法问题应该也不会太费事。<br>那么如何分解问题、发现递归性质呢？这个只能多练习，也许后续可以专门写一篇文章来探讨一下，本文就到此为止吧，希望对大家有帮助！</p><p><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">上一篇：如何寻找最长回文子串</a><br><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%88%A4%E5%AE%9A">下一篇：如何判定括号合法性</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找判定子序列</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找高效判定子序列"><a href="#二分查找高效判定子序列" class="headerlink" title="二分查找高效判定子序列"></a>二分查找高效判定子序列</h1><p>二分查找本身不难理解，难在巧妙地运用二分查找技巧。对于一个问题，你可能都很难想到它跟二分查找有关，比如前文 <a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">最长递增子序列</a> 就借助一个纸牌游戏衍生出二分查找解法。<br>今天再讲一道巧用二分查找的算法问题：如何判定字符串 <code>s</code> 是否是字符串 <code>t</code> 的子序列（可以假定 <code>s</code> 长度比较小，且 <code>t</code> 的长度非常大）。举两个例子：</p><p>s = “abc”, t = “<strong>a</strong>h<strong>b</strong>gd<strong>c</strong>“, return true.</p><p>s = “axc”, t = “ahbgdc”, return false.<br>题目很容易理解，而且看起来很简单，但很难想到这个问题跟二分查找有关吧？</p><h3 id="一、问题分析"><a href="#一、问题分析" class="headerlink" title="一、问题分析"></a>一、问题分析</h3><p>首先，一个很简单的解法是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; s.size() &amp;&amp; j &lt; t.size()) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == t[j]) i++;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i == s.size();<br>&#125;<br></code></pre></td></tr></table></figure><p>其思路也非常简单，利用双指针 <code>i, j</code> 分别指向 <code>s, t</code>，一边前进一边匹配子序列：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AD%90%E5%BA%8F%E5%88%97/1.gif" alt="gif"><br>读者也许会问，这不就是最优解法了吗，时间复杂度只需 O(N)，N 为 <code>t</code> 的长度。<br>是的，如果仅仅是这个问题，这个解法就够好了，<strong>不过这个问题还有 follow up</strong>：<br>如果给你一系列字符串 <code>s1,s2,...</code> 和字符串 <code>t</code>，你需要判定每个串 <code>s</code> 是否是 <code>t</code> 的子序列（可以假定 <code>s</code> 较短，<code>t</code> 很长）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span>[] isSubsequence(String[] sn, String t);<br></code></pre></td></tr></table></figure><p>你也许会问，这不是很简单吗，还是刚才的逻辑，加个 for 循环不就行了？<br>可以，但是此解法处理每个 <code>s</code> 时间复杂度仍然是 O(N)，而如果巧妙运用二分查找，可以将时间复杂度降低，大约是 O(MlogN)。由于 N 相对 M 大很多，所以后者效率会更高。</p><h3 id="二、二分思路"><a href="#二、二分思路" class="headerlink" title="二、二分思路"></a>二、二分思路</h3><p>二分思路主要是对 <code>t</code> 进行预处理，用一个字典 <code>index</code> 将每个字符出现的索引位置按顺序存储下来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> m = s.length(), n = t.length();<br>ArrayList&lt;Integer&gt;[] index = <span class="hljs-keyword">new</span> ArrayList[<span class="hljs-number">256</span>];<br><span class="hljs-comment">// 先记下 t 中每个字符出现的位置</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">char</span> c = t.charAt(i);<br>    <span class="hljs-keyword">if</span> (index[c] == <span class="hljs-keyword">null</span>) <br>        index[c] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    index[c].add(i);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AD%90%E5%BA%8F%E5%88%97/2.jpg"><br>比如对于这个情况，匹配了 “ab”，应该匹配 “c” 了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AD%90%E5%BA%8F%E5%88%97/1.jpg"><br>按照之前的解法，我们需要 <code>j</code> 线性前进扫描字符 “c”，但借助 <code>index</code> 中记录的信息，<strong>可以二分搜索 <code>index[c]</code> 中比 j 大的那个索引</strong>，在上图的例子中，就是在 <code>[0,2,6]</code> 中搜索比 4 大的那个索引：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AD%90%E5%BA%8F%E5%88%97/3.jpg"><br>这样就可以直接得到下一个 “c” 的索引。现在的问题就是，如何用二分查找计算那个恰好比 4 大的索引呢？答案是，寻找左侧边界的二分搜索就可以做到。</p><h3 id="三、再谈二分查找"><a href="#三、再谈二分查找" class="headerlink" title="三、再谈二分查找"></a>三、再谈二分查找</h3><p>在前文 <a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3">二分查找详解</a> 中，详解了如何正确写出三种二分查找算法的细节。二分查找返回目标值 <code>val</code> 的索引，对于搜索<strong>左侧边界</strong>的二分查找，有一个特殊性质：<br><strong>当 <code>val</code> 不存在时，得到的索引恰好是比 <code>val</code> 大的最小元素索引</strong>。<br>什么意思呢，就是说如果在数组 <code>[0,1,3,4]</code> 中搜索元素 2，算法会返回索引 2，也就是元素 3 的位置，元素 3 是数组中大于 2 的最小元素。所以我们可以利用二分搜索避免线性扫描。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查找左侧边界的二分查找</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(ArrayList&lt;Integer&gt; arr, <span class="hljs-keyword">int</span> tar)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>, hi = arr.size();<br>    <span class="hljs-keyword">while</span> (lo &lt; hi) &#123;<br>        <span class="hljs-keyword">int</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (tar &gt; arr.get(mid)) &#123;<br>            lo = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hi = mid;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> lo;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是搜索左侧边界的二分查找，等会儿会用到，其中的细节可以参见前文《二分查找详解》，这里不再赘述。</p><h3 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h3><p>这里以单个字符串 <code>s</code> 为例，对于多个字符串 <code>s</code>，可以把预处理部分抽出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = s.length(), n = t.length();<br>    <span class="hljs-comment">// 对 t 进行预处理</span><br>    ArrayList&lt;Integer&gt;[] index = <span class="hljs-keyword">new</span> ArrayList[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">char</span> c = t.charAt(i);<br>        <span class="hljs-keyword">if</span> (index[c] == <span class="hljs-keyword">null</span>) <br>            index[c] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        index[c].add(i);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 串 t 上的指针</span><br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 借助 index 查找 s[i]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(i);<br>        <span class="hljs-comment">// 整个 t 压根儿没有字符 c</span><br>        <span class="hljs-keyword">if</span> (index[c] == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">int</span> pos = left_bound(index[c], j);<br>        <span class="hljs-comment">// 二分搜索区间中没有找到字符 c</span><br>        <span class="hljs-keyword">if</span> (pos == index[c].size()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 向前移动指针 j</span><br>        j = index[c].get(pos) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法执行的过程是这样的：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AD%90%E5%BA%8F%E5%88%97/2.gif"><br>可见借助二分查找，算法的效率是可以大幅提升的。 </p><p><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E7%9A%84%E6%99%BA%E5%8A%9B%E9%A2%98">上一篇：一行代码就能解决的算法题</a><br><a href="/2016/01/01/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B">下一篇：Linux的进程、线程、文件描述符是什么</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一行代码解决的智力题</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E7%9A%84%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E7%9A%84%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一行代码就能解决的算法题"><a href="#一行代码就能解决的算法题" class="headerlink" title="一行代码就能解决的算法题"></a>一行代码就能解决的算法题</h1><p>下文是我在 LeetCode 刷题过程中总结的三道有趣的「脑筋急转弯」题目，可以使用算法编程解决，但只要稍加思考，就能找到规律，直接想出答案。</p><h3 id="一、Nim-游戏"><a href="#一、Nim-游戏" class="headerlink" title="一、Nim 游戏"></a>一、Nim 游戏</h3><p>游戏规则是这样的：你和你的朋友面前有一堆石子，你们轮流拿，一次至少拿一颗，最多拿三颗，谁拿走最后一颗石子谁获胜。<br>假设你们都很聪明，由你第一个开始拿，请你写一个算法，输入一个正整数 n，返回你是否能赢（true 或 false）。<br>比如现在有 4 颗石子，算法应该返回 false。因为无论你拿 1 颗 2 颗还是 3 颗，对方都能一次性拿完，拿走最后一颗石子，所以你一定会输。<br>首先，这道题肯定可以使用动态规划，因为显然原问题存在子问题，且子问题存在重复。但是因为你们都很聪明，涉及到你和对手的博弈，动态规划会比较复杂。<br><strong>我们解决这种问题的思路一般都是反着思考</strong>：<br>如果我能赢，那么最后轮到我取石子的时候必须要剩下 1<del>3 颗石子，这样我才能一把拿完。<br>如何营造这样的一个局面呢？显然，如果对手拿的时候只剩 4 颗石子，那么无论他怎么拿，总会剩下 1</del>3 颗石子，我就能赢。<br>如何逼迫对手面对 4 颗石子呢？要想办法，让我选择的时候还有 5<del>7 颗石子，这样的话我就有把握让对方不得不面对 4 颗石子。<br>如何营造 5</del>7 颗石子的局面呢？让对手面对 8 颗石子，无论他怎么拿，都会给我剩下 5~7 颗，我就能赢。<br>这样一直循环下去，我们发现只要踩到 4 的倍数，就落入了圈套，永远逃不出 4 的倍数，而且一定会输。所以这道题的解法非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canWinNim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果上来就踩到 4 的倍数，那就认输吧</span><br>    <span class="hljs-comment">// 否则，可以把对方控制在 4 的倍数，必胜</span><br>    <span class="hljs-keyword">return</span> n % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、石头游戏"><a href="#二、石头游戏" class="headerlink" title="二、石头游戏"></a>二、石头游戏</h3><p>游戏规则是这样的：你和你的朋友面前有一排石头堆，用一个数组 piles 表示，piles[i] 表示第 i 堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。<br><strong>假设你们都很聪明</strong>，由你第一个开始拿，请你写一个算法，输入一个数组 piles，返回你是否能赢（true 或 false）。<br>注意，石头的堆的数量为偶数，所以你们两人拿走的堆数一定是相同的。石头的总数为奇数，也就是你们最后不可能拥有相同多的石头，一定有胜负之分。<br>举个例子，<code>piles=[2, 1, 9, 5]</code>，你先拿，可以拿 2 或者 5，你选择 2。<br><code>piles=[1, 9, 5]</code>，轮到对手，可以拿 1 或 5，他选择 5。<br><code>piles=[1, 9]</code> 轮到你拿，你拿 9。<br>最后，你的对手只能拿 1 了。<br>这样下来，你总共拥有 <code>2 + 9 = 11</code> 颗石头，对手有 <code>5 + 1 = 6</code> 颗石头，你是可以赢的，所以算法应该返回 true。<br>你看到了，并不是简单的挑数字大的选，为什么第一次选择 2 而不是 5 呢？因为 5 后面是 9，你要是贪图一时的利益，就把 9 这堆石头暴露给对手了，那你就要输了。<br>这也是强调双方都很聪明的原因，算法也是求最优决策过程下你是否能赢。<br>这道题又涉及到两人的博弈，也可以用动态规划算法暴力试，比较麻烦。但我们只要对规则深入思考，就会大惊失色：只要你足够聪明，你是必胜无疑的，因为你是先手。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">stoneGame</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] piles)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是为什么呢，因为题目有两个条件很重要：一是石头总共有偶数堆，石头的总数是奇数。这两个看似增加游戏公平性的条件，反而使该游戏成为了一个割韭菜游戏。我们以 <code>piles=[2, 1, 9, 5]</code> 讲解，假设这四堆石头从左到右的索引分别是 1，2，3，4。<br>如果我们把这四堆石头按索引的奇偶分为两组，即第 1、3 堆和第 2、4 堆，那么这两组石头的数量一定不同，也就是说一堆多一堆少。因为石头的总数是奇数，不能被平分。<br>而作为第一个拿石头的人，你可以控制自己拿到所有偶数堆，或者所有的奇数堆。<br>你最开始可以选择第 1 堆或第 4 堆。如果你想要偶数堆，你就拿第 4 堆，这样留给对手的选择只有第 1、3 堆，他不管怎么拿，第 2 堆又会暴露出来，你就可以拿。同理，如果你想拿奇数堆，你就拿第 1 堆，留给对手的只有第 2、4 堆，他不管怎么拿，第 3 堆又给你暴露出来了。<br>也就是说，你可以在第一步就观察好，奇数堆的石头总数多，还是偶数堆的石头总数多，然后步步为营，就一切尽在掌控之中了。知道了这个漏洞，可以整一整不知情的同学了。</p><h3 id="三、电灯开关问题"><a href="#三、电灯开关问题" class="headerlink" title="三、电灯开关问题"></a>三、电灯开关问题</h3><p>这个问题是这样描述的：有 n 盏电灯，最开始时都是关着的。现在要进行 n 轮操作：<br>第 1 轮操作是把每一盏电灯的开关按一下（全部打开）。<br>第 2 轮操作是把每两盏灯的开关按一下（就是按第 2，4，6… 盏灯的开关，它们被关闭）。<br>第 3 轮操作是把每三盏灯的开关按一下（就是按第 3，6，9… 盏灯的开关，有的被关闭，比如 3，有的被打开，比如 6）…<br>如此往复，直到第 n 轮，即只按一下第 n 盏灯的开关。<br>现在给你输入一个正整数 n 代表电灯的个数，问你经过 n 轮操作后，这些电灯有多少盏是亮的？<br>我们当然可以用一个布尔数组表示这些灯的开关情况，然后模拟这些操作过程，最后去数一下就能出结果。但是这样显得没有灵性，最好的解法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bulbSwitch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.sqrt(n);<br>&#125;<br></code></pre></td></tr></table></figure><p>什么？这个问题跟平方根有什么关系？其实这个解法挺精妙，如果没人告诉你解法，还真不好想明白。<br>首先，因为电灯一开始都是关闭的，所以某一盏灯最后如果是点亮的，必然要被按奇数次开关。<br>我们假设只有 6 盏灯，而且我们只看第 6 盏灯。需要进行 6 轮操作对吧，请问对于第 6 盏灯，会被按下几次开关呢？这不难得出，第 1 轮会被按，第 2 轮，第 3 轮，第 6 轮都会被按。<br>为什么第 1、2、3、6 轮会被按呢？因为 <code>6=1x6=2x3</code>。一般情况下，因子都是成对出现的，也就是说开关被按的次数一般是偶数次。但是有特殊情况，比如说总共有 16 盏灯，那么第 16 盏灯会被按几次?<br><code>16=1x16=2x8=4x4</code><br>其中因子 4 重复出现，所以第 16 盏灯会被按 5 次，奇数次。现在你应该理解这个问题为什么和平方根有关了吧？<br>不过，我们不是要算最后有几盏灯亮着吗，这样直接平方根一下是啥意思呢？稍微思考一下就能理解了。<br>就假设现在总共有 16 盏灯，我们求 16 的平方根，等于 4，这就说明最后会有 4 盏灯亮着，它们分别是第 <code>1x1=1</code> 盏、第 <code>2x2=4</code> 盏、第 <code>3x3=9</code> 盏和第 <code>4x4=16</code> 盏。<br>就算有的 n 平方根结果是小数，强转成 int 型，也相当于一个最大整数上界，比这个上界小的所有整数，平方后的索引都是最后亮着的灯的索引。所以说我们直接把平方根转成整数，就是这个问题的答案。</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8">上一篇：Union-Find算法应用</a><br><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E5%AD%90%E5%BA%8F%E5%88%97">下一篇：二分查找高效判定子序列</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断回文链表</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>我们之前有两篇文章写了回文串和回文序列相关的问题。<br><strong>寻找</strong>回文串的核心思想是从中心向两端扩展：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">palindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 防止索引越界</span><br>    <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.size()<br>            &amp;&amp; s[l] == s[r]) &#123;<br>        <span class="hljs-comment">// 向两边展开</span><br>        l--; r++;<br>    &#125;<br>    <span class="hljs-comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span><br>    <span class="hljs-keyword">return</span> s.substr(l + <span class="hljs-number">1</span>, r - l - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为回文串长度可能为奇数也可能是偶数，长度为奇数时只存在一个中心点，而长度为偶数时存在两个中心点，所以上面这个函数需要传入<code>l</code>和<code>r</code>。<br>而<strong>判断</strong>一个字符串是不是回文串就简单很多，不需要考虑奇偶情况，只需要「双指针技巧」，从两端向中间逼近即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = s.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (s[left] != s[right])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        left++; right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码很好理解吧，<strong>因为回文串是对称的，所以正着读和倒着读应该是一样的，这一特点是解决回文串问题的关键</strong>。<br>下面扩展这一最简单的情况，来解决：如何判断一个「单链表」是不是回文。</p><h3 id="一、判断回文单链表"><a href="#一、判断回文单链表" class="headerlink" title="一、判断回文单链表"></a>一、判断回文单链表</h3><p>输入一个单链表的头结点，判断这个链表中的数字是不是回文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单链表节点的定义：</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span></span>;<br>输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-keyword">null</span><br>输出: <span class="hljs-keyword">false</span><br>输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-keyword">null</span><br>输出: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>这道题的关键在于，单链表无法倒着遍历，无法使用双指针技巧。那么最简单的办法就是，把原始链表反转存入一条新的链表，然后比较这两条链表是否相同。关于如何反转链表，可以参见前文「递归操作链表」。<br>其实，<strong>借助二叉树后序遍历的思路，不需要显式反转原始链表也可以倒序遍历链表</strong>，下面来具体聊聊。<br>对于二叉树的几种遍历方式，我们再熟悉不过了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">// 前序遍历代码</span><br>    traverse(root.left);<br>    <span class="hljs-comment">// 中序遍历代码</span><br>    traverse(root.right);<br>    <span class="hljs-comment">// 后序遍历代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在「学习数据结构的框架思维」中说过，链表兼具递归结构，树结构不过是链表的衍生。那么，<strong>链表其实也可以有前序遍历和后序遍历</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-comment">// 前序遍历代码</span><br>    traverse(head.next);<br>    <span class="hljs-comment">// 后序遍历代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个框架有什么指导意义呢？如果我想正序打印链表中的<code>val</code>值，可以在前序遍历位置写代码；反之，如果想倒序遍历链表，就可以在后序遍历位置操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 倒序打印单链表中的元素值 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>    traverse(head.next);<br>    <span class="hljs-comment">// 后序遍历代码</span><br>    print(head.val);<br>&#125;<br></code></pre></td></tr></table></figure><p>说到这了，其实可以稍作修改，模仿双指针实现回文判断的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 左侧指针</span><br>ListNode left;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    left = head;<br>    <span class="hljs-keyword">return</span> traverse(head);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">traverse</span><span class="hljs-params">(ListNode right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">boolean</span> res = traverse(right.next);<br>    <span class="hljs-comment">// 后序遍历代码</span><br>    res = res &amp;&amp; (right.val == left.val);<br>    left = left.next;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这么做的核心逻辑是什么呢？<strong>实际上就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的</strong>，只不过我们利用的是递归函数的堆栈而已。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/1.gif"><br>当然，无论造一条反转链表还是利用后续遍历，算法的时间和空间复杂度都是 O(N)。下面我们想想，能不能不用额外的空间，解决这个问题呢？</p><h3 id="二、优化空间复杂度"><a href="#二、优化空间复杂度" class="headerlink" title="二、优化空间复杂度"></a>二、优化空间复杂度</h3><p>更好的思路是这样的：<br><strong>1、先通过「双指针技巧」中的快慢指针来找到链表的中点</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode slow, fast;<br>slow = fast = head;<br><span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>    slow = slow.next;<br>    fast = fast.next.next;<br>&#125;<br><span class="hljs-comment">// slow 指针现在指向链表中点</span><br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/1.jpg"><br><strong>2、如果<code>fast</code>指针没有指向<code>null</code>，说明链表长度为奇数，<code>slow</code>还要再前进一步</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (fast != <span class="hljs-keyword">null</span>)<br>    slow = slow.next;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/2.jpg"><br><strong>3、从<code>slow</code>开始反转后面的链表，现在就可以开始比较回文串了</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ListNode left = head;<br>ListNode right = reverse(slow);<br><span class="hljs-keyword">while</span> (right != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (left.val != right.val)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    left = left.next;<br>    right = right.next;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/3.jpg"><br>至此，把上面 3 段代码合在一起就高效地解决这个问题了，其中<code>reverse</code>函数很容易实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode pre = <span class="hljs-keyword">null</span>, cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br>        ListNode next = cur.next;<br>        cur.next = pre;<br>        pre = cur;<br>        cur = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kgroup/8.gif"><br>算法总体的时间复杂度 O(N)，空间复杂度 O(1)，已经是最优的了。<br>我知道肯定有读者会问：这种解法虽然高效，但破坏了输入链表的原始结构，能不能避免这个瑕疵呢？<br>其实这个问题很好解决，关键在于得到<code>p, q</code>这两个指针位置：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/4.jpg"><br>这样，只要在函数 return 之前加一段代码即可恢复原先链表顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">p.next = reverse(q);<br></code></pre></td></tr></table></figure><p>篇幅所限，我就不写了，读者可以自己尝试一下。</p><h3 id="三、最后总结"><a href="#三、最后总结" class="headerlink" title="三、最后总结"></a>三、最后总结</h3><p>首先，寻找回文串是从中间向两端扩展，判断回文串是从两端向中间收缩。对于单链表，无法直接倒序遍历，可以造一条新的反转链表，可以利用链表的后序遍历，也可以用栈结构倒序处理单链表。<br>具体到回文链表的判断问题，由于回文的特殊性，可以不完全反转链表，而是仅仅反转部分链表，将空间复杂度降到 O(1)。</p><p><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E7%BC%BA%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0">上一篇：如何寻找缺失和重复的元素</a><br><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7">下一篇：如何在无限序列中随机抽取元素</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合法括号判定</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%88%A4%E5%AE%9A/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%88%A4%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="如何判定括号合法性"><a href="#如何判定括号合法性" class="headerlink" title="如何判定括号合法性"></a>如何判定括号合法性</h1><p>对括号的合法性判断是一个很常见且实用的问题，比如说我们写的代码，编辑器和编译器都会检查括号是否正确闭合。而且我们的代码可能会包含三种括号 <code>[]()&#123;&#125;</code>，判断起来有一点难度。<br>本文就来聊一道关于括号合法性判断的算法题，相信能加深你对<strong>栈</strong>这种数据结构的理解。<br>题目很简单，输入一个字符串，其中包含 <code>[]()&#123;&#125;</code> 六种括号，请你判断这个字符串组成的括号是否合法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">Input: &quot;()[]&#123;&#125;&quot;<br>Output: true<br>Input: &quot;([)]&quot;<br>Output: false<br>Input: &quot;&#123;[]&#125;&quot;<br>Output: true<br></code></pre></td></tr></table></figure><p>解决这个问题之前，我们先降低难度，思考一下，**如果只有一种括号 <code>()</code>**，应该如何判断字符串组成的括号是否合法呢？</p><h3 id="一、处理一种括号"><a href="#一、处理一种括号" class="headerlink" title="一、处理一种括号"></a>一、处理一种括号</h3><p>字符串中只有圆括号，如果想让括号字符串合法，那么必须做到：<br><strong>每个右括号 <code>)</code> 的左边必须有一个左括号 <code>(</code> 和它匹配</strong>。<br>比如说字符串 <code>()))((</code> 中，中间的两个右括号<strong>左边</strong>就没有左括号匹配，所以这个括号组合是不合法的。<br>那么根据这个思路，我们可以写出算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span>&#123;<br>    <span class="hljs-comment">// 待匹配的左括号数量</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>)<br>            left++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 遇到右括号</span><br>            left--;<br>        <span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只有圆括号，这样就能正确判断合法性。对于三种括号的情况，我一开始想模仿这个思路，定义三个变量 <code>left1</code>，<code>left2</code>，<code>left3</code> 分别处理每种括号，虽然要多写不少 if else 分支，但是似乎可以解决问题。<br>但实际上直接照搬这种思路是不行的，比如说只有一个括号的情况下 <code>(())</code> 是合法的，但是多种括号的情况下， <code>[(])</code> 显然是不合法的。<br>仅仅记录每种左括号出现的次数已经不能做出正确判断了，我们要加大存储的信息量，可以利用栈来模仿类似的思路。</p><h3 id="二、处理多种括号"><a href="#二、处理多种括号" class="headerlink" title="二、处理多种括号"></a>二、处理多种括号</h3><p>栈是一种先进后出的数据结构，处理括号问题的时候尤其有用。<br>我们这道题就用一个名为 <code>left</code> 的栈代替之前思路中的 <code>left</code> 变量，<strong>遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span>&#123;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; left;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span>)<br>            left.push(c);<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 字符 c 是右括号</span><br>            <span class="hljs-keyword">if</span> (!left.empty() &amp;&amp; leftOf(c) == left.top())<br>                left.pop();<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 和最近的左括号不匹配</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 是否所有的左括号都被匹配了</span><br>    <span class="hljs-keyword">return</span> left.empty();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">leftOf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#125;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">上一篇：如何k个一组反转链表</a><br><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%B6%88%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0">下一篇：如何寻找消失的元素</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何去除有序数组的重复元素</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="如何去除有序数组的重复元素"><a href="#如何去除有序数组的重复元素" class="headerlink" title="如何去除有序数组的重复元素"></a>如何去除有序数组的重复元素</h1><p>我们知道对于数组来说，在尾部插入、删除元素是比较高效的，时间复杂度是 O(1)，但是如果在中间或者开头插入、删除元素，就会涉及数据的搬移，时间复杂度为 O(N)，效率较低。<br>所以对于一般处理数组的算法问题，我们要尽可能只对数组尾部的元素进行操作，以避免额外的时间复杂度。<br>这篇文章讲讲如何对一个有序数组去重，先看下题目：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/title.png"><br>显然，由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难，但如果毎找到一个重复元素就立即删除它，就是在数组中间进行删除操作，整个时间复杂度是会达到 O(N^2)。而且题目要求我们原地修改，也就是说不能用辅助数组，空间复杂度得是 O(1)。<br>其实，<strong>对于数组相关的算法问题，有一个通用的技巧：要尽量避免在中间删除元素，那我就想先办法把这个元素换到最后去</strong>。这样的话，最终待删除的元素都拖在数组尾部，一个一个 pop 掉就行了，每次操作的时间复杂度也就降低到 O(1) 了。<br>按照这个思路呢，又可以衍生出解决类似需求的通用方式：双指针技巧。具体一点说，应该是快慢指针。<br>我们让慢指针 <code>slow</code> 走左后面，快指针 <code>fast</code> 走在前面探路，找到一个不重复的元素就告诉 <code>slow</code> 并让 <code>slow</code> 前进一步。这样当 <code>fast</code> 指针遍历完整个数组 <code>nums</code> 后，**<code>nums[0..slow]</code> 就是不重复元素，之后的所有元素都是重复元素**。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (fast &lt; n) &#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] != nums[slow]) &#123;<br>            slow++;<br>            <span class="hljs-comment">// 维护 nums[0..slow] 无重复</span><br>            nums[slow] = nums[fast];<br>        &#125;<br>        fast++;<br>    &#125;<br>    <span class="hljs-comment">// 长度为索引 + 1</span><br>    <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看下算法执行的过程：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/1.gif"><br>再简单扩展一下，如果给你一个有序链表，如何去重呢？其实和数组是一模一样的，唯一的区别是把数组赋值操作变成操作指针而已：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    ListNode slow = head, fast = head.next;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (fast.val != slow.val) &#123;<br>            <span class="hljs-comment">// nums[slow] = nums[fast];</span><br>            slow.next = fast;<br>            <span class="hljs-comment">// slow++;</span><br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-comment">// fast++</span><br>        fast = fast.next;<br>    &#125;<br>    <span class="hljs-comment">// 断开与后面重复元素的连接</span><br>    slow.next = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/2.gif"></p><p><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%8E%A5%E9%9B%A8%E6%B0%B4">上一篇：如何高效解决接雨水问题</a><br><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">下一篇：如何寻找最长回文子串</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子集排列组合</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%AD%90%E9%9B%86%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%AD%90%E9%9B%86%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>今天就来聊三道考察频率高，而且容易让人搞混的算法问题，分别是求子集（subset），求排列（permutation），求组合（combination）。<br>这几个问题都可以用回溯算法模板解决，同时子集问题还可以用数学归纳思想解决。读者可以记住这几个问题的回溯套路，就不怕搞不清了。</p><h3 id="一、子集"><a href="#一、子集" class="headerlink" title="一、子集"></a>一、子集</h3><p>问题很简单，输入一个<strong>不包含重复数字</strong>的数组，要求算法输出这些数字的所有子集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span>;<br></code></pre></td></tr></table></figure><p>比如输入 <code>nums = [1,2,3]</code>，你的算法应输出 8 个子集，包含空集和本身，顺序可以不同：<br>[ [],[1],[2],[3],[1,3],[2,3],[1,2],[1,2,3] ]<br><strong>第一个解法是利用数学归纳的思想</strong>：假设我现在知道了规模更小的子问题的结果，如何推导出当前问题的结果呢？<br>具体来说就是，现在让你求 <code>[1,2,3]</code> 的子集，如果你知道了 <code>[1,2]</code> 的子集，是否可以推导出 <code>[1,2,3]</code> 的子集呢？先把  <code>[1,2]</code> 的子集写出来瞅瞅：<br>[ [],[1],[2],[1,2] ]<br>你会发现这样一个规律：<br>subset(<code>[1,2,3]</code>) - subset(<code>[1,2]</code>)<br>= [3],[1,3],[2,3],[1,2,3]<br>而这个结果，就是把 sebset(<code>[1,2]</code>) 的结果中每个集合再添加上 3。<br>换句话说，如果 <code>A = subset([1,2])</code> ，那么：<br>subset(<code>[1,2,3]</code>)<br>= A + [A[i].add(3) for i = 1..len(A)]<br>这就是一个典型的递归结构嘛，<code>[1,2,3]</code> 的子集可以由 <code>[1,2]</code> 追加得出，<code>[1,2]</code> 的子集可以由 <code>[1]</code> 追加得出，base case 显然就是当输入集合为空集时，输出子集也就是一个空集。<br>翻译成代码就很容易理解了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-comment">// base case，返回一个空集</span><br>    <span class="hljs-keyword">if</span> (nums.empty()) <span class="hljs-keyword">return</span> &#123;&#123;&#125;&#125;;<br>    <span class="hljs-comment">// 把最后一个元素拿出来</span><br>    <span class="hljs-keyword">int</span> n = nums.back();<br>    nums.pop_back();<br>    <span class="hljs-comment">// 先递归算出前面元素的所有子集</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res = subsets(nums);<br>    <span class="hljs-keyword">int</span> size = res.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-comment">// 然后在之前的结果之上追加</span><br>        res.push_back(res[i]);<br>        res.back().push_back(n);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这个问题的时间复杂度计算比较容易坑人</strong>。我们之前说的计算递归算法时间复杂度的方法，是找到递归深度，然后乘以每次递归中迭代的次数。对于这个问题，递归深度显然是 N，但我们发现每次递归 for 循环的迭代次数取决于 <code>res</code> 的长度，并不是固定的。<br>根据刚才的思路，<code>res</code> 的长度应该是每次递归都翻倍，所以说总的迭代次数应该是 2^N。或者不用这么麻烦，你想想一个大小为 N 的集合的子集总共有几个？2^N 个对吧，所以说至少要对 <code>res</code> 添加 2^N 次元素。<br>那么算法的时间复杂度就是 O(2^N) 吗？还是不对，2^N 个子集是 <code>push_back</code> 添加进 <code>res</code> 的，所以要考虑 <code>push_back</code> 这个操作的效率：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>    res.push_back(res[i]); <span class="hljs-comment">// O(N)</span><br>    res.back().push_back(n); <span class="hljs-comment">// O(1)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为 <code>res[i]</code> 也是一个数组呀，<code>push_back</code> 是把 <code>res[i]</code> copy 一份然后添加到数组的最后，所以一次操作的时间是 O(N)。<br>综上，总的时间复杂度就是 O(N<em>2^N)，还是比较耗时的。<br>空间复杂度的话，如果不计算储存返回结果所用的空间的，只需要 O(N) 的递归堆栈空间。如果计算 <code>res</code> 所需的空间，应该是 O(N</em>2^N)。<br><strong>第二种通用方法就是回溯算法</strong>。旧文「回溯算法详解」写过回溯算法的模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">result = []<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">路径, 选择列表</span>):</span><br>    <span class="hljs-keyword">if</span> 满足结束条件:<br>        result.add(路径)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br></code></pre></td></tr></table></figure><p>只要改造回溯算法的模板就行了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 记录走过的路径</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; track;<br>    backtrack(nums, <span class="hljs-number">0</span>, track);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> start, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; track)</span> </span>&#123;<br>    res.push_back(track);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.size(); i++) &#123;<br>        <span class="hljs-comment">// 做选择</span><br>        track.push_back(nums[i]);<br>        <span class="hljs-comment">// 回溯</span><br>        backtrack(nums, i + <span class="hljs-number">1</span>, track);<br>        <span class="hljs-comment">// 撤销选择</span><br>        track.pop_back();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看见，对 <code>res</code> 更新的位置处在前序遍历，也就是说，**<code>res</code> 就是树上的所有节点**：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AD%90%E9%9B%86/1.jpg"></p><h3 id="二、组合"><a href="#二、组合" class="headerlink" title="二、组合"></a>二、组合</h3><p>输入两个数字 <code>n, k</code>，算法输出 <code>[1..n]</code> 中 k 个数字的所有组合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span></span>;<br></code></pre></td></tr></table></figure><p>比如输入 <code>n = 4, k = 2</code>，输出如下结果，顺序无所谓，但是不能包含重复（按照组合的定义，<code>[1,2]</code> 和 <code>[2,1]</code> 也算重复）：<br>[<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>  [2,3],<br>  [2,4],<br>  [3,4]<br>]<br>这也是典型的回溯算法，<code>k</code> 限制了树的高度，<code>n</code> 限制了树的宽度，继续套我们以前讲过的回溯算法模板框架就行了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AD%90%E9%9B%86/2.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;res;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span> || n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; track;<br>    backtrack(n, k, <span class="hljs-number">1</span>, track);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> start, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; track)</span> </span>&#123;<br>    <span class="hljs-comment">// 到达树的底部</span><br>    <span class="hljs-keyword">if</span> (k == track.size()) &#123;<br>        res.push_back(track);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 注意 i 从 start 开始递增</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= n; i++) &#123;<br>        <span class="hljs-comment">// 做选择</span><br>        track.push_back(i);<br>        backtrack(n, k, i + <span class="hljs-number">1</span>, track);<br>        <span class="hljs-comment">// 撤销选择</span><br>        track.pop_back();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>backtrack</code> 函数和计算子集的差不多，区别在于，更新 <code>res</code> 的时机是树到达底端时。</p><h3 id="三、排列"><a href="#三、排列" class="headerlink" title="三、排列"></a>三、排列</h3><p>输入一个<strong>不包含重复数字</strong>的数组 <code>nums</code>，返回这些数字的全部排列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">permute</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span>;<br></code></pre></td></tr></table></figure><p>比如说输入数组 <code>[1,2,3]</code>，输出结果应该如下，顺序无所谓，不能有重复：<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]<br>「回溯算法详解」中就是拿这个问题来解释回溯模板的。这里又列出这个问题，是将「排列」和「组合」这两个回溯算法的代码拿出来对比。<br>首先画出回溯树来看一看：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%AD%90%E9%9B%86/3.jpg"><br>我们当时使用 Java 代码写的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span><br>List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-comment">// 记录「路径」</span><br>    LinkedList&lt;Integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    backtrack(nums, track);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;<br>    <span class="hljs-comment">// 触发结束条件</span><br>    <span class="hljs-keyword">if</span> (track.size() == nums.length) &#123;<br>        res.add(<span class="hljs-keyword">new</span> LinkedList(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 排除不合法的选择</span><br>        <span class="hljs-keyword">if</span> (track.contains(nums[i]))<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 做选择</span><br>        track.add(nums[i]);<br>        <span class="hljs-comment">// 进入下一层决策树</span><br>        backtrack(nums, track);<br>        <span class="hljs-comment">// 取消选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回溯模板依然没有变，但是根据排列问题和组合问题画出的树来看，排列问题的树比较对称，而组合问题的树越靠右节点越少。<br>在代码中的体现就是，排列问题每次通过 <code>contains</code> 方法来排除在 <code>track</code> 中已经选择过的数字；而组合问题通过传入一个 <code>start</code> 参数，来排除 <code>start</code> 索引之前的数字。<br><strong>以上，就是排列组合和子集三个问题的解法，总结一下</strong>：<br>子集问题可以利用数学归纳思想，假设已知一个规模较小的问题的结果，思考如何推导出原问题的结果。也可以用回溯算法，要用 <code>start</code> 参数排除已选择的数字。<br>组合问题利用的是回溯思想，结果可以表示成树结构，我们只要套用回溯算法模板即可，关键点在于要用一个 <code>start</code> 排除已经选择过的数字。<br>排列问题是回溯思想，也可以表示成树结构套用算法模板，关键点在于使用 <code>contains</code> 方法排除已经选择的数字，前文有详细分析，这里主要是和组合问题作对比。<br>记住这几种树的形状，就足以应对大部分回溯算法问题了，无非就是 <code>start</code> 或者 <code>contains</code> 剪枝，也没啥别的技巧了。</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88">上一篇：回溯算法详解</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3">下一篇：二分查找详解</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>座位调度</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%BA%A7%E4%BD%8D%E8%B0%83%E5%BA%A6/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%BA%A7%E4%BD%8D%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="如何调度考生的座位"><a href="#如何调度考生的座位" class="headerlink" title="如何调度考生的座位"></a>如何调度考生的座位</h1><p>这是 LeetCode 第 885 题，有趣且具有一定技巧性。这种题目并不像动态规划这类算法拼智商，而是看你对常用数据结构的理解和写代码的水平，个人认为值得重视和学习。<br>另外说句题外话，很多读者都问，算法框架是如何总结出来的，其实框架反而是慢慢从细节里抠出来的。希望大家看了我们的文章之后，最好能抽时间把相关的问题亲自做一做，纸上得来终觉浅，绝知此事要躬行嘛。<br>先来描述一下题目：假设有一个考场，考场有一排共 <code>N</code> 个座位，索引分别是 <code>[0..N-1]</code>，考生会<strong>陆续</strong>进入考场考试，并且可能在<strong>任何时候</strong>离开考场。<br>你作为考官，要安排考生们的座位，满足：<strong>每当一个学生进入时，你需要最大化他和最近其他人的距离；如果有多个这样的座位，安排到他到索引最小的那个座位</strong>。这很符合实际情况对吧，<br>也就是请你实现下面这样一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExamRoom</span> </span>&#123;<br>    <span class="hljs-comment">// 构造函数，传入座位总数 N</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExamRoom</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span></span>;<br>    <span class="hljs-comment">// 来了一名考生，返回你给他分配的座位</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">seat</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 坐在 p 位置的考生离开了</span><br>    <span class="hljs-comment">// 可以认为 p 位置一定坐有考生</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leave</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>比方说考场有 5 个座位，分别是 <code>[0..4]</code>：<br>第一名考生进入时（调用 <code>seat()</code>），坐在任何位置都行，但是要给他安排索引最小的位置，也就是返回位置 0。<br>第二名学生进入时（再调用 <code>seat()</code>），要和旁边的人距离最远，也就是返回位置 4。<br>第三名学生进入时，要和旁边的人距离最远，应该做到中间，也就是座位 2。<br>如果再进一名学生，他可以坐在座位 1 或者 3，取较小的索引 1。<br>以此类推。<br>刚才所说的情况，没有调用 <code>leave</code> 函数，不过读者肯定能够发现规律：<br><strong>如果将每两个相邻的考生看做线段的两端点，新安排考生就是找最长的线段，然后让该考生在中间把这个线段「二分」，中点就是给他分配的座位。<code>leave(p)</code> 其实就是去除端点 <code>p</code>，使得相邻两个线段合并为一个</strong>。<br>核心思路很简单对吧，所以这个问题实际上实在考察你对数据结构的理解。对于上述这个逻辑，你用什么数据结构来实现呢？</p><h3 id="一、思路分析"><a href="#一、思路分析" class="headerlink" title="一、思路分析"></a>一、思路分析</h3><p>根据上述思路，首先需要把坐在教室的学生抽象成线段，我们可以简单的用一个大小为 2 的数组表示。<br>另外，思路需要我们找到「最长」的线段，还需要去除线段，增加线段。<br><strong>但凡遇到在动态过程中取最值的要求，肯定要使用有序数据结构，我们常用的数据结构就是二叉堆和平衡二叉搜索树了</strong>。二叉堆实现的优先级队列取最值的时间复杂度是 O(logN)，但是只能删除最大值。平衡二叉树也可以取最值，也可以修改、删除任意一个值，而且时间复杂度都是 O(logN)。<br>综上，二叉堆不能满足 <code>leave</code> 操作，应该使用平衡二叉树。所以这里我们会用到 Java 的一种数据结构 <code>TreeSet</code>，这是一种有序数据结构，底层由红黑树维护有序性。<br>这里顺便提一下，一说到集合（Set）或者映射（Map），有的读者可能就想当然的认为是哈希集合（HashSet）或者哈希表（HashMap），这样理解是有点问题的。<br>因为哈希集合/映射底层是由哈希函数和数组实现的，特性是遍历无固定顺序，但是操作效率高，时间复杂度为 O(1)。<br>而集合/映射还可以依赖其他底层数据结构，常见的就是红黑树（一种平衡二叉搜索树），特性是自动维护其中元素的顺序，操作效率是 O(logN)。这种一般称为「有序集合/映射」。<br>我们使用的 <code>TreeSet</code> 就是一个有序集合，目的就是为了保持线段长度的有序性，快速查找最大线段，快速删除和插入。</p><h3 id="二、简化问题"><a href="#二、简化问题" class="headerlink" title="二、简化问题"></a>二、简化问题</h3><p>首先，如果有多个可选座位，需要选择索引最小的座位对吧？<strong>我们先简化一下问题，暂时不管这个要求</strong>，实现上述思路。<br>这个问题还用到一个常用的编程技巧，就是使用一个「虚拟线段」让算法正确启动，这就和链表相关的算法需要「虚拟头结点」一个道理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将端点 p 映射到以 p 为左端点的线段</span><br><span class="hljs-keyword">private</span> Map&lt;Integer, <span class="hljs-keyword">int</span>[]&gt; startMap;<br><span class="hljs-comment">// 将端点 p 映射到以 p 为右端点的线段</span><br><span class="hljs-keyword">private</span> Map&lt;Integer, <span class="hljs-keyword">int</span>[]&gt; endMap;<br><span class="hljs-comment">// 根据线段长度从小到大存放所有线段</span><br><span class="hljs-keyword">private</span> TreeSet&lt;<span class="hljs-keyword">int</span>[]&gt; pq;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> N;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExamRoom</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.N = N;<br>    startMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    endMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    pq = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;((a, b) -&gt; &#123;<br>        <span class="hljs-comment">// 算出两个线段的长度</span><br>        <span class="hljs-keyword">int</span> distA = distance(a);<br>        <span class="hljs-keyword">int</span> distB = distance(b);<br>        <span class="hljs-comment">// 长度更长的更大，排后面</span><br>        <span class="hljs-keyword">return</span> distA - distB;<br>    &#125;);<br>    <span class="hljs-comment">// 在有序集合中先放一个虚拟线段</span><br>    addInterval(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;-<span class="hljs-number">1</span>, N&#125;);<br>&#125;<br><span class="hljs-comment">/* 去除一个线段 */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeInterval</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] intv)</span> </span>&#123;<br>    pq.remove(intv);<br>    startMap.remove(intv[<span class="hljs-number">0</span>]);<br>    endMap.remove(intv[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">/* 增加一个线段 */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterval</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] intv)</span> </span>&#123;<br>    pq.add(intv);<br>    startMap.put(intv[<span class="hljs-number">0</span>], intv);<br>    endMap.put(intv[<span class="hljs-number">1</span>], intv);<br>&#125;<br><span class="hljs-comment">/* 计算一个线段的长度 */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] intv)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> intv[<span class="hljs-number">1</span>] - intv[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>「虚拟线段」其实就是为了将所有座位表示为一个线段：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%BA%A7%E4%BD%8D%E8%B0%83%E5%BA%A6/1.jpg"><br>有了上述铺垫，主要 API <code>seat</code> 和 <code>leave</code> 就可以写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">seat</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 从有序集合拿出最长的线段</span><br>    <span class="hljs-keyword">int</span>[] longest = pq.last();<br>    <span class="hljs-keyword">int</span> x = longest[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> y = longest[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> seat;<br>    <span class="hljs-keyword">if</span> (x == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 情况一</span><br>        seat = <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y == N) &#123; <span class="hljs-comment">// 情况二</span><br>        seat = N - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 情况三</span><br>        seat = (y - x) / <span class="hljs-number">2</span> + x;<br>    &#125;<br>    <span class="hljs-comment">// 将最长的线段分成两段</span><br>    <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;x, seat&#125;;<br>    <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;seat, y&#125;;<br>    removeInterval(longest);<br>    addInterval(left);<br>    addInterval(right);<br>    <span class="hljs-keyword">return</span> seat;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leave</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    <span class="hljs-comment">// 将 p 左右的线段找出来</span><br>    <span class="hljs-keyword">int</span>[] right = startMap.get(p);<br>    <span class="hljs-keyword">int</span>[] left = endMap.get(p);<br>    <span class="hljs-comment">// 合并两个线段成为一个线段</span><br>    <span class="hljs-keyword">int</span>[] merged = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;left[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]&#125;;<br>    removeInterval(left);<br>    removeInterval(right);<br>    addInterval(merged);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%BA%A7%E4%BD%8D%E8%B0%83%E5%BA%A6/2.jpg" alt="三种情况"><br>至此，算法就基本实现了，代码虽多，但思路很简单：找最长的线段，从中间分隔成两段，中点就是 <code>seat()</code> 的返回值；找 <code>p</code> 的左右线段，合并成一个线段，这就是 <code>leave(p)</code> 的逻辑。</p><h3 id="三、进阶问题"><a href="#三、进阶问题" class="headerlink" title="三、进阶问题"></a>三、进阶问题</h3><p>但是，题目要求多个选择时选择索引最小的那个座位，我们刚才忽略了这个问题。比如下面这种情况会出错：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%BA%A7%E4%BD%8D%E8%B0%83%E5%BA%A6/3.jpg"><br>现在有序集合里有线段 <code>[0,4]</code> 和 <code>[4,9]</code>，那么最长线段 <code>longest</code> 就是后者，按照 <code>seat</code> 的逻辑，就会分割 <code>[4,9]</code>，也就是返回座位 6。但正确答案应该是座位 2，因为 2 和 6 都满足最大化相邻考生距离的条件，二者应该取较小的。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%BA%A7%E4%BD%8D%E8%B0%83%E5%BA%A6/4.jpg"><br><strong>遇到题目的这种要求，解决方式就是修改有序数据结构的排序方式</strong>。具体到这个问题，就是修改 <code>TreeMap</code> 的比较函数逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">pq = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;((a, b) -&gt; &#123;<br>    <span class="hljs-keyword">int</span> distA = distance(a);<br>    <span class="hljs-keyword">int</span> distB = distance(b);<br>    <span class="hljs-comment">// 如果长度相同，就比较索引</span><br>    <span class="hljs-keyword">if</span> (distA == distB)<br>        <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> distA - distB;<br>&#125;);<br></code></pre></td></tr></table></figure><p>除此之外，还要改变 <code>distance</code> 函数，<strong>不能简单地让它计算一个线段两个端点间的长度，而是让它计算该线段中点和端点之间的长度</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] intv)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = intv[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> y = intv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (x == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> y;<br>    <span class="hljs-keyword">if</span> (y == N) <span class="hljs-keyword">return</span> N - <span class="hljs-number">1</span> - x;<br>    <span class="hljs-comment">// 中点和端点之间的长度</span><br>    <span class="hljs-keyword">return</span> (y - x) / <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%BA%A7%E4%BD%8D%E8%B0%83%E5%BA%A6/5.jpg"><br>这样，<code>[0,4]</code> 和 <code>[4,9]</code> 的 <code>distance</code> 值就相等了，算法会比较二者的索引，取较小的线段进行分割。到这里，这道算法题目算是完全解决了。</p><h3 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a>四、最后总结</h3><p>本文聊的这个问题其实并不算难，虽然看起来代码很多。核心问题就是考察有序数据结构的理解和使用，来梳理一下。<br>处理动态问题一般都会用到有序数据结构，比如平衡二叉搜索树和二叉堆，二者的时间复杂度差不多，但前者支持的操作更多。<br>既然平衡二叉搜索树这么好用，还用二叉堆干嘛呢？因为二叉堆底层就是数组，实现简单啊，详见旧文「二叉堆详解」。你实现个红黑树试试？操作复杂，而且消耗的空间相对来说会多一些。具体问题，还是要选择恰当的数据结构来解决。<br>希望本文对大家有帮助。</p><p><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7">上一篇：如何在无限序列中随机抽取元素</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3">下一篇：Union-Find算法详解</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打印素数</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%89%93%E5%8D%B0%E7%B4%A0%E6%95%B0/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%89%93%E5%8D%B0%E7%B4%A0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="如何高效寻找素数"><a href="#如何高效寻找素数" class="headerlink" title="如何高效寻找素数"></a>如何高效寻找素数</h1><p>素数的定义看起来很简单，如果一个数如果只能被 1 和它本身整除，那么这个数就是素数。<br>不要觉得素数的定义简单，恐怕没多少人真的能把素数相关的算法写得高效。比如让你写这样一个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回区间 [2, n) 中有几个素数 </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"><span class="hljs-comment">// 比如 countPrimes(10) 返回 4</span></span><br><span class="hljs-function"><span class="hljs-comment">// 因为 2,3,5,7 是素数</span></span><br></code></pre></td></tr></table></figure><p>你会如何写这个函数？我想大家应该会这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">if</span> (isPrim(i)) count++;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-comment">// 判断整数 n 是否是素数</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 有其他整除因子</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写的话时间复杂度 O(n^2)，问题很大。<strong>首先你用 isPrime 函数来辅助的思路就不够高效；而且就算你要用 isPrime 函数，这样写算法也是存在计算冗余的</strong>。<br>先来简单说下<strong>如果你要判断一个数是不是素数，应该如何写算法</strong>。只需稍微修改一下上面的 isPrim 代码中的 for 循环条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++)<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p>换句话说，<code>i</code> 不需要遍历到 <code>n</code>，而只需要到 <code>sqrt(n)</code> 即可。为什么呢，我们举个例子，假设 <code>n = 12</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">12</span> = <span class="hljs-number">2</span> × <span class="hljs-number">6</span><br><span class="hljs-number">12</span> = <span class="hljs-number">3</span> × <span class="hljs-number">4</span><br><span class="hljs-number">12</span> = sqrt(<span class="hljs-number">12</span>) <span class="hljs-function">× <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span><br><span class="hljs-function">12 </span>= <span class="hljs-number">4</span> × <span class="hljs-number">3</span><br><span class="hljs-number">12</span> = <span class="hljs-number">6</span> × <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>可以看到，后两个乘积就是前面两个反过来，反转临界点就在 <code>sqrt(n)</code>。<br>换句话说，如果在 <code>[2,sqrt(n)]</code> 这个区间之内没有发现可整除因子，就可以直接断定 <code>n</code> 是素数了，因为在区间 <code>[sqrt(n),n]</code> 也一定不会发现可整除因子。<br>现在，<code>isPrime</code> 函数的时间复杂度降为 O(sqrt(N))，<strong>但是我们实现 <code>countPrimes</code> 函数其实并不需要这个函数</strong>，以上只是希望读者明白 <code>sqrt(n)</code> 的含义，因为等会还会用到。</p><h3 id="高效实现-countPrimes"><a href="#高效实现-countPrimes" class="headerlink" title="高效实现 countPrimes"></a>高效实现 <code>countPrimes</code></h3><p>高效解决这个问题的核心思路是和上面的常规思路反着来：<br>首先从 2 开始，我们知道 2 是一个素数，那么 2 × 2 = 4, 3 × 2 = 6, 4 × 2 = 8… 都不可能是素数了。<br>然后我们发现 3 也是素数，那么 3 × 2 = 6, 3 × 3 = 9, 3 × 4 = 12… 也都不可能是素数了。<br>看到这里，你是否有点明白这个排除法的逻辑了呢？先看我们的第一版代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span>[] isPrim = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br>    <span class="hljs-comment">// 将数组都初始化为 true</span><br>    Arrays.fill(isPrim, <span class="hljs-keyword">true</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) <br>        <span class="hljs-keyword">if</span> (isPrim[i]) <br>            <span class="hljs-comment">// i 的倍数不可能是素数了</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * i; j &lt; n; j += i) <br>                    isPrim[j] = <span class="hljs-keyword">false</span>;<br>    <br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">if</span> (isPrim[i]) count++;<br>    <br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果上面这段代码你能够理解，那么你已经掌握了整体思路，但是还有两个细微的地方可以优化。<br>首先，回想刚才判断一个数是否是素数的 <code>isPrime</code> 函数，由于因子的对称性，其中的 for 循环只需要遍历 <code>[2,sqrt(n)]</code> 就够了。这里也是类似的，我们外层的 for 循环也只需要遍历到 <code>sqrt(n)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt; n; i++) <br>    <span class="hljs-keyword">if</span> (isPrim[i]) <br>        ...<br></code></pre></td></tr></table></figure><p>除此之外，很难注意到内层的 for 循环也可以优化。我们之前的做法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * i; j &lt; n; j += i) <br>    isPrim[j] = <span class="hljs-keyword">false</span>;<br></code></pre></td></tr></table></figure><p>这样可以把 <code>i</code> 的整数倍都标记为 <code>false</code>，但是仍然存在计算冗余。<br>比如 <code>n = 25</code>，<code>i = 4</code> 时算法会标记 4 × 2 = 8，4 × 3 = 12 等等数字，但是这两个数字已经被 <code>i = 2</code> 和 <code>i = 3</code> 的 2 × 4 和 3 × 4 标记了。<br>我们可以稍微优化一下，让 <code>j</code> 从 <code>i</code> 的平方开始遍历，而不是从 <code>2 * i</code> 开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt; n; j += i) <br>    isPrim[j] = <span class="hljs-keyword">false</span>;<br></code></pre></td></tr></table></figure><p>这样，素数计数的算法就高效实现了，其实这个算法有一个名字，叫做 Sieve of Eratosthenes。看下完整的最终代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span>[] isPrim = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br>    Arrays.fill(isPrim, <span class="hljs-keyword">true</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt; n; i++) <br>        <span class="hljs-keyword">if</span> (isPrim[i]) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt; n; j += i) <br>                isPrim[j] = <span class="hljs-keyword">false</span>;<br>    <br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">if</span> (isPrim[i]) count++;<br>    <br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>该算法的时间复杂度比较难算</strong>，显然时间跟这两个嵌套的 for 循环有关，其操作数应该是：<br>  n/2 + n/3 + n/5 + n/7 + …<br>= n × (1/2 + 1/3 + 1/5 + 1/7…)<br>括号中是素数的倒数。其最终结果是 O(N * loglogN)，有兴趣的读者可以查一下该算法的时间复杂度证明。<br>以上就是素数算法相关的全部内容。怎么样，是不是看似简单的问题却有不少细节可以打磨呀？</p><p><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/LRU%E7%AE%97%E6%B3%95">上一篇：如何实现LRU算法</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">下一篇：如何计算编辑距离</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接雨水</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="接雨水问题详解"><a href="#接雨水问题详解" class="headerlink" title="接雨水问题详解"></a>接雨水问题详解</h1><p>接雨水这道题目挺有意思，在面试题中出现频率还挺高的，本文就来步步优化，讲解一下这道题。<br>先看一下题目：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%8E%A5%E9%9B%A8%E6%B0%B4/title.png"><br>就是用一个数组表示一个条形图，问你这个条形图最多能接多少水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span></span>;<br></code></pre></td></tr></table></figure><p>下面就来由浅入深介绍暴力解法 -&gt; 备忘录解法 -&gt; 双指针解法，在 O(N) 时间 O(1) 空间内解决这个问题。</p><h3 id="一、核心思路"><a href="#一、核心思路" class="headerlink" title="一、核心思路"></a>一、核心思路</h3><p>我第一次看到这个问题，无计可施，完全没有思路，相信很多朋友跟我一样。所以对于这种问题，我们不要想整体，而应该去想局部；就像之前的文章处理字符串问题，不要考虑如何处理整个字符串，而是去思考应该如何处理每一个字符。<br>这么一想，可以发现这道题的思路其实很简单。具体来说，仅仅对于位置 i，能装下多少水呢？<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%8E%A5%E9%9B%A8%E6%B0%B4/0.jpg"><br>能装 2 格水。为什么恰好是两格水呢？因为 height[i] 的高度为 0，而这里最多能盛 2 格水，2-0=2。<br>为什么位置 i 最多能盛 2 格水呢？因为，位置 i 能达到的水柱高度和其左边的最高柱子、右边的最高柱子有关，我们分别称这两个柱子高度为 <code>l_max</code> 和 <code>r_max</code>；<strong>位置 i 最大的水柱高度就是 <code>min(l_max, r_max)</code>。</strong><br>更进一步，对于位置 i，能够装的水为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">water[i] = min(<br>               <span class="hljs-comment"># 左边最高的柱子</span><br>               max(height[<span class="hljs-number">0.</span>.i]),  <br>               <span class="hljs-comment"># 右边最高的柱子</span><br>               max(height[i..end]) <br>            ) - height[i]<br>    <br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%8E%A5%E9%9B%A8%E6%B0%B4/1.jpg"><br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%8E%A5%E9%9B%A8%E6%B0%B4/2.jpg"><br>这就是本问题的核心思路，我们可以简单写一个暴力算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = height.size();<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> l_max = <span class="hljs-number">0</span>, r_max = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 找右边最高的柱子</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; n; j++)<br>            r_max = max(r_max, height[j]);<br>        <span class="hljs-comment">// 找左边最高的柱子</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; j--)<br>            l_max = max(l_max, height[j]);<br>        <span class="hljs-comment">// 如果自己就是最高的话，</span><br>        <span class="hljs-comment">// l_max == r_max == height[i]</span><br>        ans += min(l_max, r_max) - height[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>有之前的思路，这个解法应该是很直接粗暴的，时间复杂度 O(N^2)，空间复杂度 O(1)。但是很明显这种计算 <code>r_max</code> 和 <code>l_max</code> 的方式非常笨拙，一般的优化方法就是备忘录。</p><h3 id="二、备忘录优化"><a href="#二、备忘录优化" class="headerlink" title="二、备忘录优化"></a>二、备忘录优化</h3><p>之前的暴力解法，不是在每个位置 i 都要计算 <code>r_max</code> 和 <code>l_max</code> 吗？我们直接把结果都缓存下来，别傻不拉几的每次都遍历，这时间复杂度不就降下来了嘛。<br>我们开两个<strong>数组</strong> <code>r_max</code> 和 <code>l_max</code> 充当备忘录，<code>l_max[i]</code> 表示位置 i 左边最高的柱子高度，<code>r_max[i]</code> 表示位置 i 右边最高的柱子高度。预先把这两个数组计算好，避免重复计算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (height.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = height.size();<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 数组充当备忘录</span><br>    vector&lt;int&gt; l_max(n), r_max(n);<br>    <span class="hljs-comment">// 初始化 base case</span><br>    l_max[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>    r_max[n - <span class="hljs-number">1</span>] = height[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 从左向右计算 l_max</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        l_max[i] = max(height[i], l_max[i - <span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 从右向左计算 r_max</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) <br>        r_max[i] = max(height[i], r_max[i + <span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 计算答案</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) <br>        ans += min(l_max[i], r_max[i]) - height[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个优化其实和暴力解法差不多，就是避免了重复计算，把时间复杂度降低为 O(N)，已经是最优了，但是空间复杂度是 O(N)。下面来看一个精妙一些的解法，能够把空间复杂度降低到 O(1)。</p><h3 id="三、双指针解法"><a href="#三、双指针解法" class="headerlink" title="三、双指针解法"></a>三、双指针解法</h3><p>这种解法的思路是完全相同的，但在实现手法上非常巧妙，我们这次也不要用备忘录提前计算了，而是用双指针<strong>边走边算</strong>，节省下空间复杂度。<br>首先，看一部分代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = height.size();<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">int</span> l_max = height[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> r_max = height[n - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        l_max = max(l_max, height[left]);<br>        r_max = max(r_max, height[right]);<br>        left++; right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这部分代码，请问 <code>l_max</code> 和 <code>r_max</code> 分别表示什么意义呢？<br>很容易理解，**<code>l_max</code> 是 <code>height[0..left]</code> 中最高柱子的高度，<code>r_max</code> 是 <code>height[right..end]</code> 的最高柱子的高度**。<br>明白了这一点，直接看解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (height.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = height.size();<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">int</span> l_max = height[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> r_max = height[n - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        l_max = max(l_max, height[left]);<br>        r_max = max(r_max, height[right]);<br>        <br>        <span class="hljs-comment">// ans += min(l_max, r_max) - height[i]</span><br>        <span class="hljs-keyword">if</span> (l_max &lt; r_max) &#123;<br>            ans += l_max - height[left];<br>            left++; <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans += r_max - height[right];<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>你看，其中的核心思想和之前一模一样，换汤不换药。但是细心的读者可能会发现次解法还是有点细节差异：<br>之前的备忘录解法，<code>l_max[i]</code> 和 <code>r_max[i]</code> 代表的是 <code>height[0..i]</code> 和 <code>height[i..end]</code> 的最高柱子高度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ans += min(l_max[i], r_max[i]) - height[i];<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%8E%A5%E9%9B%A8%E6%B0%B4/3.jpg"><br>但是双指针解法中，<code>l_max</code> 和 <code>r_max</code> 代表的是 <code>height[0..left]</code> 和 <code>height[right..end]</code> 的最高柱子高度。比如这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (l_max &lt; r_max) &#123;<br>    ans += l_max - height[left];<br>    left++; <br>&#125; <br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%8E%A5%E9%9B%A8%E6%B0%B4/4.jpg"><br>此时的 <code>l_max</code> 是 <code>left</code> 指针左边的最高柱子，但是 <code>r_max</code> 并不一定是 <code>left</code> 指针右边最高的柱子，这真的可以得到正确答案吗？<br>其实这个问题要这么思考，我们只在乎 <code>min(l_max, r_max)</code>。对于上图的情况，我们已经知道 <code>l_max &lt; r_max</code> 了，至于这个 <code>r_max</code> 是不是右边最大的，不重要，重要的是 <code>height[i]</code> 能够装的水只和 <code>l_max</code> 有关。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E6%8E%A5%E9%9B%A8%E6%B0%B4/5.jpg"></p><p><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/koko%E5%81%B7%E9%A6%99%E8%95%89">上一篇：如何运用二分查找算法</a><br><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">下一篇：如何去除有序数组的重复元素</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="如何寻找最长回文子串"><a href="#如何寻找最长回文子串" class="headerlink" title="如何寻找最长回文子串"></a>如何寻找最长回文子串</h1><p>回文串是面试常常遇到的问题（虽然问题本身没啥意义），本文就告诉你回文串问题的核心思想是什么。<br>首先，明确一下什：<strong>回文串就是正着读和反着读都一样的字符串</strong>。<br>比如说字符串 <code>aba</code> 和 <code>abba</code> 都是回文串，因为它们对称，反过来还是和本身一样。反之，字符串 <code>abac</code> 就不是回文串。<br>可以看到回文串的的长度可能是奇数，也可能是偶数，这就添加了回文串问题的难度，解决该类问题的核心是<strong>双指针</strong>。下面就通过一道最长回文子串的问题来具体理解一下回文串问题：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%9B%9E%E6%96%87/title.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="一、思考"><a href="#一、思考" class="headerlink" title="一、思考"></a>一、思考</h3><p>对于这个问题，我们首先应该思考的是，给一个字符串 <code>s</code>，如何在 <code>s</code> 中找到一个回文子串？<br>有一个很有趣的思路：既然回文串是一个正着反着读都一样的字符串，那么如果我们把 <code>s</code> 反转，称为 <code>s&#39;</code>，然后在 <code>s</code> 和 <code>s&#39;</code> 中寻找<strong>最长公共子串</strong>，这样应该就能找到最长回文子串。<br>比如说字符串 <code>abacd</code>，反过来是 <code>dcaba</code>，它的最长公共子串是 <code>aba</code>，也就是最长回文子串。<br>但是这个思路是错误的，比如说字符串 <code>aacxycaa</code>，反转之后是 <code>aacyxcaa</code>，最长公共子串是 <code>aac</code>，但是最长回文子串应该是 <code>aa</code>。<br>虽然这个思路不正确，但是<strong>这种把问题转化为其他形式的思考方式是非常值得提倡的</strong>。<br>下面，就来说一下正确的思路，如何使用双指针。<br><strong>寻找回文串的问题核心思想是：从中间开始向两边扩散来判断回文串</strong>。对于最长回文子串，就是这个意思：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt;= i &lt; len(s):<br>    找到以 s[i] 为中心的回文串<br>    更新答案<br></code></pre></td></tr></table></figure><p>但是呢，我们刚才也说了，回文串的长度可能是奇数也可能是偶数，如果是 <code>abba</code>这种情况，没有一个中心字符，上面的算法就没辙了。所以我们可以修改一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt;= i &lt; len(s):<br>    找到以 s[i] 为中心的回文串<br>    找到以 s[i] 和 s[i+<span class="hljs-number">1</span>] 为中心的回文串<br>    更新答案<br></code></pre></td></tr></table></figure><p>PS：读者可能发现这里的索引会越界，等会会处理。</p><h3 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h3><p>按照上面的思路，先要实现一个函数来寻找最长回文串，这个函数是有点技巧的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">palindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 防止索引越界</span><br>    <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.size()<br>            &amp;&amp; s[l] == s[r]) &#123;<br>        <span class="hljs-comment">// 向两边展开</span><br>        l--; r++;<br>    &#125;<br>    <span class="hljs-comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span><br>    <span class="hljs-keyword">return</span> s.substr(l + <span class="hljs-number">1</span>, r - l - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要传入两个指针 <code>l</code> 和 <code>r</code> 呢？<strong>因为这样实现可以同时处理回文串长度为奇数和偶数的情况</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt;= i &lt; len(s):<br>    <span class="hljs-comment"># 找到以 s[i] 为中心的回文串</span><br>    palindrome(s, i, i)<br>    <span class="hljs-comment"># 找到以 s[i] 和 s[i+1] 为中心的回文串</span><br>    palindrome(s, i, i + <span class="hljs-number">1</span>)<br>    更新答案<br></code></pre></td></tr></table></figure><p>下面看下 <code>longestPalindrome</code> 的完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>        <span class="hljs-comment">// 以 s[i] 为中心的最长回文子串</span><br>        <span class="hljs-built_in">string</span> s1 = palindrome(s, i, i);<br>        <span class="hljs-comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span><br>        <span class="hljs-built_in">string</span> s2 = palindrome(s, i, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// res = longest(res, s1, s2)</span><br>        res = res.size() &gt; s1.size() ? res : s1;<br>        res = res.size() &gt; s2.size() ? res : s2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，这道最长回文子串的问题就解决了，时间复杂度 O(N^2)，空间复杂度 O(1)。<br>值得一提的是，这个问题可以用动态规划方法解决，时间复杂度一样，但是空间复杂度至少要 O(N^2) 来存储 DP table。这道题是少有的动态规划非最优解法的问题。<br>另外，这个问题还有一个巧妙的解法，时间复杂度只需要 O(N)，不过该解法比较复杂，我个人认为没必要掌握。该算法的名字叫 Manacher’s Algorithm（马拉车算法），有兴趣的读者可以自行搜索一下。</p><p><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">上一篇：如何去除有序数组的重复元素</a><br><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">下一篇：如何k个一组反转链表</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>水塘抽样</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7/</url>
      
        <content type="html"><![CDATA[<p>我最近在 LeetCode 上做到两道非常有意思的题目，382 和 398 题，关于水塘抽样算法（Reservoir Sampling），本质上是一种随机概率算法，解法应该说会者不难，难者不会。<br>我第一次见到这个算法问题是谷歌的一道算法题：给你一个<strong>未知长度</strong>的链表，请你设计一个算法，<strong>只能遍历一次</strong>，随机地返回链表中的一个节点。<br>这里说的随机是均匀随机（uniform random），也就是说，如果有 <code>n</code> 个元素，每个元素被选中的概率都是 <code>1/n</code>，不可以有统计意义上的偏差。<br>一般的想法就是，我先遍历一遍链表，得到链表的总长度 <code>n</code>，再生成一个 <code>[1,n]</code> 之间的随机数为索引，然后找到索引对应的节点，不就是一个随机的节点了吗？<br>但题目说了，只能遍历一次，意味着这种思路不可行。题目还可以再泛化，给一个未知长度的序列，如何在其中随机地选择 <code>k</code> 个元素？想要解决这个问题，就需要著名的水塘抽样算法了。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p><strong>先解决只抽取一个元素的问题</strong>，这个问题的难点在于，随机选择是「动态」的，比如说你现在你有 5 个元素，你已经随机选取了其中的某个元素 <code>a</code> 作为结果，但是现在再给你一个新元素 <code>b</code>，你应该留着 <code>a</code> 还是将 <code>b</code> 作为结果呢，以什么逻辑选择 <code>a</code> 和 <code>b</code> 呢，怎么证明你的选择方法在概率上是公平的呢？<br><strong>先说结论，当你遇到第 <code>i</code> 个元素时，应该有 <code>1/i</code> 的概率选择该元素，<code>1 - 1/i</code> 的概率保持原有的选择</strong>。看代码容易理解这个思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 返回链表中一个随机节点的值 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    Random r = <span class="hljs-keyword">new</span> Random();<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>    ListNode p = head;<br>    <span class="hljs-comment">// while 循环遍历链表</span><br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 生成一个 [0, i) 之间的整数</span><br>        <span class="hljs-comment">// 这个整数等于 0 的概率就是 1/i</span><br>        <span class="hljs-keyword">if</span> (r.nextInt(++i) == <span class="hljs-number">0</span>) &#123;<br>            res = p.val;<br>        &#125;<br>        p = p.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于概率算法，代码往往都是很浅显的，但是这种问题的关键在于证明，你的算法为什么是对的？为什么每次以 <code>1/i</code> 的概率更新结果就可以保证结果是平均随机（uniform random）？<br><strong>证明</strong>：假设总共有 <code>n</code> 个元素，我们要的随机性无非就是每个元素被选择的概率都是 <code>1/n</code> 对吧，那么对于第 <code>i</code> 个元素，它被选择的概率就是：<br>$$<br>\begin{aligned}<br>    &amp;\frac{1}{i} \times (1 - \frac{1}{i+1}) \times (1 - \frac{1}{i+2}) \times … \times (1 - \frac{1}{n}) \<br>    = &amp;\frac{1}{i} \times \frac{i}{i+1} \times \frac{i+1}{i+2} \times … \times \frac{n-1}{n} \<br>    = &amp;\frac{1}{n}<br>\end{aligned}<br>$$<br>第 <code>i</code> 个元素被选择的概率是 <code>1/i</code>，第 <code>i+1</code> 次不被替换的概率是 <code>1 - 1/(i+1)</code>，以此类推，相乘就是第 <code>i</code> 个元素最终被选中的概率，就是 <code>1/n</code>。<br>因此，该算法的逻辑是正确的。<br><strong>同理，如果要随机选择 <code>k</code> 个数，只要在第 <code>i</code> 个元素处以 <code>k/i</code> 的概率选择该元素，以 <code>1 - k/i</code> 的概率保持原有选择即可</strong>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 返回链表中 k 个随机节点的值 */</span><br><span class="hljs-keyword">int</span>[] getRandom(ListNode head, <span class="hljs-keyword">int</span> k) &#123;<br>    Random r = <span class="hljs-keyword">new</span> Random();<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>    ListNode p = head;<br>    <span class="hljs-comment">// 前 k 个元素先默认选上</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k &amp;&amp; p != <span class="hljs-keyword">null</span>; j++) &#123;<br>        res[j] = p.val;<br>        p = p.next;<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = k;<br>    <span class="hljs-comment">// while 循环遍历链表</span><br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 生成一个 [0, i) 之间的整数</span><br>        <span class="hljs-keyword">int</span> j = r.nextInt(++i);<br>        <span class="hljs-comment">// 这个整数小于 k 的概率就是 k/i</span><br>        <span class="hljs-keyword">if</span> (j &lt; k) &#123;<br>            res[j] = p.val;<br>        &#125;<br>        p = p.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于数学证明，和上面区别不大：<br>$$<br>\begin{aligned}<br>    &amp;\frac{k}{i} \times (1 - \frac{k}{i+1} \times \frac{1}{k}) \times (1 - \frac{k}{i+2} \times \frac{1}{k}) \times … \times (1 - \frac{k}{n} \times \frac{1}{k}) \<br>    = &amp;\frac{k}{i} \times (1 - \frac{1}{i+1}) \times (1 - \frac{1}{i+2}) \times … \times (1 - \frac{1}{n}) \<br>    = &amp;\frac{k}{i} \times \frac{i}{i+1} \times \frac{i+1}{i+2} \times … \times \frac{n-1}{n} \<br>    = &amp;\frac{k}{n}<br>\end{aligned}<br>$$<br>因为虽然每次更新选择的概率增大了 <code>k</code> 倍，但是选到具体第 <code>i</code> 个元素的概率还是要乘 <code>1/k</code>，也就回到了上一个推导。</p><h3 id="拓展延伸"><a href="#拓展延伸" class="headerlink" title="拓展延伸"></a>拓展延伸</h3><p>以上的抽样算法时间复杂度是 O(n)，但不是最优的方法，更优化的算法基于几何分布（geometric distribution），时间复杂度为 O(k + klog(n/k))。由于涉及的数学知识比较多，这里就不列出了，有兴趣的读者可以自行搜索一下。<br>还有一种思路是基于「Fisher–Yates 洗牌算法」的。随机抽取 <code>k</code> 个元素，等价于对所有元素洗牌，然后选取前 <code>k</code> 个。只不过，洗牌算法需要对元素的随机访问，所以只能对数组这类支持随机存储的数据结构有效。<br>另外有一种思路也比较有启发意义：给每一个元素关联一个随机数，然后把每个元素插入一个容量为 <code>k</code> 的二叉堆（优先级队列）按照配对的随机数进行排序，最后剩下的 <code>k</code> 个元素也是随机的。<br>这个方案看起来似乎有点多此一举，因为插入二叉堆需要 O(logk) 的时间复杂度，所以整个抽样算法就需要 O(nlogk) 的复杂度，还不如我们最开始的算法。但是，这种思路可以指导我们解决<strong>加权随机抽样算法</strong>，权重越高，被随机选中的概率相应增大，这种情况在现实生活中是很常见的，比如你不往游戏里充钱，就永远抽不到皮肤。<br>最后，我想说随机算法虽然不多，但其实很有技巧的，读者不妨思考两个常见且看起来很简单的问题：<br>1、如何对带有权重的样本进行加权随机抽取？比如给你一个数组 <code>w</code>，每个元素 <code>w[i]</code> 代表权重，请你写一个算法，按照权重随机抽取索引。比如 <code>w = [1,99]</code>，算法抽到索引 0 的概率是 1%，抽到索引 1 的概率是 99%。<br>2、实现一个生成器类，构造函数传入一个很长的数组，请你实现 <code>randomGet</code> 方法，每次调用随机返回数组中的一个元素，多次调用不能重复返回相同索引的元素。要求不能对该数组进行任何形式的修改，且操作的时间复杂度是 O(1)。<br>这两个问题都是比较困难的，以后有时间我会写一写相关的文章。</p><p><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">上一篇：如何判断回文链表</a><br><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%BA%A7%E4%BD%8D%E8%B0%83%E5%BA%A6">下一篇：如何调度考生的座位</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消失的元素</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%B6%88%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%B6%88%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="如何寻找消失的元素"><a href="#如何寻找消失的元素" class="headerlink" title="如何寻找消失的元素"></a>如何寻找消失的元素</h1><p>之前也有文章写过几个有趣的智力题，今天再聊一道巧妙的题目。<br>题目非常简单：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E7%BC%BA%E5%A4%B1%E5%85%83%E7%B4%A0/title.png"><br>给一个长度为 n 的数组，其索引应该在 <code>[0,n)</code>，但是现在你要装进去 n + 1 个元素 <code>[0,n]</code>，那么肯定有一个元素装不下嘛，请你找出这个缺失的元素。<br>这道题不难的，我们应该很容易想到，把这个数组排个序，然后遍历一遍，不就很容易找到缺失的那个元素了吗？<br>或者说，借助数据结构的特性，用一个 HashSet 把数组里出现的数字都储存下来，再遍历 <code>[0,n]</code> 之间的数字，去 HashSet 中查询，也可以很容易查出那个缺失的元素。<br>排序解法的时间复杂度是 O(NlogN)，HashSet 的解法时间复杂度是 O(N)，但是还需要 O(N) 的空间复杂度存储 HashSet。<br><strong>第三种方法是位运算</strong>。<br>对于异或运算（<code>^</code>），我们知道它有一个特殊性质：一个数和它本身做异或运算结果为 0，一个数和 0 做异或运算还是它本身。<br>而且异或运算满足交换律和结合律，也就是说：<br>2 ^ 3 ^ 2 = 3 ^ (2 ^ 2) = 3 ^ 0 = 3<br>而这道题索就可以通过这些性质巧妙算出缺失的那个元素。比如说 <code>nums = [0,3,1,4]</code>：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E7%BC%BA%E5%A4%B1%E5%85%83%E7%B4%A0/1.jpg"></p><p>为了容易理解，我们假设先把索引补一位，然后让每个元素和自己相等的索引相对应：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E7%BC%BA%E5%A4%B1%E5%85%83%E7%B4%A0/2.jpg"></p><p>这样做了之后，就可以发现除了缺失元素之外，所有的索引和元素都组成一对儿了，现在如果把这个落单的索引 2 找出来，也就找到了缺失的那个元素。<br>如何找这个落单的数字呢，<strong>只要把所有的元素和索引做异或运算，成对儿的数字都会消为 0，只有这个落单的元素会剩下</strong>，也就达到了我们的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 先和新补的索引异或一下</span><br>    res ^= n;<br>    <span class="hljs-comment">// 和其他的元素、索引做异或</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        res ^= i ^ nums[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E7%BC%BA%E5%A4%B1%E5%85%83%E7%B4%A0/3.jpg"><br>由于异或运算满足交换律和结合律，所以总是能把成对儿的数字消去，留下缺失的那个元素的。<br>至此，时间复杂度 O(N)，空间复杂度 O(1)，已经达到了最优，我们是否就应该打道回府了呢？<br>如果这样想，说明我们受算法的毒害太深，随着我们学习的知识越来越多，反而容易陷入思维定式，这个问题其实还有一个特别简单的解法：<strong>等差数列求和公式</strong>。<br>题目的意思可以这样理解：现在有个等差数列 0, 1, 2,…, n，其中少了某一个数字，请你把它找出来。那这个数字不就是 <code>sum(0,1,..n) - sum(nums)</code> 嘛？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">// 公式：(首项 + 末项) * 项数 / 2</span><br>    <span class="hljs-keyword">int</span> expect = (<span class="hljs-number">0</span> + n) * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums) <br>        sum += x;<br>    <span class="hljs-keyword">return</span> expect - sum;<br></code></pre></td></tr></table></figure><p>你看，这种解法应该是最简单的，但说实话，我自己也没想到这个解法，而且我去问了几个大佬，他们也没想到这个最简单的思路。相反，如果去问一个初中生，他也许很快就能想到。<br>做到这一步了，我们是否就应该打道回府了呢？<br>如果这样想，说明我们对细节的把控还差点火候。在用求和公式计算 <code>expect</code> 时，你考虑过<strong>整型溢出</strong>吗？如果相乘的结果太大导致溢出，那么结果肯定是错误的。<br>刚才我们的思路是把两个和都加出来然后相减，为了避免溢出，干脆一边求和一边减算了。很类似刚才位运算解法的思路，仍然假设 <code>nums = [0,3,1,4]</code>，先补一位索引再让元素跟索引配对：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E7%BC%BA%E5%A4%B1%E5%85%83%E7%B4%A0/xor.png"></p><p>我们让每个索引减去其对应的元素，再把相减的结果加起来，不就是那个缺失的元素吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 新补的索引</span><br>    res += n - <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 剩下索引和元素的差加起来</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>        res += i - nums[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于加减法满足交换律和结合律，所以总是能把成对儿的数字消去，留下缺失的那个元素的。<br>至此这道算法题目经历九曲十八弯，终于再也没有什么坑了。</p><p><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%88%A4%E5%AE%9A">上一篇：如何判定括号合法性</a><br><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E7%BC%BA%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0">下一篇：如何寻找缺失和重复的元素</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缺失和重复的元素</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E7%BC%BA%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E7%BC%BA%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>今天就聊一道很看起来简单却十分巧妙的问题，寻找缺失和重复的元素。之前的一篇文章「寻找缺失元素」也写过类似的问题，不过这次的和上次的问题使用的技巧不同。<br>这是 LeetCode 645 题，我来描述一下这个题目：<br>给一个长度为 <code>N</code> 的数组 <code>nums</code>，其中本来装着 <code>[1..N]</code> 这 <code>N</code> 个元素，无序。但是现在出现了一些错误，<code>nums</code> 中的一个元素出现了重复，也就同时导致了另一个元素的缺失。请你写一个算法，找到 <code>nums</code> 中的重复元素和缺失元素的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回两个数字，分别是 &#123;dup, missing&#125;</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span>;<br></code></pre></td></tr></table></figure><p>比如说输入：<code>nums = [1,2,2,4]</code>，算法返回 <code>[2,3]</code>。<br>其实很容易解决这个问题，先遍历一次数组，用一个哈希表记录每个数字出现的次数，然后遍历一次 <code>[1..N]</code>，看看那个元素重复出现，那个元素没有出现，就 OK 了。<br>但问题是，这个常规解法需要一个哈希表，也就是 O(N) 的空间复杂度。你看题目给的条件那么巧，在 <code>[1..N]</code> 的几个数字中恰好有一个重复，一个缺失，<strong>事出反常必有妖</strong>，对吧。<br>O(N) 的时间复杂度遍历数组是无法避免的，所以我们可以想想办法如何降低空间复杂度，是否可以在 O(1) 的空间复杂度之下找到重复和确实的元素呢？</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>这个问题的特点是，每个元素和数组索引有一定的对应关系。<br>我们现在自己改造下问题，<strong>暂且将 <code>nums</code> 中的元素变为 <code>[0..N-1]</code>，这样每个元素就和一个数组索引完全对应了，这样方便理解一些</strong>。<br>如果说 <code>nums</code> 中不存在重复元素和缺失元素，那么每个元素就和唯一一个索引值对应，对吧？<br>现在的问题是，有一个元素重复了，同时导致一个元素缺失了，这会产生什么现象呢？<strong>会导致有两个元素对应到了同一个索引，而且会有一个索引没有元素对应过去</strong>。<br>那么，如果我能够通过某些方法，找到这个重复对应的索引，不就是找到了那个重复元素么？找到那个没有元素对应的索引，不就是找到了那个缺失的元素了么？<br>那么，如何不使用额外空间判断某个索引有多少个元素对应呢？这就是这个问题的精妙之处了：<br><strong>通过将每个索引对应的元素变成负数，以表示这个索引被对应过一次了</strong>：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/dupmissing/1.gif"><br>如果出现重复元素 <code>4</code>，直观结果就是，索引 <code>4</code> 所对应的元素已经是负数了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/dupmissing/2.jpg"><br>对于缺失元素 <code>3</code>，直观结果就是，索引 <code>3</code> 所对应的元素是正数：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/dupmissing/3.jpg"><br>对于这个现象，我们就可以翻译成代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.size();<br>    <span class="hljs-keyword">int</span> dup = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-built_in">abs</span>(nums[i]);<br>        <span class="hljs-comment">// nums[index] 小于 0 则说明重复访问</span><br>        <span class="hljs-keyword">if</span> (nums[index] &lt; <span class="hljs-number">0</span>)<br>            dup = <span class="hljs-built_in">abs</span>(nums[i]);<br>        <span class="hljs-keyword">else</span><br>            nums[index] *= <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> missing = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-comment">// nums[i] 大于 0 则说明没有访问</span><br>        <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>)<br>            missing = i;<br>    <br>    <span class="hljs-keyword">return</span> &#123;dup, missing&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个问题就基本解决了，别忘了我们刚才为了方便分析，假设元素是 <code>[0..N-1]</code>，但题目要求是 <code>[1..N]</code>，所以只要简单修改两处地方即可得到原题的答案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.size();<br>    <span class="hljs-keyword">int</span> dup = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 现在的元素是从 1 开始的</span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-built_in">abs</span>(nums[i]) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[index] &lt; <span class="hljs-number">0</span>)<br>            dup = <span class="hljs-built_in">abs</span>(nums[i]);<br>        <span class="hljs-keyword">else</span><br>            nums[index] *= <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> missing = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 将索引转换成元素</span><br>            missing = i + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">return</span> &#123;dup, missing&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实，元素从 1 开始是有道理的，也必须从一个非零数开始。因为如果元素从 0 开始，那么 0 的相反数还是自己，所以如果数字 0 出现了重复或者缺失，算法就无法判断 0 是否被访问过。我们之前的假设只是为了简化题目，更通俗易懂。</p><h3 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h3><p>对于这种数组问题，<strong>关键点在于元素和索引是成对儿出现的，常用的方法是排序、异或、映射</strong>。<br>映射的思路就是我们刚才的分析，将每个索引和元素映射起来，通过正负号记录某个元素是否被映射。<br>排序的方法也很好理解，对于这个问题，可以想象如果元素都被从小到大排序，如果发现索引对应的元素如果不相符，就可以找到重复和缺失的元素。<br>异或运算也是常用的，因为异或性质 <code>a ^ a = 0, a ^ 0 = a</code>，如果将索引和元素同时异或，就可以消除成对儿的索引和元素，留下的就是重复或者缺失的元素。可以看看前文「寻找缺失元素」，介绍过这种方法。</p><p><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%B6%88%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0">上一篇：如何寻找消失的元素</a><br><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">下一篇：如何判断回文链表</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高频面试系列</title>
      <link href="2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"/>
      <url>2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="高频面试系列"><a href="#高频面试系列" class="headerlink" title="高频面试系列"></a>高频面试系列</h1><ul><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/LRU%E7%AE%97%E6%B3%95">如何实现LRU算法</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%89%93%E5%8D%B0%E7%B4%A0%E6%95%B0">如何高效寻找素数</a></li><li><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">如何计算编辑距离</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/koko%E5%81%B7%E9%A6%99%E8%95%89">如何运用二分查找算法</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%8E%A5%E9%9B%A8%E6%B0%B4">如何高效解决接雨水问题</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">如何去除有序数组的重复元素</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">如何寻找最长回文子串</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">如何k个一组反转链表</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%88%A4%E5%AE%9A">如何判定括号合法性</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%B6%88%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0">如何寻找消失的元素</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E7%BC%BA%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0">如何寻找缺失和重复的元素</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">如何判断回文链表</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7">如何在无限序列中随机抽取元素</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%BA%A7%E4%BD%8D%E8%B0%83%E5%BA%A6">如何调度考生的座位</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3">Union-Find算法详解</a></li><li><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8">Union-Find算法应用</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E7%9A%84%E6%99%BA%E5%8A%9B%E9%A2%98">一行代码就能解决的算法题</a></li><li><a href="/2016/01/01/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E5%AD%90%E5%BA%8F%E5%88%97">二分查找高效判定子序列</a><br>8 说了，本章都是高频面试题，配合前面的动态规划系列，祝各位马到成功！</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之KMP字符匹配算法</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8BKMP%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8BKMP%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>title: 动态规划之KMP字符匹配算法<br>author: 远方<br>tags:</p><ul><li>LeetCode</li><li>算法<br>categories:</li><li>LeetCode破局攻略<br>date: 2016-01-01 19:20:00</li></ul><hr><h1 id="动态规划之KMP字符匹配算法"><a href="#动态规划之KMP字符匹配算法" class="headerlink" title="动态规划之KMP字符匹配算法"></a>动态规划之KMP字符匹配算法</h1><p>KMP 算法（Knuth-Morris-Pratt 算法）是一个著名的字符串匹配算法，效率很高，但是确实有点复杂。<br>很多读者抱怨 KMP 算法无法理解，这很正常，想到大学教材上关于 KMP 算法的讲解，也不知道有多少未来的 Knuth、Morris、Pratt 被提前劝退了。有一些优秀的同学通过手推 KMP 算法的过程来辅助理解该算法，这是一种办法，不过本文要从逻辑层面帮助读者理解算法的原理。十行代码之间，KMP 灰飞烟灭。<br><strong>先在开头约定，本文用 <code>pat</code> 表示模式串，长度为 <code>M</code>，<code>txt</code> 表示文本串，长度为 <code>N</code>。KMP 算法是在 <code>txt</code> 中查找子串 <code>pat</code>，如果存在，返回这个子串的起始索引，否则返回 -1</strong>。<br>为什么我认为 KMP 算法就是个动态规划问题呢，等会再解释。对于动态规划，之前多次强调了要明确 <code>dp</code> 数组的含义，而且同一个问题可能有不止一种定义 <code>dp</code> 数组含义的方法，不同的定义会有不同的解法。<br>读者见过的 KMP 算法应该是，一波诡异的操作处理 <code>pat</code> 后形成一个一维的数组 <code>next</code>，然后根据这个数组经过又一波复杂操作去匹配 <code>txt</code>。时间复杂度 O(N)，空间复杂度 O(M)。其实它这个 <code>next</code> 数组就相当于 <code>dp</code> 数组，其中元素的含义跟 <code>pat</code> 的前缀和后缀有关，判定规则比较复杂，不好理解。<strong>本文则用一个二维的 <code>dp</code> 数组（但空间复杂度还是 O(M)），重新定义其中元素的含义，使得代码长度大大减少，可解释性大大提高</strong>。<br>PS：本文的代码参考《算法4》，原代码使用的数组名称是 <code>dfa</code>（确定有限状态机），因为我们的公众号之前有一系列动态规划的文章，就不说这么高大上的名词了，我对书中代码进行了一点修改，并沿用 <code>dp</code> 数组的名称。</p><h3 id="一、KMP-算法概述"><a href="#一、KMP-算法概述" class="headerlink" title="一、KMP 算法概述"></a>一、KMP 算法概述</h3><p>首先还是简单介绍一下 KMP 算法和暴力匹配算法的不同在哪里，难点在哪里，和动态规划有啥关系。<br>暴力的字符串匹配算法很容易写，看一下它的运行逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 暴力匹配（伪码）</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String pat, String txt)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> M = pat.length;<br>    <span class="hljs-keyword">int</span> N = txt.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N - M; i++) &#123;<br>        <span class="hljs-keyword">int</span> j;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; M; j++) &#123;<br>            <span class="hljs-keyword">if</span> (pat[j] != txt[i+j])<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// pat 全都匹配了</span><br>        <span class="hljs-keyword">if</span> (j == M) <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-comment">// txt 中不存在 pat 子串</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于暴力算法，如果出现不匹配字符，同时回退 <code>txt</code> 和 <code>pat</code> 的指针，嵌套 for 循环，时间复杂度 $O(MN)$，空间复杂度$O(1)$。最主要的问题是，如果字符串中重复的字符比较多，该算法就显得很蠢。<br>比如 txt = “aaacaaab” pat = “aaab”：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/1.gif" alt="brutal"><br>很明显，<code>pat</code> 中根本没有字符 c，根本没必要回退指针 <code>i</code>，暴力解法明显多做了很多不必要的操作。<br>KMP 算法的不同之处在于，它会花费空间来记录一些信息，在上述情况中就会显得很聪明：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/2.gif" alt="kmp1"><br>再比如类似的 txt = “aaaaaaab” pat = “aaab”，暴力解法还会和上面那个例子一样蠢蠢地回退指针 <code>i</code>，而 KMP 算法又会耍聪明：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/3.gif" alt="kmp2"><br>因为 KMP 算法知道字符 b 之前的字符 a 都是匹配的，所以每次只需要比较字符 b 是否被匹配就行了。<br><strong>KMP 算法永不回退 <code>txt</code> 的指针 <code>i</code>，不走回头路（不会重复扫描 <code>txt</code>），而是借助 <code>dp</code> 数组中储存的信息把 <code>pat</code> 移到正确的位置继续匹配</strong>，时间复杂度只需 O(N)，用空间换时间，所以我认为它是一种动态规划算法。<br>KMP 算法的难点在于，如何计算 <code>dp</code> 数组中的信息？如何根据这些信息正确地移动 <code>pat</code> 的指针？这个就需要<strong>确定有限状态自动机</strong>来辅助了，别怕这种高大上的文学词汇，其实和动态规划的 <code>dp</code> 数组如出一辙，等你学会了也可以拿这个词去吓唬别人。<br>还有一点需要明确的是：<strong>计算这个 <code>dp</code> 数组，只和 <code>pat</code> 串有关</strong>。意思是说，只要给我个 <code>pat</code>，我就能通过这个模式串计算出 <code>dp</code> 数组，然后你可以给我不同的 <code>txt</code>，我都不怕，利用这个 <code>dp</code> 数组我都能在 O(N) 时间完成字符串匹配。<br>具体来说，比如上文举的两个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">txt1 = <span class="hljs-string">&quot;aaacaaab&quot;</span> <br>pat = <span class="hljs-string">&quot;aaab&quot;</span><br>txt2 = <span class="hljs-string">&quot;aaaaaaab&quot;</span> <br>pat = <span class="hljs-string">&quot;aaab&quot;</span><br></code></pre></td></tr></table></figure><p>我们的 <code>txt</code> 不同，但是 <code>pat</code> 是一样的，所以 KMP 算法使用的 <code>dp</code> 数组是同一个。<br>只不过对于 <code>txt1</code> 的下面这个即将出现的未匹配情况：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/txt1.jpg"><br><code>dp</code> 数组指示 <code>pat</code> 这样移动：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/txt2.jpg"><br>PS：这个<code>j</code> 不要理解为索引，它的含义更准确地说应该是<strong>状态</strong>（state），所以它会出现这个奇怪的位置，后文会详述。<br>而对于 <code>txt2</code> 的下面这个即将出现的未匹配情况：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/txt3.jpg"><br><code>dp</code> 数组指示 <code>pat</code> 这样移动：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/txt4.jpg"><br>明白了 <code>dp</code> 数组只和 <code>pat</code> 有关，那么我们这样设计 KMP 算法就会比较漂亮：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KMP</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] dp;<br>    <span class="hljs-keyword">private</span> String pat;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">KMP</span><span class="hljs-params">(String pat)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.pat = pat;<br>        <span class="hljs-comment">// 通过 pat 构建 dp 数组</span><br>        <span class="hljs-comment">// 需要 O(M) 时间</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String txt)</span> </span>&#123;<br>        <span class="hljs-comment">// 借助 dp 数组去匹配 txt</span><br>        <span class="hljs-comment">// 需要 O(N) 时间</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，当我们需要用同一 <code>pat</code> 去匹配不同 <code>txt</code> 时，就不需要浪费时间构造 <code>dp</code> 数组了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">KMP kmp = <span class="hljs-keyword">new</span> KMP(<span class="hljs-string">&quot;aaab&quot;</span>);<br><span class="hljs-keyword">int</span> pos1 = kmp.search(<span class="hljs-string">&quot;aaacaaab&quot;</span>); <span class="hljs-comment">//4</span><br><span class="hljs-keyword">int</span> pos2 = kmp.search(<span class="hljs-string">&quot;aaaaaaab&quot;</span>); <span class="hljs-comment">//4</span><br></code></pre></td></tr></table></figure><h3 id="二、状态机概述"><a href="#二、状态机概述" class="headerlink" title="二、状态机概述"></a>二、状态机概述</h3><p>为什么说 KMP 算法和状态机有关呢？是这样的，我们可以认为 <code>pat</code> 的匹配就是状态的转移。比如当 pat = “ABABC”：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/state.jpg"><br>如上图，圆圈内的数字就是状态，状态 0 是起始状态，状态 5（<code>pat.length</code>）是终止状态。开始匹配时 <code>pat</code> 处于起始状态，一旦转移到终止状态，就说明在 <code>txt</code> 中找到了 <code>pat</code>。比如说当前处于状态 2，就说明字符 “AB” 被匹配：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/state2.jpg"><br>另外，处于不同状态时，<code>pat</code> 状态转移的行为也不同。比如说假设现在匹配到了状态 4，如果遇到字符 A 就应该转移到状态 3，遇到字符 C 就应该转移到状态 5，如果遇到字符 B 就应该转移到状态 0：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/state4.jpg"><br>具体什么意思呢，我们来一个个举例看看。用变量 <code>j</code> 表示指向当前状态的指针，当前 <code>pat</code> 匹配到了状态 4：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/exp1.jpg"><br>如果遇到了字符 “A”，根据箭头指示，转移到状态 3 是最聪明的：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/exp3.jpg"><br>如果遇到了字符 “B”，根据箭头指示，只能转移到状态 0（一夜回到解放前）：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/exp5.jpg"><br>如果遇到了字符 “C”，根据箭头指示，应该转移到终止状态 5，这也就意味着匹配完成：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/exp7.jpg"></p><p>当然了，还可能遇到其他字符，比如 Z，但是显然应该转移到起始状态 0，因为 <code>pat</code> 中根本都没有字符 Z：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/z.jpg"><br>这里为了清晰起见，我们画状态图时就把其他字符转移到状态 0 的箭头省略，只画 <code>pat</code> 中出现的字符的状态转移：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/allstate.jpg"><br>KMP 算法最关键的步骤就是构造这个状态转移图。<strong>要确定状态转移的行为，得明确两个变量，一个是当前的匹配状态，另一个是遇到的字符</strong>；确定了这两个变量后，就可以知道这个情况下应该转移到哪个状态。<br>下面看一下 KMP 算法根据这幅状态转移图匹配字符串 <code>txt</code> 的过程：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/kmp.gif"><br><strong>请记住这个 GIF 的匹配过程，这就是 KMP 算法的核心逻辑</strong>！<br>为了描述状态转移图，我们定义一个二维 dp 数组，它的含义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[j][c] = next<br><span class="hljs-number">0</span> &lt;= j &lt; M，代表当前的状态<br><span class="hljs-number">0</span> &lt;= c &lt; <span class="hljs-number">256</span>，代表遇到的字符（ASCII 码）<br><span class="hljs-number">0</span> &lt;= next &lt;= M，代表下一个状态<br>dp[<span class="hljs-number">4</span>][<span class="hljs-string">&#x27;A&#x27;</span>] = <span class="hljs-number">3</span> 表示：<br>当前是状态 <span class="hljs-number">4</span>，如果遇到字符 A，<br>pat 应该转移到状态 <span class="hljs-number">3</span><br>dp[<span class="hljs-number">1</span>][<span class="hljs-string">&#x27;B&#x27;</span>] = <span class="hljs-number">2</span> 表示：<br>当前是状态 <span class="hljs-number">1</span>，如果遇到字符 B，<br>pat 应该转移到状态 <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>根据我们这个 dp 数组的定义和刚才状态转移的过程，我们可以先写出 KMP 算法的 search 函数代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String txt)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> M = pat.length();<br>    <span class="hljs-keyword">int</span> N = txt.length();<br>    <span class="hljs-comment">// pat 的初始态为 0</span><br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-comment">// 当前是状态 j，遇到字符 txt[i]，</span><br>        <span class="hljs-comment">// pat 应该转移到哪个状态？</span><br>        j = dp[j][txt.charAt(i)];<br>        <span class="hljs-comment">// 如果达到终止态，返回匹配开头的索引</span><br>        <span class="hljs-keyword">if</span> (j == M) <span class="hljs-keyword">return</span> i - M + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 没到达终止态，匹配失败</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，应该还是很好理解的吧，<code>dp</code> 数组就是我们刚才画的那幅状态转移图，如果不清楚的话回去看下 GIF 的算法演进过程。下面讲解：如何通过 <code>pat</code> 构建这个 <code>dp</code> 数组？</p><h3 id="三、构建状态转移图"><a href="#三、构建状态转移图" class="headerlink" title="三、构建状态转移图"></a>三、构建状态转移图</h3><p>回想刚才说的：<strong>要确定状态转移的行为，必须明确两个变量，一个是当前的匹配状态，另一个是遇到的字符</strong>，而且我们已经根据这个逻辑确定了 <code>dp</code> 数组的含义，那么构造 <code>dp</code> 数组的框架就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt;= j &lt; M: <span class="hljs-comment"># 状态</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt;= c &lt; <span class="hljs-number">256</span>: <span class="hljs-comment"># 字符</span><br>        dp[j][c] = next<br></code></pre></td></tr></table></figure><p>这个 next 状态应该怎么求呢？显然，<strong>如果遇到的字符 <code>c</code> 和 <code>pat[j]</code> 匹配的话</strong>，状态就应该向前推进一个，也就是说 <code>next = j + 1</code>，我们不妨称这种情况为<strong>状态推进</strong>：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/forward.jpg"><br><strong>如果字符 <code>c</code> 和 <code>pat[j]</code> 不匹配的话</strong>，状态就要回退（或者原地不动），我们不妨称这种情况为<strong>状态重启</strong>：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/back.jpg"><br>那么，如何得知在哪个状态重启呢？解答这个问题之前，我们再定义一个名字：<strong>影子状态</strong>（我编的名字），用变量 <code>X</code> 表示。<strong>所谓影子状态，就是和当前状态具有相同的前缀</strong>。比如下面这种情况：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/shadow.jpg"><br>当前状态 <code>j = 4</code>，其影子状态为 <code>X = 2</code>，它们都有相同的前缀 “AB”。因为状态 <code>X</code> 和状态 <code>j</code> 存在相同的前缀，所以当状态 <code>j</code> 准备进行状态重启的时候（遇到的字符 <code>c</code> 和 <code>pat[j]</code> 不匹配），可以通过 <code>X</code> 的状态转移图来获得<strong>最近的重启位置</strong>。<br>比如说刚才的情况，如果状态 <code>j</code> 遇到一个字符 “A”，应该转移到哪里呢？首先只有遇到 “C” 才能推进状态，遇到 “A” 显然只能进行状态重启。<strong>状态 <code>j</code> 会把这个字符委托给状态 <code>X</code> 处理，也就是 <code>dp[j][&#39;A&#39;] = dp[X][&#39;A&#39;]</code>**：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/shadow1.jpg"><br>为什么这样可以呢？因为：既然 <code>j</code> 这边已经确定字符 “A” 无法推进状态，</strong>只能回退<strong>，而且 KMP 就是要</strong>尽可能少的回退**，以免多余的计算。那么 <code>j</code> 就可以去问问和自己具有相同前缀的 <code>X</code>，如果 <code>X</code> 遇见 “A” 可以进行「状态推进」，那就转移过去，因为这样回退最少。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/A.gif"><br>当然，如果遇到的字符是 “B”，状态 <code>X</code> 也不能进行「状态推进」，只能回退，<code>j</code> 只要跟着 <code>X</code> 指引的方向回退就行了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/shadow2.jpg"><br>你也许会问，这个 <code>X</code> 怎么知道遇到字符 “B” 要回退到状态 0 呢？因为 <code>X</code> 永远跟在 <code>j</code> 的身后，状态 <code>X</code> 如何转移，在之前就已经算出来了。动态规划算法不就是利用过去的结果解决现在的问题吗？<br>这样，我们就细化一下刚才的框架代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">int X <span class="hljs-comment"># 影子状态</span><br><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt;= j &lt; M:<br>    <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt;= c &lt; <span class="hljs-number">256</span>:<br>        <span class="hljs-keyword">if</span> c == pat[j]:<br>            <span class="hljs-comment"># 状态推进</span><br>            dp[j][c] = j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>: <br>            <span class="hljs-comment"># 状态重启</span><br>            <span class="hljs-comment"># 委托 X 计算重启位置</span><br>            dp[j][c] = dp[X][c] <br></code></pre></td></tr></table></figure><h3 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h3><p>如果之前的内容你都能理解，恭喜你，现在就剩下一个问题：影子状态 <code>X</code> 是如何得到的呢？下面先直接看完整代码吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KMP</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] dp;<br>    <span class="hljs-keyword">private</span> String pat;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">KMP</span><span class="hljs-params">(String pat)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.pat = pat;<br>        <span class="hljs-keyword">int</span> M = pat.length();<br>        <span class="hljs-comment">// dp[状态][字符] = 下个状态</span><br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[M][<span class="hljs-number">256</span>];<br>        <span class="hljs-comment">// base case</span><br>        dp[<span class="hljs-number">0</span>][pat.charAt(<span class="hljs-number">0</span>)] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 影子状态 X 初始为 0</span><br>        <span class="hljs-keyword">int</span> X = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 当前状态 j 从 1 开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; M; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">256</span>; c++) &#123;<br>                <span class="hljs-keyword">if</span> (pat.charAt(j) == c) <br>                    dp[j][c] = j + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <br>                    dp[j][c] = dp[X][c];<br>            &#125;<br>            <span class="hljs-comment">// 更新影子状态</span><br>            X = dp[X][pat.charAt(j)];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String txt)</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先解释一下这一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// base case</span><br>dp[<span class="hljs-number">0</span>][pat.charAt(<span class="hljs-number">0</span>)] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这行代码是 base case，只有遇到 pat[0] 这个字符才能使状态从 0 转移到 1，遇到其它字符的话还是停留在状态 0（Java 默认初始化数组全为 0）。<br>影子状态 <code>X</code> 是先初始化为 0，然后随着 <code>j</code> 的前进而不断更新的。下面看看到底应该**如何更新影子状态 <code>X</code>**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> X = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; M; j++) &#123;<br>    ...<br>    <span class="hljs-comment">// 更新影子状态</span><br>    <span class="hljs-comment">// 当前是状态 X，遇到字符 pat[j]，</span><br>    <span class="hljs-comment">// pat 应该转移到哪个状态？</span><br>    X = dp[X][pat.charAt(j)];<br>&#125;<br></code></pre></td></tr></table></figure><p>更新 <code>X</code> 其实和 <code>search</code> 函数中更新状态 <code>j</code> 的过程是非常相似的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    <span class="hljs-comment">// 当前是状态 j，遇到字符 txt[i]，</span><br>    <span class="hljs-comment">// pat 应该转移到哪个状态？</span><br>    j = dp[j][txt.charAt(i)];<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中的原理非常微妙</strong>，注意代码中 for 循环的变量初始值，可以这样理解：后者是在 <code>txt</code> 中匹配 <code>pat</code>，前者是在 <code>pat</code> 中匹配 <code>pat[1..end]</code>，状态 <code>X</code> 总是落后状态 <code>j</code> 一个状态，与 <code>j</code> 具有最长的相同前缀。所以我把 <code>X</code> 比喻为影子状态，似乎也有一点贴切。<br>另外，构建 dp 数组是根据 base case <code>dp[0][..]</code> 向后推演。这就是我认为 KMP 算法就是一种动态规划算法的原因。<br>下面来看一下状态转移图的完整构造过程，你就能理解状态 <code>X</code> 作用之精妙了：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/kmp/dfa.gif"><br>至此，KMP 算法的核心终于写完啦啦啦啦！看下 KMP 算法的完整代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KMP</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] dp;<br>    <span class="hljs-keyword">private</span> String pat;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">KMP</span><span class="hljs-params">(String pat)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.pat = pat;<br>        <span class="hljs-keyword">int</span> M = pat.length();<br>        <span class="hljs-comment">// dp[状态][字符] = 下个状态</span><br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[M][<span class="hljs-number">256</span>];<br>        <span class="hljs-comment">// base case</span><br>        dp[<span class="hljs-number">0</span>][pat.charAt(<span class="hljs-number">0</span>)] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 影子状态 X 初始为 0</span><br>        <span class="hljs-keyword">int</span> X = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 构建状态转移图（稍改的更紧凑了）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; M; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">256</span>; c++)<br>                dp[j][c] = dp[X][c];<br>            dp[j][pat.charAt(j)] = j + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 更新影子状态</span><br>            X = dp[X][pat.charAt(j)];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(String txt)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> M = pat.length();<br>        <span class="hljs-keyword">int</span> N = txt.length();<br>        <span class="hljs-comment">// pat 的初始态为 0</span><br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            <span class="hljs-comment">// 计算 pat 的下一个状态</span><br>            j = dp[j][txt.charAt(i)];<br>            <span class="hljs-comment">// 到达终止态，返回结果</span><br>            <span class="hljs-keyword">if</span> (j == M) <span class="hljs-keyword">return</span> i - M + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 没到达终止态，匹配失败</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过之前的详细举例讲解，你应该可以理解这段代码的含义了，当然你也可以把 KMP 算法写成一个函数。核心代码也就是两个函数中 for 循环的部分，数一下有超过十行吗？</p><h3 id="五、最后总结"><a href="#五、最后总结" class="headerlink" title="五、最后总结"></a>五、最后总结</h3><p>传统的 KMP 算法是使用一个一维数组 <code>next</code> 记录前缀信息，而本文是使用一个二维数组 <code>dp</code> 以状态转移的角度解决字符匹配问题，但是空间复杂度仍然是 O(256M) = O(M)。<br>在 <code>pat</code> 匹配 <code>txt</code> 的过程中，只要明确了「当前处在哪个状态」和「遇到的字符是什么」这两个问题，就可以确定应该转移到哪个状态（推进或回退）。<br>对于一个模式串 <code>pat</code>，其总共就有 M 个状态，对于 ASCII 字符，总共不会超过 256 种。所以我们就构造一个数组 <code>dp[M][256]</code> 来包含所有情况，并且明确 <code>dp</code> 数组的含义：<br><code>dp[j][c] = next</code> 表示，当前是状态 <code>j</code>，遇到了字符 <code>c</code>，应该转移到状态 <code>next</code>。<br>明确了其含义，就可以很容易写出 search 函数的代码。<br>对于如何构建这个 <code>dp</code> 数组，需要一个辅助状态 <code>X</code>，它永远比当前状态 <code>j</code> 落后一个状态，拥有和 <code>j</code> 最长的相同前缀，我们给它起了个名字叫「影子状态」。<br>在构建当前状态 <code>j</code> 的转移方向时，只有字符 <code>pat[j]</code> 才能使状态推进（<code>dp[j][pat[j]] = j+1</code>）；而对于其他字符只能进行状态回退，应该去请教影子状态 <code>X</code> 应该回退到哪里（<code>dp[j][other] = dp[X][other]</code>，其中 <code>other</code> 是除了 <code>pat[j]</code> 之外所有字符）。<br>对于影子状态 <code>X</code>，我们把它初始化为 0，并且随着 <code>j</code> 的前进进行更新，更新的方式和 search 过程更新 <code>j</code> 的过程非常相似（<code>X = dp[X][pat[j]]</code>）。<br>KMP 算法也就是动态规划那点事，我们的公众号文章目录有一系列专门讲动态规划的，而且都是按照一套框架来的，无非就是描述问题逻辑，明确 <code>dp</code> 数组含义，定义 base case 这点破事。希望这篇文章能让大家对动态规划有更深的理解。</p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98">上一篇：贪心算法之区间调度问题</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%9B%A2%E7%81%AD%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98">下一篇：团灭 LeetCode 股票买卖问题</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划详解进阶</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划详解"><a href="#动态规划详解" class="headerlink" title="动态规划详解"></a>动态规划详解</h1><p>这篇文章是我们号半年前一篇 200 多赞赏的成名之作「动态规划详解」的进阶版。由于账号迁移的原因，旧文无法被搜索到，所以我润色了本文，并添加了更多干货内容，希望本文成为解决动态规划的一部「指导方针」。</p><p>再说句题外话，我们的公众号开号至今写了起码十几篇文章拆解动态规划问题，我都整理到了公众号菜单的「文章目录」中，<strong>它们都提到了动态规划的解题框架思维，本文就系统总结一下</strong>。这段时间本人也从非科班小白成长到刷通半个 LeetCode，所以我总结的套路可能不适合各路大神，但是应该适合大众，毕竟我自己也是一路摸爬滚打过来的。</p><p>算法技巧就那几个套路，如果你心里有数，就会轻松很多，本文就来扒一扒动态规划的裤子，形成一套解决这类问题的思维框架。废话不多说了，上干货。</p><p><strong>动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离呀等等。</p><p>既然是要求最值，核心问题是什么呢？<strong>求解动态规划的核心问题是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。</p><p>动态规划就这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！</p><p>首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p><p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p><p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程</strong>」才能正确地穷举。</p><p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：</p><p>明确「状态」 -&gt; 定义 dp 数组/函数的含义 -&gt; 明确「选择」-&gt; 明确 base case。</p><p>下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。</p><p>请读者不要嫌弃这个例子简单，<strong>只有简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙</strong>。想要困难的例子，历史文章里有的是。</p><h3 id="一、斐波那契数列"><a href="#一、斐波那契数列" class="headerlink" title="一、斐波那契数列"></a>一、斐波那契数列</h3><p><strong>1、暴力递归</strong></p><p>斐波那契数列的数学形式就是递归的，写成代码就是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (N == <span class="hljs-number">1</span> || N == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> fib(N - <span class="hljs-number">1</span>) + fib(N - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树。</p><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/1.jpg"></p><p>这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><p><strong>递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间。</strong></p><p>子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为 O(2^n)，指数级别，爆炸。</p><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p><p><strong>2、带备忘录的递归解法</strong></p><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 备忘录全初始化为 0</span><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">memo</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-comment">// 初始化最简情况</span><br>    <span class="hljs-keyword">return</span> helper(memo, N);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; memo, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// base case </span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 已经计算过</span><br>    <span class="hljs-keyword">if</span> (memo[n] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[n];<br>    memo[n] = helper(memo, n - <span class="hljs-number">1</span>) + <br>                helper(memo, n - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> memo[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/2.jpg"></p><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/3.jpg"></p><p>递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间。</p><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p><p>至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 触底，然后逐层返回答案，这就叫「自顶向下」。</p><p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始往上推，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><p><strong>3、dp 数组的迭代解法</strong></p><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-comment">// base case</span><br>    dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= N; i++)<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">return</span> dp[N];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/4.jpg"></p><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/fib.png"></p><p>为啥叫「状态转移方程」？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程</strong>，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> || n == <span class="hljs-number">1</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> prev = <span class="hljs-number">1</span>, curr = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">int</span> sum = prev + curr;<br>        prev = curr;<br>        curr = sum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> curr;<br>&#125;<br></code></pre></td></tr></table></figure><p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在演示算法设计螺旋上升的过程。下面，看第二个例子，凑零钱问题。</p><h3 id="二、凑零钱问题"><a href="#二、凑零钱问题" class="headerlink" title="二、凑零钱问题"></a>二、凑零钱问题</h3><p>先看下题目：给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// coins 中是可选硬币面值，amount 是目标金额</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span></span>;<br></code></pre></td></tr></table></figure><p>比如说 <code>k = 3</code>，面值分别为 1，2，5，总金额 <code>amount = 11</code>。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。</p><p>你认为计算机应该如何解决这个问题？显然，就是把所有肯能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。</p><p><strong>1、暴力递归</strong></p><p>首先，这个问题是动态规划问题，因为它具有「最优子结构」的。<strong>要符合「最优子结构」，子问题间必须互相独立</strong>。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。</p><p>比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p><p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案，因为硬币的数量是没有限制的，子问题之间没有相互制，是互相独立的。</p><p>那么，既然知道了这是个动态规划问题，就要思考<strong>如何列出正确的状态转移方程</strong>？</p><p><strong>先确定「状态」</strong>，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额 <code>amount</code>。</p><p><strong>然后确定 <code>dp</code> 函数的定义</strong>：当前的目标金额是 <code>n</code>，至少需要 <code>dp(n)</code> 个硬币凑出该金额。</p><p><strong>然后确定「选择」并择优</strong>，也就是对于每个状态，可以做出什么选择改变当前状态。具体到这个问题，无论当的目标金额是多少，选择就是从面额列表 <code>coins</code> 中选择一个硬币，然后目标金额就会减少：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 伪码框架</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coinChange</span>(<span class="hljs-params">coins: List[int], amount: int</span>):</span><br>    <span class="hljs-comment"># 定义：要凑出金额 n，至少要 dp(n) 个硬币</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">n</span>):</span><br>        <span class="hljs-comment"># 做选择，选择需要硬币最少的那个结果</span><br>        <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:<br>            res = min(res, <span class="hljs-number">1</span> + dp(n - coin))<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-comment"># 我们要求的问题是 dp(amount)</span><br>    <span class="hljs-keyword">return</span> dp(amount)<br></code></pre></td></tr></table></figure><p><strong>最后明确 base case</strong>，显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coinChange</span>(<span class="hljs-params">coins: List[int], amount: int</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">n</span>):</span><br>        <span class="hljs-comment"># base case</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        <span class="hljs-comment"># 求最小值，所以初始化为正无穷</span><br>        res = float(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>        <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:<br>            subproblem = dp(n - coin)<br>            <span class="hljs-comment"># 子问题无解，跳过</span><br>            <span class="hljs-keyword">if</span> subproblem == <span class="hljs-number">-1</span>: <span class="hljs-keyword">continue</span><br>            res = min(res, <span class="hljs-number">1</span> + subproblem)<br><br>        <span class="hljs-keyword">return</span> res <span class="hljs-keyword">if</span> res != float(<span class="hljs-string">&#x27;INF&#x27;</span>) <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span><br>    <br>    <span class="hljs-keyword">return</span> dp(amount)<br></code></pre></td></tr></table></figure><p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/coin.png"></p><p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 <code>amount = 11, coins = &#123;1,2,5&#125;</code> 时画出递归树看看：</p><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/5.jpg"></p><p><strong>时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p><p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p><p><strong>2、带备忘录的递归</strong></p><p>只需要稍加修改，就可以通过备忘录消除子问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coinChange</span>(<span class="hljs-params">coins: List[int], amount: int</span>):</span><br>    <span class="hljs-comment"># 备忘录</span><br>    memo = dict()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">n</span>):</span><br>        <span class="hljs-comment"># 查备忘录，避免重复计算</span><br>        <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> memo: <span class="hljs-keyword">return</span> memo[n]<br><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        res = float(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>        <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:<br>            subproblem = dp(n - coin)<br>            <span class="hljs-keyword">if</span> subproblem == <span class="hljs-number">-1</span>: <span class="hljs-keyword">continue</span><br>            res = min(res, <span class="hljs-number">1</span> + subproblem)<br>        <br>        <span class="hljs-comment"># 记入备忘录</span><br>        memo[n] = res <span class="hljs-keyword">if</span> res != float(<span class="hljs-string">&#x27;INF&#x27;</span>) <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span><br>        <span class="hljs-keyword">return</span> memo[n]<br>    <br>    <span class="hljs-keyword">return</span> dp(amount)<br></code></pre></td></tr></table></figure><p>不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p><p><strong>3、dp 数组的迭代解法</strong></p><p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，<code>dp</code> 数组的定义和刚才 <code>dp</code> 函数类似，定义也是一样的：</p><p><strong><code>dp[i] = x</code> 表示，当目标金额为 <code>i</code> 时，至少需要 <code>x</code> 枚硬币</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, amount + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-comment">// base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dp.size(); i++) &#123;<br>        <span class="hljs-comment">// 内层 for 在求所有子问题 + 1 的最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;<br>            <span class="hljs-comment">// 子问题无解，跳过</span><br>            <span class="hljs-keyword">if</span> (i - coin &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            dp[i] = min(dp[i], <span class="hljs-number">1</span> + dp[i - coin]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (dp[amount] == amount + <span class="hljs-number">1</span>) ? <span class="hljs-number">-1</span> : dp[amount];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/6.jpg"></p><p>PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p><h3 id="三、最后总结"><a href="#三、最后总结" class="headerlink" title="三、最后总结"></a>三、最后总结</h3><p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p><p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p><p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p><p><strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%954">上一篇：学习数据结构和算法读什么书</a></p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84">下一篇：动态规划答疑篇</a></p><p><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>团灭股票问题</title>
      <link href="2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%9B%A2%E7%81%AD%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
      <url>2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%9B%A2%E7%81%AD%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>title: 团灭股票问题<br>author: 远方<br>tags:</p><ul><li>LeetCode</li><li>算法<br>categories:</li><li>LeetCode破局攻略<br>date: 2016-01-01 19:20:00</li></ul><hr><h1 id="团灭-LeetCode-股票买卖问题"><a href="#团灭-LeetCode-股票买卖问题" class="headerlink" title="团灭 LeetCode 股票买卖问题"></a>团灭 LeetCode 股票买卖问题</h1><p>很多读者抱怨 LeetCode 的股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？<strong>所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变</strong>。<br>这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。<br>PS：本文参考自<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39038">英文版 LeetCode 的一篇题解</a>。<br>先随便抽出一道题，看看别人的解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(prices.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> s1=-prices[<span class="hljs-number">0</span>],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;<br>        <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;prices.size();++i) &#123;            <br>        s1 = max(s1, -prices[i]);<br>        s2 = max(s2, s1+prices[i]);<br>        s3 = max(s3, s2-prices[i]);<br>        s4 = max(s4, s3+prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max(<span class="hljs-number">0</span>,s4);<br>&#125;<br></code></pre></td></tr></table></figure><p>能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。<br>本文就来告诉你这个框架，然后带着你一道一道秒杀。这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。<br>这 6 道题目是有共性的，我就抽出来第 4 道题目，因为这道题是一个最泛化的形式，其他的问题都是这个形式的简化，看下题目：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/title.png"><br>第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。<br>如果你还不熟悉题目，可以去 LeetCode 查看这些题目的内容，本文为了节省篇幅，就不列举这些题目的具体内容了。下面言归正传，开始解题。<br><strong>一、穷举框架</strong><br>首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。<br>递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。<br>而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 状态<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> 状态<span class="hljs-number">1</span>的所有取值：<br>    <span class="hljs-keyword">for</span> 状态<span class="hljs-number">2</span> <span class="hljs-keyword">in</span> 状态<span class="hljs-number">2</span>的所有取值：<br>        <span class="hljs-keyword">for</span> ...<br>            dp[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...] = 择优(选择<span class="hljs-number">1</span>，选择<span class="hljs-number">2.</span>..)<br></code></pre></td></tr></table></figure><p>比如说这个问题，<strong>每天都有三种「选择」</strong>：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。<br>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。<strong>这个问题的「状态」有三个</strong>，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[i][k][<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>]<br><span class="hljs-number">0</span> &lt;= i &lt;= n<span class="hljs-number">-1</span>, <span class="hljs-number">1</span> &lt;= k &lt;= K<br>n 为天数，大 K 为最多交易数<br>此问题共 n × K × <span class="hljs-number">2</span> 种状态，全部穷举就能搞定。<br><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt;= i &lt; n:<br>    <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> &lt;= k &lt;= K:<br>        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;:<br>            dp[i][k][s] = max(buy, sell, rest)<br></code></pre></td></tr></table></figure><p>而且我们可以用自然语言描述出每一个状态的含义，比如说 <code>dp[3][2][1]</code> 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 <code>dp[2][3][0]</code> 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？<br>我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。<br>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。<br><strong>二、状态转移框架</strong><br>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/1.png"><br>通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">dp[i][k][0] &#x3D; max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])<br>              max(   选择 rest  ,             选择 sell      )<br>解释：今天我没有持有股票，有两种可能：<br>要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；<br>要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。<br>dp[i][k][1] &#x3D; max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])<br>              max(   选择 rest  ,           选择 buy         )<br>解释：今天我持有着股票，有两种可能：<br>要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；<br>要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。<br></code></pre></td></tr></table></figure><p>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。<br>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。<strong>如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。</strong>不过还差最后一点点，就是定义 base case，即最简单的情况。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">dp[-1][k][0] &#x3D; 0<br>解释：因为 i 是从 0 开始的，所以 i &#x3D; -1 意味着还没有开始，这时候的利润当然是 0 。<br>dp[-1][k][1] &#x3D; -infinity<br>解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。<br>dp[i][0][0] &#x3D; 0<br>解释：因为 k 是从 1 开始的，所以 k &#x3D; 0 意味着根本不允许交易，这时候利润当然是 0 。<br>dp[i][0][1] &#x3D; -infinity<br>解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。<br></code></pre></td></tr></table></figure><p>把上面的状态转移方程总结一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">base case：<br>dp[-1][k][0] &#x3D; dp[i][0][0] &#x3D; 0<br>dp[-1][k][1] &#x3D; dp[i][0][1] &#x3D; -infinity<br>状态转移方程：<br>dp[i][k][0] &#x3D; max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])<br>dp[i][k][1] &#x3D; max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])<br></code></pre></td></tr></table></figure><p>读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。<br><strong>三、秒杀题目</strong><br><strong>第一题，k = 1</strong><br>直接套状态转移方程，根据 base case，可以做一些化简：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">dp[i][1][0] &#x3D; max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])<br>dp[i][1][1] &#x3D; max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) <br>            &#x3D; max(dp[i-1][1][1], -prices[i])<br>解释：k &#x3D; 0 的 base case，所以 dp[i-1][0][0] &#x3D; 0。<br>现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。<br>可以进行进一步化简去掉所有 k：<br>dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][1] + prices[i])<br>dp[i][1] &#x3D; max(dp[i-1][1], -prices[i])<br></code></pre></td></tr></table></figure><p>直接写出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = prices.length;<br><span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>    dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);<br>&#125;<br><span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 解释：</span><br>        <span class="hljs-comment">//   dp[i][0] </span><br>        <span class="hljs-comment">// = max(dp[-1][0], dp[-1][1] + prices[i])</span><br>        <span class="hljs-comment">// = max(0, -infinity + prices[i]) = 0</span><br>        dp[i][<span class="hljs-number">1</span>] = -prices[i];<br>        <span class="hljs-comment">//解释：</span><br>        <span class="hljs-comment">//   dp[i][1] </span><br>        <span class="hljs-comment">// = max(dp[-1][1], dp[-1][0] - prices[i])</span><br>        <span class="hljs-comment">// = max(-infinity, 0 - prices[i]) </span><br>        <span class="hljs-comment">// = -prices[i]</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>    dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);<br>&#125;<br><span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// k == 1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-comment">// base case: dp[-1][0] = 0, dp[-1][1] = -infinity</span><br>    <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>, dp_i_1 = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br>        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>        <span class="hljs-comment">// dp[i][1] = max(dp[i-1][1], -prices[i])</span><br>        dp_i_1 = Math.max(dp_i_1, -prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i_0;<br>&#125;<br></code></pre></td></tr></table></figure><p>两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。<br><strong>第二题，k = +infinity</strong><br>如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[i][k][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>] + prices[i])<br>dp[i][k][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i])<br>            = max(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>] - prices[i])<br>我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：<br>dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i])<br>dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i])<br></code></pre></td></tr></table></figure><p>直接翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_inf</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>, dp_i_1 = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> temp = dp_i_0;<br>        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i_0;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第三题，k = +infinity with cooldown</strong><br>每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][1] + prices[i])<br>dp[i][1] &#x3D; max(dp[i-1][1], dp[i-2][0] - prices[i])<br>解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。<br></code></pre></td></tr></table></figure><p>翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_with_cool</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>, dp_i_1 = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">int</span> dp_pre_0 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 代表 dp[i-2][0]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> temp = dp_i_0;<br>        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);<br>        dp_pre_0 = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i_0;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第四题，k = +infinity with fee</strong><br>每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][1] + prices[i])<br>dp[i][1] &#x3D; max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)<br>解释：相当于买入股票的价格升高了。<br>在第一个式子里减也是一样的，相当于卖出股票的价格减小了。<br></code></pre></td></tr></table></figure><p>直接翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_with_fee</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>, dp_i_1 = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> temp = dp_i_0;<br>        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i_0;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第五题，k = 2</strong><br>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。<br>这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">原始的动态转移方程，没有可化简的地方<br>dp[i][k][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i])<br>dp[i][k][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i])<br></code></pre></td></tr></table></figure><p>按照之前的代码，我们可能想当然这样写代码（错误的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/* 处理一下 base case*/</span> &#125;<br>    dp[i][k][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i]);<br>    dp[i][k][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>&#125;<br><span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>为什么错误？我这不是照着状态转移方程写的吗？<br>还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。比如说第一题，k = 1：<br>「代码截图」<br>这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> max_k = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][max_k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = max_k; k &gt;= <span class="hljs-number">1</span>; k--) &#123;<br>        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/*处理 base case */</span> &#125;<br>        dp[i][k][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i]);<br>        dp[i][k][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 穷举了 n × max_k × 2 个状态，正确。</span><br><span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][max_k][<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。<br>这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况全部列举出来也可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] + prices[i])<br>dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i])<br>dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i])<br>dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i])<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> dp_i10 = <span class="hljs-number">0</span>, dp_i11 = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">int</span> dp_i20 = <span class="hljs-number">0</span>, dp_i21 = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> price : prices) &#123;<br>        dp_i20 = Math.max(dp_i20, dp_i21 + price);<br>        dp_i21 = Math.max(dp_i21, dp_i10 - price);<br>        dp_i10 = Math.max(dp_i10, dp_i11 + price);<br>        dp_i11 = Math.max(dp_i11, -price);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i20;<br>&#125;<br></code></pre></td></tr></table></figure><p>有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会大惊失色，对你肃然起敬。<br><strong>第六题，k = any integer</strong><br>有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？<br>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。<br>直接把之前的代码重用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_any</span><span class="hljs-params">(<span class="hljs-keyword">int</span> max_k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-keyword">if</span> (max_k &gt; n / <span class="hljs-number">2</span>) <br>        <span class="hljs-keyword">return</span> maxProfit_k_inf(prices);<br>    <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][max_k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = max_k; k &gt;= <span class="hljs-number">1</span>; k--) &#123;<br>            <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/* 处理 base case */</span> &#125;<br>            dp[i][k][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i][k][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);     <br>        &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][max_k][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，6 道题目通过一个状态转移方程全部解决。</p><p><strong>四、最后总结</strong><br>本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。<br>关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？<br>具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有，所以给个在看/分享吧，鼓励一下我。</p><p><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8BKMP%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95">上一篇：动态规划之KMP字符匹配算法</a><br><a href="/2016/01/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%8A%A2%E6%88%BF%E5%AD%90">下一篇：团灭 LeetCode 打家劫舍问题</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找详解</title>
      <link href="2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3/"/>
      <url>2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找详解"><a href="#二分查找详解" class="headerlink" title="二分查找详解"></a>二分查找详解</h1><p>先给大家讲个笑话乐呵一下：<br>有一天阿东到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。<br>从此，图书馆丢了 N - 1 本书。<br>二分查找并不简单，Knuth 大佬（发明 KMP 算法的那位）都说二分查找：<strong>思路很简单，细节是魔鬼</strong>。很多人喜欢拿整型溢出的 bug 说事儿，但是二分查找真正的坑根本就不是那个细节问题，而是在于到底要给 <code>mid</code> 加一还是减一，while 里到底用 <code>&lt;=</code> 还是 <code>&lt;</code>。<br>你要是没有正确理解这些细节，写二分肯定就是玄学编程，有没有 bug 只能靠菩萨保佑。<strong>我特意写了一首诗来歌颂该算法，概括本文的主要内容，建议保存</strong>：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/poem.png"><br>本文就来探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。而且，我们就是要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。</p><h3 id="零、二分查找框架"><a href="#零、二分查找框架" class="headerlink" title="零、二分查找框架"></a>零、二分查找框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = ...;<br>    <span class="hljs-keyword">while</span>(...) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = ...<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ...;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节</strong>。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。<br>其中 <code>...</code> 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。<br>另外声明一下，计算 mid 时需要防止溢出，代码中 <code>left + (right - left) / 2</code> 就和 <code>(left + right) / 2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> 太大直接相加导致溢出。</p><h3 id="一、寻找一个数（基本的二分搜索）"><a href="#一、寻找一个数（基本的二分搜索）" class="headerlink" title="一、寻找一个数（基本的二分搜索）"></a>一、寻找一个数（基本的二分搜索）</h3><p>这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1、为什么 while 循环的条件中是 &lt;=，而不是 &lt;**？<br>答：因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code>。<br>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>，因为索引大小为 <code>nums.length</code> 是越界的。<br>我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。</strong>这个区间其实就是每次进行搜索的区间**。<br>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(nums[mid] == target)<br>    <span class="hljs-keyword">return</span> mid; <br></code></pre></td></tr></table></figure><p>但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？<strong>搜索区间为空的时候应该终止</strong>，意味着你没得找了，就等于没找到嘛。<br><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见<strong>这时候区间为空</strong>，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。<br><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[left, right]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，<strong>这时候区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说这区间 <code>[2, 2]</code> 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。<br>当然，如果你非要用 <code>while(left &lt; right)</code> 也可以，我们已经知道了出错的原因，就打个补丁好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><strong>2、为什么 <code>left = mid + 1</code>，<code>right = mid - 1</code>？我看有的代码是 <code>right = mid</code> 或者 <code>left = mid</code>，没有这些加加减减，到底怎么回事，怎么判断</strong>？<br>答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。<br>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[left, right]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，下一步应该去搜索哪里呢？<br>当然是去搜索 <code>[left, mid-1]</code> 或者 <code>[mid+1, right]</code> 对不对？<strong>因为 <code>mid</code> 已经搜索过，应该从搜索区间中去除</strong>。<br><strong>3、此算法有什么缺陷</strong>？<br>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。<br>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target</code> 为 2，此算法返回的索引是 2，没错。但是如果我想得到 <code>target</code> 的左侧边界，即索引 1，或者我想得到 <code>target</code> 的右侧边界，即索引 3，这样的话此算法是无法处理的。<br>这样的需求很常见，<strong>你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了</strong>。<br>我们后续的算法就来讨论这两种二分查找的算法。</p><h3 id="二、寻找左侧边界的二分搜索"><a href="#二、寻找左侧边界的二分搜索" class="headerlink" title="二、寻找左侧边界的二分搜索"></a>二、寻找左侧边界的二分搜索</h3><p>以下是最常见的代码形式，其中的标记是需要注意的细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length; <span class="hljs-comment">// 注意</span><br>    <br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123; <span class="hljs-comment">// 注意</span><br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid; <span class="hljs-comment">// 注意</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1、为什么 while 中是 <code>&lt;</code> 而不是 <code>&lt;=</code></strong>?<br>答：用相同的方法分析，因为 <code>right = nums.length</code> 而不是 <code>nums.length - 1</code>。因此每次循环的「搜索区间」是 <code>[left, right)</code> 左闭右开。<br><code>while(left &lt; right)</code> 终止的条件是 <code>left == right</code>，此时搜索区间 <code>[left, left)</code> 为空，所以可以正确终止。<br>PS：这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的：<strong>刚才的 <code>right</code> 不是 <code>nums.length - 1</code> 吗，为啥这里非要写成 <code>nums.length</code> 使得「搜索区间」变成左闭右开呢</strong>？<br>因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。<br><strong>2、为什么没有返回 -1 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办</strong>？<br>答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.jpg"><br>对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：<code>nums</code> 中小于 2 的元素有 1 个。<br>比如对于有序数组 <code>nums = [2,3,5,7]</code>, <code>target = 1</code>，算法会返回 0，含义是：<code>nums</code> 中小于 1 的元素有 0 个。<br>再比如说 <code>nums = [2,3,5,7], target = 8</code>，算法会返回 4，含义是：<code>nums</code> 中小于 8 的元素有 4 个。<br>综上可以看出，函数的返回值（即 <code>left</code> 变量的值）取值区间是闭区间 <code>[0, nums.length]</code>，所以我们简单添加两行代码就能在正确的时候 return -1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">// target 比所有数都大</span><br><span class="hljs-keyword">if</span> (left == nums.length) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-comment">// 类似之前算法的处理方式</span><br><span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><strong>3、为什么 <code>left = mid + 1</code>，<code>right = mid</code> ？和之前的算法不一样</strong>？<br>答：这个很好解释，因为我们的「搜索区间」是 <code>[left, right)</code> 左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉 <code>mid</code> 分割成两个区间，即 <code>[left, mid)</code> 或 <code>[mid + 1, right)</code>。<br><strong>4、为什么该算法能够搜索左侧边界</strong>？<br>答：关键在于对于 <code>nums[mid] == target</code> 这种情况的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (nums[mid] == target)<br>    right = mid;<br></code></pre></td></tr></table></figure><p>可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 <code>right</code>，在区间 <code>[left, mid)</code> 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。<br><strong>5、为什么返回 <code>left</code> 而不是 <code>right</code>**？<br>答：都是一样的，因为 while 终止的条件是 <code>left == right</code>。<br>**6、能不能想办法把 <code>right</code> 变成 <code>nums.length - 1</code>，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了</strong>。<br>答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改：<br>因为你非要让搜索区间两端都闭，所以 <code>right</code> 应该初始化为 <code>nums.length - 1</code>，while 的终止条件应该是 <code>left == right + 1</code>，也就是其中应该用 <code>&lt;=</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-comment">// 搜索区间为 [left, right]</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// if else ...</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 <code>left</code> 和 <code>right</code> 的更新逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>    <span class="hljs-comment">// 搜索区间变为 [mid+1, right]</span><br>    left = mid + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>    <span class="hljs-comment">// 搜索区间变为 [left, mid-1]</span><br>    right = mid - <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>    <span class="hljs-comment">// 收缩右侧边界</span><br>    right = mid - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 while 的退出条件是 <code>left == right + 1</code>，所以当 <code>target</code> 比 <code>nums</code> 中所有元素都大时，会存在以下情况使得索引越界：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/2.jpg"><br>因此，最后返回结果的代码应该检查越界情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (left &gt;= nums.length || nums[left] != target)<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> left;<br></code></pre></td></tr></table></figure><p>至此，整个算法就写完了，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 搜索区间为 [left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            <span class="hljs-comment">// 搜索区间变为 [mid+1, right]</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            <span class="hljs-comment">// 搜索区间变为 [left, mid-1]</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 收缩右侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查出界情况</span><br>    <span class="hljs-keyword">if</span> (left &gt;= nums.length || nums[left] != target)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 <code>left</code> 变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。</p><h3 id="三、寻找右侧边界的二分查找"><a href="#三、寻找右侧边界的二分查找" class="headerlink" title="三、寻找右侧边界的二分查找"></a>三、寻找右侧边界的二分查找</h3><p>类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同，已标注：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1、为什么这个算法能够找到右侧边界</strong>？<br>答：类似地，关键点还是这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>    left = mid + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>当 <code>nums[mid] == target</code> 时，不要立即返回，而是增大「搜索区间」的下界 <code>left</code>，使得区间不断向右收缩，达到锁定右侧边界的目的。<br><strong>2、为什么最后返回 <code>left - 1</code> 而不像左侧边界的函数，返回 <code>left</code>？而且我觉得这里既然是搜索右侧边界，应该返回 <code>right</code> 才对</strong>。<br>答：首先，while 循环的终止条件是 <code>left == right</code>，所以 <code>left</code> 和 <code>right</code> 是一样的，你非要体现右侧的特点，返回 <code>right - 1</code> 好了。<br>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>    left = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 这样想: mid = left - 1</span><br></code></pre></td></tr></table></figure><p><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/3.jpg"><br>因为我们对 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，就是说 while 循环结束时，<code>nums[left]</code> 一定不等于 <code>target</code> 了，而 <code>nums[left-1]</code> 可能是 <code>target</code>。<br>至于为什么 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，同左侧边界搜索，就不再赘述。<br><strong>3、为什么没有返回 -1 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办</strong>？<br>答：类似之前的左侧边界搜索，因为 while 的终止条件是 <code>left == right</code>，就是说 <code>left</code> 的取值范围是 <code>[0, nums.length]</code>，所以可以添加两行代码，正确地返回 -1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> nums[left-<span class="hljs-number">1</span>] == target ? (left-<span class="hljs-number">1</span>) : -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><strong>4、是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了</strong>。<br>答：当然可以，类似搜索左侧边界的统一写法，其实只要改两个地方就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 这里改成收缩左侧边界即可</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 这里改为检查 right 越界的情况，见下图</span><br>    <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span> || nums[right] != target)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 <code>target</code> 比所有元素都小时，<code>right</code> 会被减到 -1，所以需要在最后防止越界：<br><img src="/images/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/4.jpg"><br>至此，搜索右侧边界的二分查找的两种写法也完成了，其实将「搜索区间」统一成两端都闭反而更容易记忆，你说是吧？</p><h3 id="四、逻辑统一"><a href="#四、逻辑统一" class="headerlink" title="四、逻辑统一"></a>四、逻辑统一</h3><p>来梳理一下这些细节差异的因果逻辑：<br><strong>第一个，最基本的二分查找算法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">因为我们初始化 right = nums.length - <span class="hljs-number">1</span><br>所以决定了我们的「搜索区间」是 [left, right]<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt;= right)<br>同时也决定了 left = mid+<span class="hljs-number">1</span> 和 right = mid<span class="hljs-number">-1</span><br>因为我们只需找到一个 target 的索引即可<br>所以当 nums[mid] == target 时可以立即返回<br></code></pre></td></tr></table></figure><p><strong>第二个，寻找左侧边界的二分查找</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">因为我们初始化 right = nums.length<br>所以决定了我们的「搜索区间」是 [left, right)<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt; right)<br>同时也决定了 left = mid + <span class="hljs-number">1</span> 和 right = mid<br>因为我们需找到 target 的最左侧索引<br>所以当 nums[mid] == target 时不要立即返回<br>而要收紧右侧边界以锁定左侧边界<br></code></pre></td></tr></table></figure><p><strong>第三个，寻找右侧边界的二分查找</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">因为我们初始化 right = nums.length<br>所以决定了我们的「搜索区间」是 [left, right)<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt; right)<br>同时也决定了 left = mid + <span class="hljs-number">1</span> 和 right = mid<br>因为我们需找到 target 的最右侧索引<br>所以当 nums[mid] == target 时不要立即返回<br>而要收紧左侧边界以锁定右侧边界<br>又因为收紧左侧边界时必须 left = mid + <span class="hljs-number">1</span><br>所以最后无论返回 left 还是 right，必须减一<br></code></pre></td></tr></table></figure><p>对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的「搜索区间」，<strong>我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 直接返回</span><br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 直接返回</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 别返回，锁定左侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后要检查 left 越界的情况</span><br>    <span class="hljs-keyword">if</span> (left &gt;= nums.length || nums[left] != target)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 别返回，锁定右侧边界</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后要检查 right 越界的情况</span><br>    <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span> || nums[right] != target)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。<br>通过本文，你学会了：<br>1、分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。<br>2、注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。<br>3、如需定义左闭右开的「搜索区间」搜索左右边界，只要在 <code>nums[mid] == target</code> 时做修改即可，搜索右侧时需要减一。<br>4、如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 <code>nums[mid] == target</code> 条件处的代码和返回的逻辑即可，<strong>推荐拿小本本记下，作为二分搜索模板</strong>。<br>呵呵，此文对二分查找的问题无敌好吧！</p><p><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88">上一篇：回溯算法解题框架</a><br><a href="/2016/01/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7">下一篇：滑动窗口解题框架</a><br><a href="/2050/08/05/LeetCode%E7%A0%B4%E5%B1%80%E6%94%BB%E7%95%A5#%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode破局攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="about/index.html"/>
      <url>about/index.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="index.html">测试</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="categories/index.html"/>
      <url>categories/index.html</url>
      
        <content type="html"><![CDATA[<p>layout: categories</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="tags/index.html"/>
      <url>tags/index.html</url>
      
        <content type="html"><![CDATA[<p>layout: tags</p>]]></content>
      
    </entry>
    
    
  
</search>
